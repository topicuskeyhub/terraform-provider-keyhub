// Code generated by "terraform-provider-keyhub-generator"; DO NOT EDIT.
// Copyright (c) Topicus Security B.V.
// SPDX-License-Identifier: APSL-2.0

//lint:ignore U1000 Ignore unused functions in generated code
package provider

import (
	"golang.org/x/exp/maps"
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

func dataSourceSchemaAttrsAuditInfo(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["created_at"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["created_by"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_modified_at"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_modified_by"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGeneratedSecret(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["generated_secret"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsLinkable(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsNonLinkable(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	return schemaAttrs
}
func dataSourceSchemaAttrsRestLink(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["href"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["id"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["rel"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["type_escaped"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuditGroupAudit(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsAuditGroupAudit_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["accounts"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuditGroupAuditAccount(false),
		},
		Computed: true,
	}
	schemaAttrs["comment"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["created_at"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["created_by"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["group_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name_on_audit"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["nested_groups"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuditNestedGroupAudit(false),
		},
		Computed: true,
	}
	schemaAttrs["reviewed_at"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["reviewed_by"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["status"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["submitted_at"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["submitted_by"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuditGroupAuditAccount(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["account_uuid"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["account_valid"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["action"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["comment"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["disconnected_nested"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["end_date"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_used"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["nested"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["rights"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuditGroupAuditLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuditGroupAudit(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuditGroupAudit_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsAuditNestedGroupAudit(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["action"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["comment"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["group_uuid"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuthAccount(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"activeLogin", "audit", "groups", "pendingRecoveryRequests", "settings", "storedAttributes", "vault",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsAuthAccount_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["validity"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["account_permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(false),
		},
		Computed: true,
	}
	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["can_request_groups"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["directory"] = attr
	}

	schemaAttrs["directory_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["directory_password_change_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["directory_rotating_password"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["directory_type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["email"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["id_in_directory"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsIdentityIdentity(false),
		}
		attr.Computed = true
		schemaAttrs["identity"] = attr
	}

	schemaAttrs["key_hub_password_change_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["last_modified_at"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["license_role"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["locale"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["reregistration_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["token_password_enabled"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["two_factor_status"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["valid_in_directory"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuthAccountPrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["validity"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuthAccountRecoveryStatus(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["pending2fa_recovery_request"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["pending_password_recovery_request"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuthAccountSettings(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["default_organizational_unit"] = attr
	}

	schemaAttrs["directory_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["directory_type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["in_groups"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["in_multiple_organizational_units"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["key_hub_admin"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["multiple_organizational_units_exist"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["password_mode"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["ssh_public_key"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["two_factor_authentication"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["use_token_password"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["vault_status"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuthAccount_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["active_login"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupAccountGroupsWrapper(recurse),
		}
		attr.Computed = true
		schemaAttrs["groups"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuthAccountRecoveryStatus(recurse),
		}
		attr.Computed = true
		schemaAttrs["pending_recovery_requests"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuthAccountSettings(recurse),
		}
		attr.Computed = true
		schemaAttrs["settings"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuthStoredAccountAttributes(recurse),
		}
		attr.Computed = true
		schemaAttrs["stored_attributes"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVault(recurse),
		}
		attr.Computed = true
		schemaAttrs["vault"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsAuthPermission(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["full"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["instances"] = dsschema.ListAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["operations"] = dsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["type_escaped"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuthStoredAccountAttribute(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["value"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuthStoredAccountAttributes(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["attributes"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthStoredAccountAttribute(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsCertificateCertificate(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsCertificateCertificate_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["alias"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["certificate_data"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["expiration"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["fingerprint_sha1"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["fingerprint_sha256"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["global"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["subject_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["key_data"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsCertificateCertificatePrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["alias"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["certificate_data"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["expiration"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["fingerprint_sha1"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["fingerprint_sha256"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["global"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["subject_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsCertificateCertificate_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsClientClientApplication(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"accessprofileclients", "audit", "groupclients", "groups", "organizationalUnits", "secret", "tile", "vaultRecordCount",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsClientClientApplication_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["client_id"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["scopes"] = dsschema.ListAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["sso_application"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["last_modified_at"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["owner"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["technical_administrator"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientLdapClient(false),
		}
		attr.Computed = true
		schemaAttrs["ldap_client"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientOAuth2Client(false),
		}
		attr.Computed = true
		schemaAttrs["oauth2_client"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientSaml2Client(false),
		}
		attr.Computed = true
		schemaAttrs["saml2_client"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsClientClientApplicationLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsClientClientApplication(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsClientClientApplicationPrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["client_id"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["scopes"] = dsschema.ListAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["sso_application"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsClientClientApplication_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dataSourceSchemaAttrsProfileAccessProfileClientLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["accessprofileclients"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupGroupClientLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["groupclients"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupGroupLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["groups"] = attr
	}

	{
		attr := dataSourceSchemaAttrsOrganizationClientApplicationOrganizationalUnitLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["organizational_units"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGeneratedSecret(recurse),
		}
		attr.Computed = true
		schemaAttrs["secret"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsLaunchpadSsoApplicationLaunchpadTile(recurse),
		}
		attr.Computed = true
		schemaAttrs["tile"] = attr
	}

	schemaAttrs["vault_record_count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsClientLdapClient(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["bind_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["client_certificate"] = attr
	}

	schemaAttrs["share_secret_in_vault"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["shared_secret"] = attr
	}

	schemaAttrs["used_for_provisioning"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsClientOAuth2Client(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["account_permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["attributes"] = dsschema.MapAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["callback_uri"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["debug_mode"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["for_identity_source"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["id_token_claims"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["initiate_login_uri"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["profile"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["resource_uris"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["share_secret_in_vault"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["shared_secret"] = attr
	}

	schemaAttrs["show_landing_page"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["use_client_credentials"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsClientOAuth2ClientPermission(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsClientOAuth2ClientPermission_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["for_group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystemPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["for_system"] = attr
	}

	schemaAttrs["value"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsClientOAuth2ClientPermissionWithClient(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsClientOAuth2ClientPermission_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["for_group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystemPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["for_system"] = attr
	}

	schemaAttrs["value"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientOAuth2Client(false),
		}
		attr.Computed = true
		schemaAttrs["client"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsClientOAuth2ClientPermissionWithClientLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsClientOAuth2ClientPermissionWithClient(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsClientOAuth2ClientPermission_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsClientSaml2Client(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["attributes"] = dsschema.MapAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["metadata"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["metadata_url"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["subject_format"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryAccountDirectory(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "markers", "status",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsDirectoryAccountDirectory_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["account_validity_supported"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["base_organizational_unit"] = attr
	}

	schemaAttrs["default_directory"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["helpdesk_group"] = attr
	}

	schemaAttrs["restrict2fa"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["rotating_password"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username_customizable"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryInternalDirectory(false),
		}
		attr.Computed = true
		schemaAttrs["internal_directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryLDAPDirectory(false),
		}
		attr.Computed = true
		schemaAttrs["ldap_directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryMaintenanceDirectory(false),
		}
		attr.Computed = true
		schemaAttrs["maintenance_directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryOIDCDirectory(false),
		}
		attr.Computed = true
		schemaAttrs["oidc_directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryPendingAccountsDirectory(false),
		}
		attr.Computed = true
		schemaAttrs["pending_accounts_directory"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryAccountDirectoryLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectory(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryAccountDirectoryPrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["account_validity_supported"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryAccountDirectoryStatusReport(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["accounts"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["reason"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["status"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryAccountDirectorySummary(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["domain_restriction"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["fully_resolved_issuer"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryStatusReport(recurse),
		}
		attr.Computed = true
		schemaAttrs["status"] = attr
	}

	schemaAttrs["username_customizable"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryAccountDirectorySummaryLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectorySummary(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryAccountDirectory_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsMarkItemMarkers(recurse),
		}
		attr.Computed = true
		schemaAttrs["markers"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryStatusReport(recurse),
		}
		attr.Computed = true
		schemaAttrs["status"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryInternalDirectory(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["owner"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryLDAPDirectory(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["attributes_to_store"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["base_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["client_certificate"] = attr
	}

	schemaAttrs["dialect"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["failover_host"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["failover_trusted_certificate"] = attr
	}

	schemaAttrs["host"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["password_recovery"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["port"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["search_bind_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["search_bind_password"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["search_filter"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["tls"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["trusted_certificate"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryMaintenanceDirectory(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryOIDCDirectory(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["acr_values"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["attributes_to_store"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["client_id"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["client_secret"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["domain_restriction"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["enforces2fa"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["fully_resolved_issuer"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["issuer"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["logout_url"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["send_login_hint"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["vendor_escaped"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryPendingAccountsDirectory(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupAccountGroup(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "vault",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsGroupAccountGroup_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["admin"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["organizational_unit"] = attr
	}

	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["end_date"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupFolder(false),
		}
		attr.Computed = true
		schemaAttrs["folder"] = attr
	}

	schemaAttrs["last_used"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["provisioning_end_time"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["rights"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["visible_for_provisioning"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupAccountGroupLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsGroupAccountGroup(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupAccountGroup_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVault(recurse),
		}
		attr.Computed = true
		schemaAttrs["vault"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsGroupAccountGroupsWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsGroupAccountGroup(recurse),
		},
		Computed: true,
	}
	schemaAttrs["total_account_group_count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupAuthorizedGroupsWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsGroupGroup(recurse),
		},
		Computed: true,
	}
	schemaAttrs["group_count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroup(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"accounts", "administeredClients", "administeredSystems", "admins", "audit", "authorizedGroups", "clientPermissions", "clients", "contentAdministeredSystems", "globalRoles", "groupAccessInfo", "groupauditinginfo", "groupinfo", "helpdesk", "markers", "myaccount", "mydelegatedaccount", "nestedGroups", "ownedAccessProfiles", "ownedClients", "ownedDirectories", "ownedGroupsOnSystem", "ownedOrganizationalUnits", "ownedSystems", "recentAudits", "requeststatus", "serviceAccounts", "systems", "vault", "webhooks",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsGroupGroup_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["admin"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["organizational_unit"] = attr
	}

	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["application_administration"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupAuditConfig(false),
		}
		attr.Computed = true
		schemaAttrs["audit_config"] = attr
	}

	schemaAttrs["audit_requested"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["authorizing_group_auditing"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["authorizing_group_delegation"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["authorizing_group_membership"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["authorizing_group_provisioning"] = attr
	}

	schemaAttrs["authorizing_group_types"] = dsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupClassificationPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["classification"] = attr
	}

	schemaAttrs["description"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["extended_access"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["hide_audit_trail"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["nested_under"] = attr
	}

	schemaAttrs["private_group"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["profile_administration"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["record_trail"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["rotating_password_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["single_managed"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["vault_recovery"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["vault_requires_activation"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupAccessInfo(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["business_accounts"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupAccount(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsGroupGroupAccount_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["validity"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["directory"] = attr
	}

	schemaAttrs["disconnected_nested"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["end_date"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_used"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["nested"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["provisioning_end_time"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["rights"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["two_factor_status"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["visible_for_provisioning"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupAccountLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsGroupGroupAccount(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupAccount_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupAuditConfig(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["months"] = dsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupAuditingInfo(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["audit_due_date"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_audit_date"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["nr_accounts"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_disabled_accounts"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_disabled_managers"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_expired_vault_records"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_managers"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_vault_records_with_end_date"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupClassification(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "info",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsGroupGroupClassification_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["authorizing_group_auditing_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["authorizing_group_delegation_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["authorizing_group_membership_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["authorizing_group_provisioning_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["default_classification"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["description"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["maximum_audit_interval"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["minimum_nr_managers"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["record_trail_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["required_months"] = dsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["rotating_password_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["vault_requires_activation"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupClassificationInfo(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["nr_groups"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupClassificationPrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupClassification_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupClassificationInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["info"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupClient(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsGroupGroupClient_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["activation_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientClientApplicationPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["client"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["owner"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["technical_administrator"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupClientLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsGroupGroupClient(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupClient_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupFolder(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsGroupGroupFolder_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupFolder_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupGlobalRoleInfo(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["auditor_group_for"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimer(recurse),
		},
		Computed: true,
	}
	schemaAttrs["create_group_approve_group_for"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimer(recurse),
		},
		Computed: true,
	}
	schemaAttrs["enable_tech_admin_approve_group_for"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimer(recurse),
		},
		Computed: true,
	}
	schemaAttrs["recovery_fallback_group_for"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimer(recurse),
		},
		Computed: true,
	}
	schemaAttrs["remove_group_approve_group_for"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimer(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupInfo(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["nr_accounts"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_accounts_with_vault"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_audits"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_clients"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_provisioned_systems"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_vault_records"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsGroupGroup(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupPrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["admin"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["organizational_unit"] = attr
	}

	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupPrimerLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroup_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dataSourceSchemaAttrsGroupGroupAccountLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["accounts"] = attr
	}

	{
		attr := dataSourceSchemaAttrsClientClientApplicationLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["administered_clients"] = attr
	}

	{
		attr := dataSourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["administered_systems"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupGroupAccountLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		attr.DeprecationMessage = "This property will be removed in a future version."
		schemaAttrs["admins"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupAuthorizedGroupsWrapper(recurse),
		}
		attr.Computed = true
		schemaAttrs["authorized_groups"] = attr
	}

	{
		attr := dataSourceSchemaAttrsClientOAuth2ClientPermissionWithClientLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["client_permissions"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupGroupClientLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["clients"] = attr
	}

	{
		attr := dataSourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["content_administered_systems"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupGlobalRoleInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["global_roles"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupAccessInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["group_access_info"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupAuditingInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["groupauditinginfo"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["groupinfo"] = attr
	}

	{
		attr := dataSourceSchemaAttrsDirectoryAccountDirectorySummaryLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["helpdesk"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsMarkItemMarkers(recurse),
		}
		attr.Computed = true
		schemaAttrs["markers"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupAccount(recurse),
		}
		attr.Computed = true
		schemaAttrs["myaccount"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupAccount(recurse),
		}
		attr.Computed = true
		schemaAttrs["mydelegatedaccount"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupGroupPrimerLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["nested_groups"] = attr
	}

	{
		attr := dataSourceSchemaAttrsProfileAccessProfileLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["owned_access_profiles"] = attr
	}

	{
		attr := dataSourceSchemaAttrsClientClientApplicationLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["owned_clients"] = attr
	}

	{
		attr := dataSourceSchemaAttrsDirectoryAccountDirectoryLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["owned_directories"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningOwnedGroupOnSystemsWrapper(recurse),
		}
		attr.Computed = true
		schemaAttrs["owned_groups_on_system"] = attr
	}

	{
		attr := dataSourceSchemaAttrsOrganizationOrganizationalUnitLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["owned_organizational_units"] = attr
	}

	{
		attr := dataSourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["owned_systems"] = attr
	}

	{
		attr := dataSourceSchemaAttrsAuditGroupAuditLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["recent_audits"] = attr
	}

	schemaAttrs["requeststatus"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dataSourceSchemaAttrsServiceaccountServiceAccountLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["service_accounts"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupProvisioningGroupLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["systems"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVault(recurse),
		}
		attr.Computed = true
		schemaAttrs["vault"] = attr
	}

	{
		attr := dataSourceSchemaAttrsWebhookWebhookLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["webhooks"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsGroupProvisioningGroup(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsGroupProvisioningGroup_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["activation_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningGroupOnSystem(false),
		}
		attr.Computed = true
		schemaAttrs["group_on_system"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsGroupProvisioningGroupLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsGroupProvisioningGroup(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupProvisioningGroupLinkableWrapperWithCount(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsGroupProvisioningGroup(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupProvisioningGroup_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsIdentityAccountAttributeDefinition(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsIdentityAccountAttributeDefinition_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["format"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["system_definition"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsIdentityAccountAttributeDefinition_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsIdentityAccountAttributeRule(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsIdentityAccountAttributeRule_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["allow_override"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["allow_self_service"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsIdentityAccountAttributeDefinition(false),
		}
		attr.Computed = true
		schemaAttrs["attribute"] = attr
	}

	schemaAttrs["default_value"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["priority_directory"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["priority_external_source"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["priority_formula"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["priority_scim"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["script"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["update_automatically"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsIdentityAccountAttributeRuleLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsIdentityAccountAttributeRule(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsIdentityAccountAttributeRule_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsIdentityAccountAttributeValueSummary(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsIdentityAccountAttributeDefinition(recurse),
		}
		attr.Computed = true
		schemaAttrs["attribute"] = attr
	}

	schemaAttrs["context"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["current_value"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["date"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["expected_value"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["source"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["status"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsIdentityIdentity(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["family_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["given_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["middle_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["telephone"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsLaunchpadSsoApplicationLaunchpadTile(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["uri"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsLaunchpadVaultRecordLaunchpadTile(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	return schemaAttrs
}
func dataSourceSchemaAttrsMarkItemMarker(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["level"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["parameters"] = dsschema.MapAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsMarkItemMarkers(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["markers"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsMarkItemMarker(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsOrganizationClientApplicationOrganizationalUnit(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsOrganizationClientApplicationOrganizationalUnitLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsOrganizationClientApplicationOrganizationalUnit(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsOrganizationOrganizationalUnit(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "settings",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsOrganizationOrganizationalUnit_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["auditor_group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["create_group_approve_group"] = attr
	}

	schemaAttrs["create_group_placeholder"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["depth"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["description"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["enable_tech_admin_approve_group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["owner"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["parent"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["recovery_fallback_group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["remove_group_approve_group"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsOrganizationOrganizationalUnitLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnit(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsOrganizationOrganizationalUnitSettings(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["create_group_approve_group"] = attr
	}

	schemaAttrs["create_group_placeholder"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["enable_tech_admin_approve_group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["recovery_fallback_group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["remove_group_approve_group"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsOrganizationOrganizationalUnit_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitSettings(recurse),
		}
		attr.Computed = true
		schemaAttrs["settings"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfile(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"accountsWithAttributes", "attributeRules", "audit", "clients", "groups", "provisioning",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProfileAccessProfile_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["activate_rule_script"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["description"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["directory"] = attr
	}

	schemaAttrs["match_rule_script"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["owner"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileAccount(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProfileAccessProfileAccount_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["validity"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["activation"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["manual"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileAccountWithAttributes(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProfileAccessProfileAccount_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["validity"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["activation"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["manual"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["attributes"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsIdentityAccountAttributeValueSummary(false),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileAccountWithAttributesLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsProfileAccessProfileAccountWithAttributes(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileAccount_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileClient(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProfileAccessProfileClient_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProfileAccessProfilePrimer(false),
		}
		attr.Computed = true
		schemaAttrs["access_profile"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientClientApplicationPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["client"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileClientLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsProfileAccessProfileClient(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileClient_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileGroup(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProfileAccessProfileGroup_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProfileAccessProfilePrimer(false),
		}
		attr.Computed = true
		schemaAttrs["access_profile"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["group"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileGroupLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsProfileAccessProfileGroup(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileGroup_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsProfileAccessProfile(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfilePrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileProvisioning(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProfileAccessProfileProvisioning_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProfileAccessProfilePrimer(false),
		}
		attr.Computed = true
		schemaAttrs["access_profile"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningGroupOnSystem(false),
		}
		attr.Computed = true
		schemaAttrs["group_on_system"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileProvisioningLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsProfileAccessProfileProvisioning(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileProvisioningLinkableWrapperWithCount(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsProfileAccessProfileProvisioning(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileProvisioning_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfile_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dataSourceSchemaAttrsProfileAccessProfileAccountWithAttributesLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["accounts_with_attributes"] = attr
	}

	{
		attr := dataSourceSchemaAttrsIdentityAccountAttributeRuleLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["attribute_rules"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dataSourceSchemaAttrsProfileAccessProfileClientLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["clients"] = attr
	}

	{
		attr := dataSourceSchemaAttrsProfileAccessProfileGroupLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["groups"] = attr
	}

	{
		attr := dataSourceSchemaAttrsProfileAccessProfileProvisioningLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["provisioning"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningAbstractProvisionedLDAP(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["attributes"] = dsschema.MapAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["base_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["bind_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["bind_password"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["client_certificate"] = attr
	}

	schemaAttrs["failover_host"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["failover_trusted_certificate"] = attr
	}

	schemaAttrs["group_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["host"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["object_classes"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["port"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["service_account_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["ssh_public_key_support"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["tls"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["trusted_certificate"] = attr
	}

	schemaAttrs["user_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningCircuitBreakerStatistics(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["number_of_failed_calls"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["number_of_not_permitted_calls"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["number_of_successful_calls"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["state"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningGroupOnSystem(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"accessProfileProvisioning", "audit", "provgroups", "serviceAccounts",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProvisioningGroupOnSystem_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name_in_system"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["short_name_in_system"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["owner"] = attr
	}

	schemaAttrs["provisioning_enabled"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningGroupOnSystemLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsProvisioningGroupOnSystem(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningGroupOnSystemPrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name_in_system"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["short_name_in_system"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningGroupOnSystemTypes(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["types"] = dsschema.ListAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningGroupOnSystem_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dataSourceSchemaAttrsProfileAccessProfileProvisioningLinkableWrapperWithCount(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["access_profile_provisioning"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupProvisioningGroupLinkableWrapperWithCount(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["provgroups"] = attr
	}

	{
		attr := dataSourceSchemaAttrsServiceaccountServiceAccountPrimerLinkableWrapperWithCount(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["service_accounts"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningOwnedGroupOnSystemsWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsProvisioningGroupOnSystem(recurse),
		},
		Computed: true,
	}
	schemaAttrs["unlinked_count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionNumberSequence(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "systems",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProvisioningProvisionNumberSequence_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["account_count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["next_uid"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionNumberSequence_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dataSourceSchemaAttrsProvisioningProvisionedSystemPrimerLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["systems"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedAD(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["sam_account_name_scheme"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedAccount(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProvisioningProvisionedAccount_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["validity"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uid"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedAccount_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedAzureOIDCDirectory(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["accounts_writable"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["directory"] = attr
	}

	schemaAttrs["tenant"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedAzureSyncLDAPDirectory(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["client_id"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["client_secret"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["directory"] = attr
	}

	schemaAttrs["tenant"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedAzureTenant(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["client_id"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["client_secret"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["idp_domain"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["tenant"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedInternalLDAP(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientLdapClient(recurse),
		}
		attr.Computed = true
		schemaAttrs["client"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedLDAP(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["gid"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["hashing_scheme"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionNumberSequence(recurse),
		}
		attr.Computed = true
		schemaAttrs["numbering"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedLDAPDirectory(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["accounts_writable"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["directory"] = attr
	}

	schemaAttrs["gid"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["group_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["hashing_scheme"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionNumberSequence(recurse),
		}
		attr.Computed = true
		schemaAttrs["numbering"] = attr
	}

	schemaAttrs["sam_account_name_scheme"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["ssh_public_key_support"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedNamespace(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystemPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["base_system"] = attr
	}

	schemaAttrs["group_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["service_account_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedSCIM(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["authentication_scheme"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["basic_auth_password"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["basic_auth_username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["bearer_token"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["custom_header_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["custom_header_value"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["url"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["vendor_escaped"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedSystem(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"account", "audit", "issuedPermissions", "loginName", "managementPermissions", "markers", "statistics", "supportedGroupTypes",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProvisioningProvisionedSystem_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["admin_permissions"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["content_admin_permissions"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["organizational_unit"] = attr
	}

	schemaAttrs["owner_permissions"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["account_count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystem_cleanupPeriod(false),
		}
		attr.Computed = true
		schemaAttrs["cleanup_period"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["content_administrator"] = attr
	}

	schemaAttrs["external_uuid"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["group_on_system_provisioning"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["owner"] = attr
	}

	schemaAttrs["self_service_existing_groups"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["self_service_new_groups"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["self_service_new_namespaces"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["self_service_service_accounts"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["should_destroy_unknown_accounts"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["technical_administrator"] = attr
	}

	schemaAttrs["username_prefix"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningAbstractProvisionedLDAP(false),
		}
		attr.Computed = true
		schemaAttrs["abstract_provisioned_ldap"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedAD(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_a_d"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedAzureOIDCDirectory(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_azure_oidc_directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedAzureSyncLDAPDirectory(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_azure_sync_ldap_directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedAzureTenant(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_azure_tenant"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedInternalLDAP(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_internal_ldap"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedLDAP(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_ldap"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedLDAPDirectory(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_ldap_directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedNamespace(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_namespace"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSCIM(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_scim"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystem(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedSystemPrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["admin_permissions"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["content_admin_permissions"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["organizational_unit"] = attr
	}

	schemaAttrs["owner_permissions"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedSystemPrimerLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystemPrimer(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedSystem_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedAccount(recurse),
		}
		attr.Computed = true
		schemaAttrs["account"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dataSourceSchemaAttrsClientOAuth2ClientPermissionWithClientLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["issued_permissions"] = attr
	}

	schemaAttrs["login_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisioningManagementPermissions(recurse),
		}
		attr.Computed = true
		schemaAttrs["management_permissions"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsMarkItemMarkers(recurse),
		}
		attr.Computed = true
		schemaAttrs["markers"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningCircuitBreakerStatistics(recurse),
		}
		attr.Computed = true
		schemaAttrs["statistics"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningGroupOnSystemTypes(recurse),
		}
		attr.Computed = true
		schemaAttrs["supported_group_types"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedSystem_cleanupPeriod(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["days"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["months"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["years"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisioningManagementPermissions(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["create_new_groups_allowed"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["create_service_accounts_allowed"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["reuse_existing_groups_allowed"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsServiceaccountServiceAccount(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "groups", "secret", "supportedFeatures",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsServiceaccountServiceAccount_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystemPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["system"] = attr
	}

	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["description"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["password"] = attr
	}

	schemaAttrs["password_rotation"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["ssh_public_key"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["technical_administrator"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsServiceaccountServiceAccountGroup(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsServiceaccountServiceAccountGroup_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name_in_system"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["short_name_in_system"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsServiceaccountServiceAccountGroupLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsServiceaccountServiceAccountGroup(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsServiceaccountServiceAccountGroup_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsServiceaccountServiceAccountLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsServiceaccountServiceAccount(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsServiceaccountServiceAccountPrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystemPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["system"] = attr
	}

	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsServiceaccountServiceAccountPrimerLinkableWrapperWithCount(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsServiceaccountServiceAccountPrimer(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsServiceaccountServiceAccountSupportedFeatures(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["ssh_public_key"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsServiceaccountServiceAccount_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dataSourceSchemaAttrsServiceaccountServiceAccountGroupLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["groups"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGeneratedSecret(recurse),
		}
		attr.Computed = true
		schemaAttrs["secret"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsServiceaccountServiceAccountSupportedFeatures(recurse),
		}
		attr.Computed = true
		schemaAttrs["supported_features"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsVaultPasswordMetadata(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["dictionary"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["duplicate"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["hash"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["length"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["lower_count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["number_count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["special_count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["strength"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["upper_count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsVaultVault(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["access_available"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["records"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsVaultVaultRecord(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsVaultVaultActivationStatus(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["activated"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["activation_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsVaultVaultRecord(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"activationStatus", "audit", "parent", "passwordMetadata", "secret", "shareSummary", "shares", "tile", "vaultholder",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsVaultVaultRecord_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["color"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["share_end_time"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["derived"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["end_date"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["filename"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["types"] = dsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["url"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["warning_period"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsVaultVaultRecordPrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["color"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["share_end_time"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsVaultVaultRecordPrimerLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordPrimer(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsVaultVaultRecordSecrets(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["comment"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["file"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["password"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["totp"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsVaultVaultRecordShare(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsVaultVaultRecordShareSummary(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["children"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordShare(recurse),
		},
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordShare(recurse),
		}
		attr.Computed = true
		schemaAttrs["parent"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsVaultVaultRecord_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultActivationStatus(recurse),
		}
		attr.Computed = true
		schemaAttrs["activation_status"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["parent"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultPasswordMetadata(recurse),
		}
		attr.Computed = true
		schemaAttrs["password_metadata"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordSecrets(recurse),
		}
		attr.Computed = true
		schemaAttrs["secret"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordShareSummary(recurse),
		}
		attr.Computed = true
		schemaAttrs["share_summary"] = attr
	}

	{
		attr := dataSourceSchemaAttrsVaultVaultRecordPrimerLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["shares"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsLaunchpadVaultRecordLaunchpadTile(recurse),
		}
		attr.Computed = true
		schemaAttrs["tile"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsLinkable(recurse),
		}
		attr.Computed = true
		schemaAttrs["vaultholder"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsWebhookWebhook(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsWebhookWebhook_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuthAccountPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["account"] = attr
	}

	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["all_types"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["authentication_scheme"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["basic_auth_password"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["basic_auth_username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["bearer_token"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientClientApplicationPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["client"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimer(false),
		}
		attr.Computed = true
		schemaAttrs["client_certificate"] = attr
	}

	schemaAttrs["custom_header_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["custom_header_value"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["group"] = attr
	}

	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystemPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["system"] = attr
	}

	schemaAttrs["tls"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimer(false),
		}
		attr.Computed = true
		schemaAttrs["trusted_certificate"] = attr
	}

	schemaAttrs["types"] = dsschema.ListAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["url"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["verbose_payloads"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsWebhookWebhookLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsWebhookWebhook(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsWebhookWebhook_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
