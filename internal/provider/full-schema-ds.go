// Code generated by "terraform-provider-keyhub-generator"; DO NOT EDIT.
// Copyright (c) Topicus Security B.V.
// SPDX-License-Identifier: APSL-2.0

//lint:ignore U1000 Ignore unused functions in generated code
package provider

import (
	"golang.org/x/exp/maps"
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

func dataSourceSchemaAttrsAuditInfoRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["created_at"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["created_by"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_modified_at"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_modified_by"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGeneratedSecret(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["generated_secret"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["old_secret"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["regenerate"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGeneratedSecretRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["generated_secret"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["old_secret"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["regenerate"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsLinkable(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsLinkableRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsNonLinkable(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	return schemaAttrs
}
func dataSourceSchemaAttrsNonLinkableRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	return schemaAttrs
}
func dataSourceSchemaAttrsRestLink(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["href"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["id"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["rel"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["type_escaped"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsRestLinkRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["href"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["id"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["rel"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["type_escaped"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuditGroupAuditRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsAuditGroupAudit_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["accounts"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuditGroupAuditAccountRO(false),
		},
		Computed: true,
	}
	schemaAttrs["comment"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["created_at"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["created_by"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["group_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name_on_audit"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["nested_groups"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuditNestedGroupAuditRO(false),
		},
		Computed: true,
	}
	schemaAttrs["reviewed_at"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["reviewed_by"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["status"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["submitted_at"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["submitted_by"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuditGroupAuditAccountRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["account_uuid"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["account_valid"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["action"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["comment"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["disconnected_nested"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["end_date"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_used"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["nested"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["rights"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuditGroupAuditLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuditGroupAuditRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuditGroupAudit_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsAuditNestedGroupAuditRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["action"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["comment"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["group_uuid"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuthAccount(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"activeLogin", "audit", "groups", "pendingRecoveryRequests", "settings", "storedAttributes", "vault",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsAuthAccount_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["validity"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["account_permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(false),
		},
		Computed: true,
	}
	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["can_request_groups"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["directory"] = attr
	}

	schemaAttrs["directory_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["directory_password_change_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["directory_rotating_password"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["directory_type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["email"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["id_in_directory"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsIdentityIdentity(false),
		}
		attr.Computed = true
		schemaAttrs["identity"] = attr
	}

	schemaAttrs["key_hub_password_change_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["last_modified_at"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["license_role"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["locale"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["reregistration_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["token_password_enabled"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["two_factor_status"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["valid_in_directory"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuthAccountPrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["validity"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuthAccountPrimerRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["validity"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuthAccountRecoveryStatusRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["pending2fa_recovery_request"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["pending_password_recovery_request"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuthAccountSettingsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["default_organizational_unit"] = attr
	}

	schemaAttrs["directory_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["directory_type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["in_groups"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["in_multiple_organizational_units"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["key_hub_admin"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["multiple_organizational_units_exist"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["password_mode"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["ssh_public_key"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["two_factor_authentication"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["use_token_password"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["vault_status"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuthAccount_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["active_login"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupAccountGroupLinkableWrapperWithCountRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["groups"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuthAccountRecoveryStatusRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["pending_recovery_requests"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuthAccountSettingsRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["settings"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuthStoredAccountAttributesRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["stored_attributes"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["vault"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsAuthPermission(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["full"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["instances"] = dsschema.ListAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["operations"] = dsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["type_escaped"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuthPermissionRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["full"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["instances"] = dsschema.ListAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["operations"] = dsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["type_escaped"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuthStoredAccountAttributeRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["value"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsAuthStoredAccountAttributesRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["attributes"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthStoredAccountAttributeRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsCertificateCertificate(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsCertificateCertificate_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["alias"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["certificate_data"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["expiration"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["fingerprint_sha1"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["fingerprint_sha256"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["global"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["subject_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["key_data"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsCertificateCertificatePrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["alias"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["certificate_data"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["expiration"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["fingerprint_sha1"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["fingerprint_sha256"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["global"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["subject_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsCertificateCertificatePrimerRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["alias"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["certificate_data"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["expiration"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["fingerprint_sha1"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["fingerprint_sha256"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["global"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["subject_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsCertificateCertificate_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsClientClientApplication(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"accessprofileclients", "audit", "groupclients", "groups", "organizationalUnits", "secret", "tile", "vaultRecordCount",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsClientClientApplication_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["client_id"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["scopes"] = dsschema.ListAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["sso_application"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["last_modified_at"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["owner"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["technical_administrator"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientLdapClient(false),
		}
		attr.Computed = true
		schemaAttrs["ldap_client"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientOAuth2Client(false),
		}
		attr.Computed = true
		schemaAttrs["oauth2_client"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientSaml2Client(false),
		}
		attr.Computed = true
		schemaAttrs["saml2_client"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsClientClientApplicationRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"accessprofileclients", "audit", "groupclients", "groups", "organizationalUnits", "secret", "tile", "vaultRecordCount",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsClientClientApplication_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["client_id"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["scopes"] = dsschema.ListAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["sso_application"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["last_modified_at"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["owner"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["technical_administrator"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientLdapClientRO(false),
		}
		attr.Computed = true
		schemaAttrs["ldap_client"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientOAuth2ClientRO(false),
		}
		attr.Computed = true
		schemaAttrs["oauth2_client"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientSaml2ClientRO(false),
		}
		attr.Computed = true
		schemaAttrs["saml2_client"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsClientClientApplicationLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsClientClientApplicationRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsClientClientApplicationPrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["client_id"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["scopes"] = dsschema.ListAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["sso_application"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsClientClientApplicationPrimerRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["client_id"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["scopes"] = dsschema.ListAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["sso_application"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsClientClientApplication_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dataSourceSchemaAttrsProfileAccessProfileClientLinkableWrapperWithCount(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["accessprofileclients"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupGroupClientLinkableWrapperWithCount(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["groupclients"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupGroupLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["groups"] = attr
	}

	{
		attr := dataSourceSchemaAttrsOrganizationClientApplicationOrganizationalUnitLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["organizational_units"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGeneratedSecret(recurse),
		}
		attr.Computed = true
		schemaAttrs["secret"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsLaunchpadSsoApplicationLaunchpadTile(recurse),
		}
		attr.Computed = true
		schemaAttrs["tile"] = attr
	}

	schemaAttrs["vault_record_count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsClientClientApplication_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dataSourceSchemaAttrsProfileAccessProfileClientLinkableWrapperWithCountRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["accessprofileclients"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupGroupClientLinkableWrapperWithCountRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["groupclients"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupGroupLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["groups"] = attr
	}

	{
		attr := dataSourceSchemaAttrsOrganizationClientApplicationOrganizationalUnitLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["organizational_units"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGeneratedSecretRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["secret"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsLaunchpadSsoApplicationLaunchpadTileRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["tile"] = attr
	}

	schemaAttrs["vault_record_count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsClientLdapClient(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["bind_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["client_certificate"] = attr
	}

	schemaAttrs["share_secret_in_vault"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["shared_secret"] = attr
	}

	schemaAttrs["used_for_provisioning"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsClientLdapClientRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["bind_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["client_certificate"] = attr
	}

	schemaAttrs["share_secret_in_vault"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["shared_secret"] = attr
	}

	schemaAttrs["used_for_provisioning"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsClientOAuth2Client(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["account_permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["attributes"] = dsschema.MapAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["callback_uri"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["debug_mode"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["for_identity_source"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["id_token_claims"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["initiate_login_uri"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["profile"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["resource_uris"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["share_secret_in_vault"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["shared_secret"] = attr
	}

	schemaAttrs["show_landing_page"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["use_client_credentials"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsClientOAuth2ClientRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["account_permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["attributes"] = dsschema.MapAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["callback_uri"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["debug_mode"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["for_identity_source"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["id_token_claims"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["initiate_login_uri"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["profile"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["resource_uris"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["share_secret_in_vault"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["shared_secret"] = attr
	}

	schemaAttrs["show_landing_page"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["use_client_credentials"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsClientOAuth2ClientPermission(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsClientOAuth2ClientPermission_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["for_group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystemPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["for_system"] = attr
	}

	schemaAttrs["value"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsClientOAuth2ClientPermissionRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsClientOAuth2ClientPermission_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["for_group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystemPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["for_system"] = attr
	}

	schemaAttrs["value"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsClientOAuth2ClientPermissionWithClient(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsClientOAuth2ClientPermission_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["for_group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystemPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["for_system"] = attr
	}

	schemaAttrs["value"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientOAuth2Client(false),
		}
		attr.Computed = true
		schemaAttrs["client"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsClientOAuth2ClientPermissionWithClientRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsClientOAuth2ClientPermission_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["for_group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystemPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["for_system"] = attr
	}

	schemaAttrs["value"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientOAuth2ClientRO(false),
		}
		attr.Computed = true
		schemaAttrs["client"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsClientOAuth2ClientPermissionWithClientLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsClientOAuth2ClientPermissionWithClient(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsClientOAuth2ClientPermissionWithClientLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsClientOAuth2ClientPermissionWithClientRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsClientOAuth2ClientPermission_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsClientOAuth2ClientPermission_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsClientSaml2Client(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["attributes"] = dsschema.MapAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["metadata"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["metadata_url"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["subject_format"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsClientSaml2ClientRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["attributes"] = dsschema.MapAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["metadata"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["metadata_url"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["subject_format"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryAccountDirectory(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "markers", "status",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsDirectoryAccountDirectory_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["account_validity_supported"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["base_organizational_unit"] = attr
	}

	schemaAttrs["default_directory"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["helpdesk_group"] = attr
	}

	schemaAttrs["restrict2fa"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["rotating_password"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username_customizable"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryInternalDirectory(false),
		}
		attr.Computed = true
		schemaAttrs["internal_directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryLDAPDirectory(false),
		}
		attr.Computed = true
		schemaAttrs["ldap_directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryMaintenanceDirectory(false),
		}
		attr.Computed = true
		schemaAttrs["maintenance_directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryOIDCDirectory(false),
		}
		attr.Computed = true
		schemaAttrs["oidc_directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryPendingAccountsDirectory(false),
		}
		attr.Computed = true
		schemaAttrs["pending_accounts_directory"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryAccountDirectoryRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "markers", "status",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsDirectoryAccountDirectory_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["account_validity_supported"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["base_organizational_unit"] = attr
	}

	schemaAttrs["default_directory"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["helpdesk_group"] = attr
	}

	schemaAttrs["restrict2fa"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["rotating_password"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username_customizable"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryInternalDirectoryRO(false),
		}
		attr.Computed = true
		schemaAttrs["internal_directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryLDAPDirectoryRO(false),
		}
		attr.Computed = true
		schemaAttrs["ldap_directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryMaintenanceDirectoryRO(false),
		}
		attr.Computed = true
		schemaAttrs["maintenance_directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryOIDCDirectoryRO(false),
		}
		attr.Computed = true
		schemaAttrs["oidc_directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryPendingAccountsDirectoryRO(false),
		}
		attr.Computed = true
		schemaAttrs["pending_accounts_directory"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryAccountDirectoryLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryAccountDirectoryPrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["account_validity_supported"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryAccountDirectoryPrimerRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["account_validity_supported"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryAccountDirectoryStatusReportRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["accounts"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["reason"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["status"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryAccountDirectorySummaryRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["domain_restriction"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["fully_resolved_issuer"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryStatusReportRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["status"] = attr
	}

	schemaAttrs["username_customizable"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryAccountDirectorySummaryLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectorySummaryRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryAccountDirectory_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsMarkItemMarkersRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["markers"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryStatusReportRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["status"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryAccountDirectory_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsMarkItemMarkersRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["markers"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryStatusReportRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["status"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryInternalDirectory(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["owner"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryInternalDirectoryRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["owner"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryLDAPDirectory(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["attributes_to_store"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["base_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["client_certificate"] = attr
	}

	schemaAttrs["dialect"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["failover_host"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["failover_trusted_certificate"] = attr
	}

	schemaAttrs["host"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["password_recovery"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["port"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["search_bind_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["search_bind_password"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["search_filter"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["tls"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["trusted_certificate"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryLDAPDirectoryRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["attributes_to_store"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["base_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["client_certificate"] = attr
	}

	schemaAttrs["dialect"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["failover_host"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["failover_trusted_certificate"] = attr
	}

	schemaAttrs["host"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["password_recovery"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["port"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["search_bind_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["search_bind_password"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["search_filter"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["tls"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["trusted_certificate"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryMaintenanceDirectory(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryMaintenanceDirectoryRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryOIDCDirectory(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["acr_values"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["attributes_to_store"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["client_id"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["client_secret"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["domain_restriction"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["enforces2fa"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["fully_resolved_issuer"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["issuer"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["logout_url"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["send_login_hint"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["vendor_escaped"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryOIDCDirectoryRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["acr_values"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["attributes_to_store"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["client_id"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["client_secret"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["domain_restriction"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["enforces2fa"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["fully_resolved_issuer"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["issuer"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["logout_url"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["send_login_hint"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["vendor_escaped"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryPendingAccountsDirectory(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	return schemaAttrs
}
func dataSourceSchemaAttrsDirectoryPendingAccountsDirectoryRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupAccountGroupRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "vault",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsGroupAccountGroup_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["admin"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["organizational_unit"] = attr
	}

	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["end_date"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupFolderRO(false),
		}
		attr.Computed = true
		schemaAttrs["folder"] = attr
	}

	schemaAttrs["last_used"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["provisioning_end_time"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["rights"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["visible_for_provisioning"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupAccountGroupLinkableWrapperWithCountRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsGroupAccountGroupRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupAccountGroup_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["vault"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroup(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"accounts", "administeredClients", "administeredSystems", "admins", "audit", "authorizedGroups", "clientPermissions", "clients", "contentAdministeredSystems", "globalRoles", "groupAccessInfo", "groupauditinginfo", "groupinfo", "helpdesk", "markers", "myaccount", "mydelegatedaccount", "nestedGroups", "ownedAccessProfiles", "ownedClients", "ownedDirectories", "ownedGroupsOnSystem", "ownedOrganizationalUnits", "ownedSystems", "recentAudits", "requeststatus", "serviceAccounts", "systems", "vault", "webhooks",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsGroupGroup_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["admin"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["organizational_unit"] = attr
	}

	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["application_administration"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupAuditConfig(false),
		}
		attr.Computed = true
		schemaAttrs["audit_config"] = attr
	}

	schemaAttrs["audit_requested"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["authorizing_group_auditing"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["authorizing_group_delegation"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["authorizing_group_membership"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["authorizing_group_provisioning"] = attr
	}

	schemaAttrs["authorizing_group_types"] = dsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupClassificationPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["classification"] = attr
	}

	schemaAttrs["description"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["extended_access"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["hide_audit_trail"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["nested_under"] = attr
	}

	schemaAttrs["private_group"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["profile_administration"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["record_trail"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["rotating_password_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["single_managed"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["vault_recovery"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["vault_requires_activation"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"accounts", "administeredClients", "administeredSystems", "admins", "audit", "authorizedGroups", "clientPermissions", "clients", "contentAdministeredSystems", "globalRoles", "groupAccessInfo", "groupauditinginfo", "groupinfo", "helpdesk", "markers", "myaccount", "mydelegatedaccount", "nestedGroups", "ownedAccessProfiles", "ownedClients", "ownedDirectories", "ownedGroupsOnSystem", "ownedOrganizationalUnits", "ownedSystems", "recentAudits", "requeststatus", "serviceAccounts", "systems", "vault", "webhooks",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsGroupGroup_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["admin"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["organizational_unit"] = attr
	}

	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["application_administration"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupAuditConfigRO(false),
		}
		attr.Computed = true
		schemaAttrs["audit_config"] = attr
	}

	schemaAttrs["audit_requested"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["authorizing_group_auditing"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["authorizing_group_delegation"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["authorizing_group_membership"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["authorizing_group_provisioning"] = attr
	}

	schemaAttrs["authorizing_group_types"] = dsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupClassificationPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["classification"] = attr
	}

	schemaAttrs["description"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["extended_access"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["hide_audit_trail"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["nested_under"] = attr
	}

	schemaAttrs["private_group"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["profile_administration"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["record_trail"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["rotating_password_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["single_managed"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["vault_recovery"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["vault_requires_activation"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupAccessInfoRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["business_accounts"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupAccount(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsGroupGroupAccount_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["validity"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["directory"] = attr
	}

	schemaAttrs["disconnected_nested"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["end_date"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_used"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["nested"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["provisioning_end_time"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["provisioning_permission_end_time"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["rights"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["two_factor_status"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["visible_for_provisioning"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupAccountRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsGroupGroupAccount_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["validity"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["directory"] = attr
	}

	schemaAttrs["disconnected_nested"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["end_date"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_used"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["nested"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["provisioning_end_time"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["provisioning_permission_end_time"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["rights"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["two_factor_status"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["visible_for_provisioning"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupAccountLinkableWrapper(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsGroupGroupAccount(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupAccountLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsGroupGroupAccountRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupAccount_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupAccount_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupAuditConfig(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["months"] = dsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupAuditConfigRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["months"] = dsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupAuditingInfoRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["audit_due_date"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_audit_date"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["nr_accounts"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_disabled_accounts"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_disabled_managers"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_expired_vault_records"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_managers"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_vault_records_with_end_date"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupClassification(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "info",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsGroupGroupClassification_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["authorizing_group_auditing_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["authorizing_group_delegation_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["authorizing_group_membership_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["authorizing_group_provisioning_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["default_classification"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["description"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["maximum_audit_interval"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["minimum_nr_managers"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["record_trail_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["required_months"] = dsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["rotating_password_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["vault_requires_activation"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupClassificationInfoRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["nr_groups"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupClassificationPrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupClassificationPrimerRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupClassification_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupClassificationInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["info"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupClient(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsGroupGroupClient_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["activation_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientClientApplicationPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["client"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["owner"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["technical_administrator"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupClientRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsGroupGroupClient_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["activation_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientClientApplicationPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["client"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["owner"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["technical_administrator"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupClientLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsGroupGroupClientRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupClientLinkableWrapperWithCount(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsGroupGroupClient(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupClientLinkableWrapperWithCountRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsGroupGroupClientRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupClient_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupClient_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupFolderRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsGroupGroupFolder_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupFolder_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupGlobalRoleInfoRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["auditor_group_for"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["create_group_approve_group_for"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["enable_tech_admin_approve_group_for"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["recovery_fallback_group_for"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["remove_group_approve_group_for"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupInfoRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["nr_accounts"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_accounts_with_vault"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_audits"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_clients"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_provisioned_systems"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_vault_records"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsGroupGroupRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupLinkableWrapperWithCountRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsGroupGroupRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupPrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["admin"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["organizational_unit"] = attr
	}

	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupPrimerRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["admin"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["organizational_unit"] = attr
	}

	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroupPrimerLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroup_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dataSourceSchemaAttrsGroupGroupAccountLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["accounts"] = attr
	}

	{
		attr := dataSourceSchemaAttrsClientClientApplicationLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["administered_clients"] = attr
	}

	{
		attr := dataSourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["administered_systems"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupGroupAccountLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		attr.DeprecationMessage = "This property will be removed in a future version."
		schemaAttrs["admins"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupGroupLinkableWrapperWithCountRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["authorized_groups"] = attr
	}

	{
		attr := dataSourceSchemaAttrsClientOAuth2ClientPermissionWithClientLinkableWrapper(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["client_permissions"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupGroupClientLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["clients"] = attr
	}

	{
		attr := dataSourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["content_administered_systems"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupGlobalRoleInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["global_roles"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupAccessInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["group_access_info"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupAuditingInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["groupauditinginfo"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["groupinfo"] = attr
	}

	{
		attr := dataSourceSchemaAttrsDirectoryAccountDirectorySummaryLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["helpdesk"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsMarkItemMarkersRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["markers"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupAccountRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["myaccount"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupAccountRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["mydelegatedaccount"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupGroupPrimerLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["nested_groups"] = attr
	}

	{
		attr := dataSourceSchemaAttrsProfileAccessProfileLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["owned_access_profiles"] = attr
	}

	{
		attr := dataSourceSchemaAttrsClientClientApplicationLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["owned_clients"] = attr
	}

	{
		attr := dataSourceSchemaAttrsDirectoryAccountDirectoryLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["owned_directories"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningOwnedGroupOnSystemsWrapperRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["owned_groups_on_system"] = attr
	}

	{
		attr := dataSourceSchemaAttrsOrganizationOrganizationalUnitLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["owned_organizational_units"] = attr
	}

	{
		attr := dataSourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["owned_systems"] = attr
	}

	{
		attr := dataSourceSchemaAttrsAuditGroupAuditLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["recent_audits"] = attr
	}

	schemaAttrs["requeststatus"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dataSourceSchemaAttrsServiceaccountServiceAccountLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["service_accounts"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupProvisioningGroupLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["systems"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["vault"] = attr
	}

	{
		attr := dataSourceSchemaAttrsWebhookWebhookLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["webhooks"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsGroupGroup_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dataSourceSchemaAttrsGroupGroupAccountLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["accounts"] = attr
	}

	{
		attr := dataSourceSchemaAttrsClientClientApplicationLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["administered_clients"] = attr
	}

	{
		attr := dataSourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["administered_systems"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupGroupAccountLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		attr.DeprecationMessage = "This property will be removed in a future version."
		schemaAttrs["admins"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupGroupLinkableWrapperWithCountRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["authorized_groups"] = attr
	}

	{
		attr := dataSourceSchemaAttrsClientOAuth2ClientPermissionWithClientLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["client_permissions"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupGroupClientLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["clients"] = attr
	}

	{
		attr := dataSourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["content_administered_systems"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupGlobalRoleInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["global_roles"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupAccessInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["group_access_info"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupAuditingInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["groupauditinginfo"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["groupinfo"] = attr
	}

	{
		attr := dataSourceSchemaAttrsDirectoryAccountDirectorySummaryLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["helpdesk"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsMarkItemMarkersRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["markers"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupAccountRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["myaccount"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupAccountRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["mydelegatedaccount"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupGroupPrimerLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["nested_groups"] = attr
	}

	{
		attr := dataSourceSchemaAttrsProfileAccessProfileLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["owned_access_profiles"] = attr
	}

	{
		attr := dataSourceSchemaAttrsClientClientApplicationLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["owned_clients"] = attr
	}

	{
		attr := dataSourceSchemaAttrsDirectoryAccountDirectoryLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["owned_directories"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningOwnedGroupOnSystemsWrapperRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["owned_groups_on_system"] = attr
	}

	{
		attr := dataSourceSchemaAttrsOrganizationOrganizationalUnitLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["owned_organizational_units"] = attr
	}

	{
		attr := dataSourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["owned_systems"] = attr
	}

	{
		attr := dataSourceSchemaAttrsAuditGroupAuditLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["recent_audits"] = attr
	}

	schemaAttrs["requeststatus"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dataSourceSchemaAttrsServiceaccountServiceAccountLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["service_accounts"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupProvisioningGroupLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["systems"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["vault"] = attr
	}

	{
		attr := dataSourceSchemaAttrsWebhookWebhookLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["webhooks"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsGroupProvisioningGroupRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsGroupProvisioningGroup_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["activation_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningGroupOnSystemRO(false),
		}
		attr.Computed = true
		schemaAttrs["group_on_system"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsGroupProvisioningGroupLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsGroupProvisioningGroupRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupProvisioningGroupLinkableWrapperWithCountRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsGroupProvisioningGroupRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsGroupProvisioningGroup_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsIdentityAccountAttributeDefinition(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsIdentityAccountAttributeDefinition_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["format"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["list"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["system_definition"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["unique"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsIdentityAccountAttributeDefinitionRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsIdentityAccountAttributeDefinition_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["format"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["list"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["system_definition"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["unique"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsIdentityAccountAttributeDefinition_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsIdentityAccountAttributeDefinition_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsIdentityAccountAttributeRuleRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsIdentityAccountAttributeRule_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["allow_override"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["allow_self_service"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsIdentityAccountAttributeDefinitionRO(false),
		}
		attr.Computed = true
		schemaAttrs["attribute"] = attr
	}

	schemaAttrs["default_value"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["priority_directory"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["priority_external_source"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["priority_formula"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["priority_scim"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["script"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["update_automatically"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsIdentityAccountAttributeRuleLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsIdentityAccountAttributeRuleRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsIdentityAccountAttributeRule_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsIdentityAccountAttributeValueSummaryRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsIdentityAccountAttributeDefinitionRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["attribute"] = attr
	}

	schemaAttrs["context"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["current_value"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["date"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["expected_value"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["source"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["status"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsIdentityIdentity(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["family_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["given_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["middle_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["private_email"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["private_telephone"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["telephone"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsLaunchpadSsoApplicationLaunchpadTile(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["uri"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsLaunchpadSsoApplicationLaunchpadTileRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["uri"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsLaunchpadVaultRecordLaunchpadTile(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	return schemaAttrs
}
func dataSourceSchemaAttrsLaunchpadVaultRecordLaunchpadTileRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	return schemaAttrs
}
func dataSourceSchemaAttrsMarkItemMarkerRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["level"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["parameters"] = dsschema.MapAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsMarkItemMarkersRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["markers"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsMarkItemMarkerRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsMiscAttributeCustomization(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsIdentityAccountAttributeDefinition(recurse),
		}
		attr.Computed = true
		schemaAttrs["attribute_definition"] = attr
	}

	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["script"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsMiscAttributeCustomizationRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsIdentityAccountAttributeDefinitionRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["attribute_definition"] = attr
	}

	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["script"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsOrganizationClientApplicationOrganizationalUnitRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsOrganizationClientApplicationOrganizationalUnitLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsOrganizationClientApplicationOrganizationalUnitRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsOrganizationOrganizationalUnit(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "settings",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsOrganizationOrganizationalUnit_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["auditor_group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["create_group_approve_group"] = attr
	}

	schemaAttrs["create_group_placeholder"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["depth"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["description"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["enable_tech_admin_approve_group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["owner"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["parent"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["recovery_fallback_group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["remove_group_approve_group"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsOrganizationOrganizationalUnitRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "settings",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsOrganizationOrganizationalUnit_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["auditor_group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["create_group_approve_group"] = attr
	}

	schemaAttrs["create_group_placeholder"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["depth"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["description"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["enable_tech_admin_approve_group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["owner"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["parent"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["recovery_fallback_group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["remove_group_approve_group"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsOrganizationOrganizationalUnitLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsOrganizationOrganizationalUnitSettingsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["create_group_approve_group"] = attr
	}

	schemaAttrs["create_group_placeholder"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["enable_tech_admin_approve_group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["recovery_fallback_group"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["remove_group_approve_group"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsOrganizationOrganizationalUnit_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitSettingsRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["settings"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsOrganizationOrganizationalUnit_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitSettingsRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["settings"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"accountsWithAttributes", "attributeRules", "audit", "clients", "groups", "provisioning",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProfileAccessProfile_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["activate_rule_script"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["description"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["directory"] = attr
	}

	schemaAttrs["match_rule_script"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["owner"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileAccountRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProfileAccessProfileAccount_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["validity"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["activation"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["manual"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileAccountWithAttributesRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProfileAccessProfileAccount_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["validity"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["activation"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["manual"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["attributes"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsIdentityAccountAttributeValueSummaryRO(false),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileAccountWithAttributesLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsProfileAccessProfileAccountWithAttributesRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileAccount_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileClient(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProfileAccessProfileClient_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProfileAccessProfilePrimer(false),
		}
		attr.Computed = true
		schemaAttrs["access_profile"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientClientApplicationPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["client"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileClientRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProfileAccessProfileClient_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProfileAccessProfilePrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["access_profile"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientClientApplicationPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["client"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileClientLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsProfileAccessProfileClientRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileClientLinkableWrapperWithCount(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsProfileAccessProfileClient(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileClientLinkableWrapperWithCountRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsProfileAccessProfileClientRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileClient_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileClient_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileGroupRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProfileAccessProfileGroup_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProfileAccessProfilePrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["access_profile"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["group"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileGroupLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsProfileAccessProfileGroupRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileGroup_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsProfileAccessProfileRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfilePrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfilePrimerRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileProvisioningRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProfileAccessProfileProvisioning_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProfileAccessProfilePrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["access_profile"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningGroupOnSystemRO(false),
		}
		attr.Computed = true
		schemaAttrs["group_on_system"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileProvisioningLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsProfileAccessProfileProvisioningRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileProvisioningLinkableWrapperWithCountRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsProfileAccessProfileProvisioningRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfileProvisioning_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProfileAccessProfile_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dataSourceSchemaAttrsProfileAccessProfileAccountWithAttributesLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["accounts_with_attributes"] = attr
	}

	{
		attr := dataSourceSchemaAttrsIdentityAccountAttributeRuleLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["attribute_rules"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dataSourceSchemaAttrsProfileAccessProfileClientLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["clients"] = attr
	}

	{
		attr := dataSourceSchemaAttrsProfileAccessProfileGroupLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["groups"] = attr
	}

	{
		attr := dataSourceSchemaAttrsProfileAccessProfileProvisioningLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["provisioning"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningAbstractProvisionedLDAP(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["attributes"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsMiscAttributeCustomization(recurse),
		},
		Computed: true,
	}
	schemaAttrs["base_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["bind_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["bind_password"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["client_certificate"] = attr
	}

	schemaAttrs["failover_host"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["failover_trusted_certificate"] = attr
	}

	schemaAttrs["group_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["host"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["object_classes"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["port"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["service_account_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["ssh_public_key_support"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["tls"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["trusted_certificate"] = attr
	}

	schemaAttrs["user_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningAbstractProvisionedLDAPRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["attributes"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsMiscAttributeCustomizationRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["base_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["bind_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["bind_password"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["client_certificate"] = attr
	}

	schemaAttrs["failover_host"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["failover_trusted_certificate"] = attr
	}

	schemaAttrs["group_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["host"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["object_classes"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["port"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["service_account_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["ssh_public_key_support"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["tls"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["trusted_certificate"] = attr
	}

	schemaAttrs["user_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningCircuitBreakerStatisticsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["number_of_failed_calls"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["number_of_not_permitted_calls"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["number_of_successful_calls"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["state"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningGroupOnSystemRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"accessProfileProvisioning", "audit", "provgroups", "serviceAccounts",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProvisioningGroupOnSystem_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name_in_system"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["short_name_in_system"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["owner"] = attr
	}

	schemaAttrs["provisioning_enabled"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningGroupOnSystemLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsProvisioningGroupOnSystemRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningGroupOnSystemPrimerRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name_in_system"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["short_name_in_system"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningGroupOnSystemTypesRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["types"] = dsschema.ListAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningGroupOnSystem_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dataSourceSchemaAttrsProfileAccessProfileProvisioningLinkableWrapperWithCountRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["access_profile_provisioning"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dataSourceSchemaAttrsGroupProvisioningGroupLinkableWrapperWithCountRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["provgroups"] = attr
	}

	{
		attr := dataSourceSchemaAttrsServiceaccountServiceAccountPrimerLinkableWrapperWithCountRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["service_accounts"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningOwnedGroupOnSystemsWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsProvisioningGroupOnSystemRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["unlinked_count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionNumberSequence(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "systems",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProvisioningProvisionNumberSequence_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["next_id"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionNumberSequenceRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "systems",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProvisioningProvisionNumberSequence_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["next_id"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionNumberSequence_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dataSourceSchemaAttrsProvisioningProvisionedSystemPrimerLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["systems"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionNumberSequence_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dataSourceSchemaAttrsProvisioningProvisionedSystemPrimerLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["systems"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedAD(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["sam_account_name_scheme"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedADRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["sam_account_name_scheme"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedAccountRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProvisioningProvisionedAccount_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["validity"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uid"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedAccount_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedAzureOIDCDirectory(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["accounts_writable"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["directory"] = attr
	}

	schemaAttrs["tenant"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedAzureOIDCDirectoryRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["accounts_writable"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["directory"] = attr
	}

	schemaAttrs["tenant"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedAzureSyncLDAPDirectory(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["client_id"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["client_secret"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["directory"] = attr
	}

	schemaAttrs["tenant"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedAzureSyncLDAPDirectoryRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["client_id"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["client_secret"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["directory"] = attr
	}

	schemaAttrs["tenant"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedAzureTenant(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["client_id"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["client_secret"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["idp_domain"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["tenant"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedAzureTenantRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["client_id"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["client_secret"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["idp_domain"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["tenant"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedInternalLDAP(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientLdapClient(recurse),
		}
		attr.Computed = true
		schemaAttrs["client"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedInternalLDAPRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientLdapClientRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["client"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedLDAP(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["gid"] = dsschema.Int64Attribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionNumberSequence(recurse),
		}
		attr.Computed = true
		schemaAttrs["gid_numbering"] = attr
	}

	schemaAttrs["hashing_scheme"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionNumberSequence(recurse),
		}
		attr.Computed = true
		schemaAttrs["numbering"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedLDAPRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["gid"] = dsschema.Int64Attribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionNumberSequenceRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["gid_numbering"] = attr
	}

	schemaAttrs["hashing_scheme"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionNumberSequenceRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["numbering"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedLDAPDirectory(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["accounts_writable"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["attributes"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsMiscAttributeCustomization(recurse),
		},
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["directory"] = attr
	}

	schemaAttrs["gid"] = dsschema.Int64Attribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionNumberSequence(recurse),
		}
		attr.Computed = true
		schemaAttrs["gid_numbering"] = attr
	}

	schemaAttrs["group_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["hashing_scheme"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionNumberSequence(recurse),
		}
		attr.Computed = true
		schemaAttrs["numbering"] = attr
	}

	schemaAttrs["object_classes"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["sam_account_name_scheme"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["ssh_public_key_support"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedLDAPDirectoryRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["accounts_writable"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["attributes"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsMiscAttributeCustomizationRO(recurse),
		},
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["directory"] = attr
	}

	schemaAttrs["gid"] = dsschema.Int64Attribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionNumberSequenceRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["gid_numbering"] = attr
	}

	schemaAttrs["group_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["hashing_scheme"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionNumberSequenceRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["numbering"] = attr
	}

	schemaAttrs["object_classes"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["sam_account_name_scheme"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["ssh_public_key_support"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedNamespace(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystemPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["base_system"] = attr
	}

	schemaAttrs["group_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["service_account_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedNamespaceRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystemPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["base_system"] = attr
	}

	schemaAttrs["group_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["service_account_dn"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedSCIM(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["attributes"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsMiscAttributeCustomization(recurse),
		},
		Computed: true,
	}
	schemaAttrs["authentication_scheme"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["basic_auth_password"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["basic_auth_username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["bearer_token"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["custom_header_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["custom_header_value"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["url"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["vendor_escaped"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedSCIMRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["attributes"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsMiscAttributeCustomizationRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["authentication_scheme"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["basic_auth_password"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["basic_auth_username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["bearer_token"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["custom_header_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["custom_header_value"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["url"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["vendor_escaped"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedSystem(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"account", "audit", "issuedPermissions", "loginName", "managementPermissions", "markers", "statistics", "supportedGroupTypes",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProvisioningProvisionedSystem_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["admin_permissions"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["can_write_accounts"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["content_admin_permissions"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["organizational_unit"] = attr
	}

	schemaAttrs["owner_permissions"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["account_count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystem_cleanupPeriod(false),
		}
		attr.Computed = true
		schemaAttrs["cleanup_period"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["content_administrator"] = attr
	}

	schemaAttrs["external_uuid"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["group_on_system_provisioning"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["owner"] = attr
	}

	schemaAttrs["self_service_existing_groups"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["self_service_new_groups"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["self_service_new_namespaces"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["self_service_service_accounts"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["should_destroy_unknown_accounts"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["technical_administrator"] = attr
	}

	schemaAttrs["username_prefix"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningAbstractProvisionedLDAP(false),
		}
		attr.Computed = true
		schemaAttrs["abstract_provisioned_ldap"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedAD(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_a_d"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedAzureOIDCDirectory(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_azure_oidc_directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedAzureSyncLDAPDirectory(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_azure_sync_ldap_directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedAzureTenant(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_azure_tenant"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedInternalLDAP(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_internal_ldap"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedLDAP(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_ldap"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedLDAPDirectory(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_ldap_directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedNamespace(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_namespace"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSCIM(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_scim"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedSystemRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"account", "audit", "issuedPermissions", "loginName", "managementPermissions", "markers", "statistics", "supportedGroupTypes",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsProvisioningProvisionedSystem_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["admin_permissions"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["can_write_accounts"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["content_admin_permissions"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["organizational_unit"] = attr
	}

	schemaAttrs["owner_permissions"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["account_count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystem_cleanupPeriodRO(false),
		}
		attr.Computed = true
		schemaAttrs["cleanup_period"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["content_administrator"] = attr
	}

	schemaAttrs["external_uuid"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["group_on_system_provisioning"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["owner"] = attr
	}

	schemaAttrs["self_service_existing_groups"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["self_service_new_groups"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["self_service_new_namespaces"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["self_service_service_accounts"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["should_destroy_unknown_accounts"] = dsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["technical_administrator"] = attr
	}

	schemaAttrs["username_prefix"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningAbstractProvisionedLDAPRO(false),
		}
		attr.Computed = true
		schemaAttrs["abstract_provisioned_ldap"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedADRO(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_a_d"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedAzureOIDCDirectoryRO(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_azure_oidc_directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedAzureSyncLDAPDirectoryRO(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_azure_sync_ldap_directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedAzureTenantRO(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_azure_tenant"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedInternalLDAPRO(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_internal_ldap"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedLDAPRO(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_ldap"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedLDAPDirectoryRO(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_ldap_directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedNamespaceRO(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_namespace"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSCIMRO(false),
		}
		attr.Computed = true
		schemaAttrs["provisioned_scim"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystemRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedSystemPrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["admin_permissions"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["can_write_accounts"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["content_admin_permissions"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["organizational_unit"] = attr
	}

	schemaAttrs["owner_permissions"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedSystemPrimerRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["admin_permissions"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["can_write_accounts"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["content_admin_permissions"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["organizational_unit"] = attr
	}

	schemaAttrs["owner_permissions"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedSystemPrimerLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystemPrimerRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedSystem_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedAccountRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["account"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dataSourceSchemaAttrsClientOAuth2ClientPermissionWithClientLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["issued_permissions"] = attr
	}

	schemaAttrs["login_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisioningManagementPermissionsRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["management_permissions"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsMarkItemMarkersRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["markers"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningCircuitBreakerStatisticsRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["statistics"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningGroupOnSystemTypesRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["supported_group_types"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedSystem_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedAccountRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["account"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dataSourceSchemaAttrsClientOAuth2ClientPermissionWithClientLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["issued_permissions"] = attr
	}

	schemaAttrs["login_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisioningManagementPermissionsRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["management_permissions"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsMarkItemMarkersRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["markers"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningCircuitBreakerStatisticsRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["statistics"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningGroupOnSystemTypesRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["supported_group_types"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedSystem_cleanupPeriod(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["days"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["months"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["years"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisionedSystem_cleanupPeriodRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["days"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["months"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["years"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsProvisioningProvisioningManagementPermissionsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["create_new_groups_allowed"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["create_service_accounts_allowed"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["reuse_existing_groups_allowed"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsServiceaccountServiceAccount(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "groups", "secret", "supportedFeatures",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsServiceaccountServiceAccount_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystemPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["system"] = attr
	}

	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["description"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["password"] = attr
	}

	schemaAttrs["password_rotation"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["ssh_public_key"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["technical_administrator"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsServiceaccountServiceAccountRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "groups", "secret", "supportedFeatures",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsServiceaccountServiceAccount_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystemPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["system"] = attr
	}

	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["description"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["password"] = attr
	}

	schemaAttrs["password_rotation"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["ssh_public_key"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["technical_administrator"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsServiceaccountServiceAccountGroupRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsServiceaccountServiceAccountGroup_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["display_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name_in_system"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["short_name_in_system"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsServiceaccountServiceAccountGroupLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsServiceaccountServiceAccountGroupRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsServiceaccountServiceAccountGroup_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsServiceaccountServiceAccountLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsServiceaccountServiceAccountRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsServiceaccountServiceAccountPrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystemPrimer(recurse),
		}
		attr.Computed = true
		schemaAttrs["system"] = attr
	}

	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsServiceaccountServiceAccountPrimerRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystemPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["system"] = attr
	}

	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsServiceaccountServiceAccountPrimerLinkableWrapperWithCountRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsServiceaccountServiceAccountPrimerRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsServiceaccountServiceAccountSupportedFeaturesRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["ssh_public_key"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsServiceaccountServiceAccount_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dataSourceSchemaAttrsServiceaccountServiceAccountGroupLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["groups"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGeneratedSecret(recurse),
		}
		attr.Computed = true
		schemaAttrs["secret"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsServiceaccountServiceAccountSupportedFeaturesRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["supported_features"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsServiceaccountServiceAccount_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dataSourceSchemaAttrsServiceaccountServiceAccountGroupLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["groups"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGeneratedSecretRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["secret"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsServiceaccountServiceAccountSupportedFeaturesRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["supported_features"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsVaultPasswordMetadataRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["dictionary"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["duplicate"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["hash"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["length"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["lower_count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["number_count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["special_count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["strength"] = dsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["upper_count"] = dsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsVaultVaultRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["access_available"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["records"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsVaultVaultActivationStatusRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["activated"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["activation_required"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsVaultVaultRecord(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"activationStatus", "audit", "parent", "passwordMetadata", "secret", "shareSummary", "shares", "tile", "vaultholder",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsVaultVaultRecord_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["color"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["share_end_time"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["derived"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["end_date"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["filename"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["types"] = dsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["url"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["warning_period"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsVaultVaultRecordRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"activationStatus", "audit", "parent", "passwordMetadata", "secret", "shareSummary", "shares", "tile", "vaultholder",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsVaultVaultRecord_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["color"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["share_end_time"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["derived"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["end_date"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["filename"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["types"] = dsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["url"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["warning_period"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsVaultVaultRecordPrimer(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["color"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["share_end_time"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsVaultVaultRecordPrimerRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["color"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["share_end_time"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsVaultVaultRecordPrimerLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordPrimerRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsVaultVaultRecordSecrets(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["comment"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["file"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["password"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["totp"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsVaultVaultRecordSecretsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["comment"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["file"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["password"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["totp"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsVaultVaultRecordShareRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = dsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsVaultVaultRecordShareSummaryRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["children"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordShareRO(recurse),
		},
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordShareRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["parent"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsVaultVaultRecord_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultActivationStatusRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["activation_status"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["parent"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultPasswordMetadataRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["password_metadata"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordSecrets(recurse),
		}
		attr.Computed = true
		schemaAttrs["secret"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordShareSummaryRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["share_summary"] = attr
	}

	{
		attr := dataSourceSchemaAttrsVaultVaultRecordPrimerLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["shares"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsLaunchpadVaultRecordLaunchpadTile(recurse),
		}
		attr.Computed = true
		schemaAttrs["tile"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsLinkableRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["vaultholder"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsVaultVaultRecord_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultActivationStatusRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["activation_status"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["parent"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultPasswordMetadataRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["password_metadata"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordSecretsRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["secret"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsVaultVaultRecordShareSummaryRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["share_summary"] = attr
	}

	{
		attr := dataSourceSchemaAttrsVaultVaultRecordPrimerLinkableWrapperRO(recurse)["items"].(dsschema.ListNestedAttribute)
		attr.Computed = true
		schemaAttrs["shares"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsLaunchpadVaultRecordLaunchpadTileRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["tile"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsLinkableRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["vaultholder"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsWebhookWebhook(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsWebhookWebhook_additionalObjects(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLink(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuthAccountPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["account"] = attr
	}

	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["all_types"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["authentication_scheme"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["basic_auth_password"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["basic_auth_username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["bearer_token"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientClientApplicationPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["client"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimer(false),
		}
		attr.Computed = true
		schemaAttrs["client_certificate"] = attr
	}

	schemaAttrs["custom_header_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["custom_header_value"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["group"] = attr
	}

	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystemPrimer(false),
		}
		attr.Computed = true
		schemaAttrs["system"] = attr
	}

	schemaAttrs["tls"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimer(false),
		}
		attr.Computed = true
		schemaAttrs["trusted_certificate"] = attr
	}

	schemaAttrs["types"] = dsschema.ListAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["url"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["verbose_payloads"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsWebhookWebhookRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = dsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, dataSourceSchemaAttrsWebhookWebhook_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["permissions"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuthAccountPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["account"] = attr
	}

	schemaAttrs["active"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["all_types"] = dsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["authentication_scheme"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["basic_auth_password"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["basic_auth_username"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["bearer_token"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsClientClientApplicationPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["client"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["client_certificate"] = attr
	}

	schemaAttrs["custom_header_name"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["custom_header_value"] = dsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsDirectoryAccountDirectoryPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["directory"] = attr
	}

	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["group"] = attr
	}

	schemaAttrs["name"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsProvisioningProvisionedSystemPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["system"] = attr
	}

	schemaAttrs["tls"] = dsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsCertificateCertificatePrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["trusted_certificate"] = attr
	}

	schemaAttrs["types"] = dsschema.ListAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["url"] = dsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = dsschema.StringAttribute{
		Required: recurse,
		Computed: !recurse,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["verbose_payloads"] = dsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsWebhookWebhookLinkableWrapperRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	schemaAttrs["items"] = dsschema.ListNestedAttribute{
		NestedObject: dsschema.NestedAttributeObject{
			Attributes: dataSourceSchemaAttrsWebhookWebhookRO(recurse),
		},
		Computed: true,
	}
	return schemaAttrs
}
func dataSourceSchemaAttrsWebhookWebhook_additionalObjects(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func dataSourceSchemaAttrsWebhookWebhook_additionalObjectsRO(recurse bool) map[string]dsschema.Attribute {
	schemaAttrs := make(map[string]dsschema.Attribute)
	{
		attr := dsschema.SingleNestedAttribute{
			Attributes: dataSourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
