// Code generated by "terraform-provider-keyhub-generator"; DO NOT EDIT.
// Copyright (c) Topicus Security B.V.
// SPDX-License-Identifier: APSL-2.0

//lint:ignore U1000 Ignore unused functions in generated code
package provider

import (
	"context"
	"github.com/google/uuid"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/microsoft/kiota-abstractions-go/serialization"
	"github.com/sanity-io/litter"
	keyhubmodel "github.com/topicuskeyhub/sdk-go/models"
)

func tfObjectToTKHDSROAuditInfoRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.AuditInfoable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.AuditInfoable
	tkh = keyhubmodel.NewAuditInfo()
	{
		val, d := tfToTimePointer(planAttrValues["created_at"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetCreatedAt")
		tkh.SetCreatedAt(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["created_by"]))+" using SetCreatedBy")
	tkh.SetCreatedBy(tfToStringPointer(planAttrValues["created_by"]))
	{
		val, d := tfToTimePointer(planAttrValues["last_modified_at"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLastModifiedAt")
		tkh.SetLastModifiedAt(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["last_modified_by"]))+" using SetLastModifiedBy")
	tkh.SetLastModifiedBy(tfToStringPointer(planAttrValues["last_modified_by"]))
	return tkh, diags
}

func tfObjectToTKHDSGeneratedSecret(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GeneratedSecretable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GeneratedSecretable
	tkh = keyhubmodel.NewGeneratedSecret()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["generated_secret"]))+" using SetGeneratedSecret")
	tkh.SetGeneratedSecret(tfToStringPointer(planAttrValues["generated_secret"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["old_secret"]))+" using SetOldSecret")
	tkh.SetOldSecret(tfToStringPointer(planAttrValues["old_secret"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["regenerate"]))+" using SetRegenerate")
	tkh.SetRegenerate(tfToBooleanPointer(planAttrValues["regenerate"]))
	return tkh, diags
}

func tfObjectToTKHDSROGeneratedSecretRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GeneratedSecretable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GeneratedSecretable
	tkh = keyhubmodel.NewGeneratedSecret()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["generated_secret"]))+" using SetGeneratedSecret")
	tkh.SetGeneratedSecret(tfToStringPointer(planAttrValues["generated_secret"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["old_secret"]))+" using SetOldSecret")
	tkh.SetOldSecret(tfToStringPointer(planAttrValues["old_secret"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["regenerate"]))+" using SetRegenerate")
	tkh.SetRegenerate(tfToBooleanPointer(planAttrValues["regenerate"]))
	return tkh, diags
}

func tfObjectToTKHDSLinkable(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.Linkableable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.Linkableable
	tkh = keyhubmodel.NewLinkable()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROLinkableRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.Linkableable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.Linkableable
	tkh = keyhubmodel.NewLinkable()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSNonLinkable(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.NonLinkableable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	var tkh keyhubmodel.NonLinkableable
	tkh = keyhubmodel.NewNonLinkable()
	return tkh, diags
}

func tfObjectToTKHDSRONonLinkableRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.NonLinkableable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	var tkh keyhubmodel.NonLinkableable
	tkh = keyhubmodel.NewNonLinkable()
	return tkh, diags
}

func tfObjectToTKHDSRestLink(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.RestLinkable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.RestLinkable
	tkh = keyhubmodel.NewRestLink()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["href"]))+" using SetHref")
	tkh.SetHref(tfToStringPointer(planAttrValues["href"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["id"]))+" using SetId")
	tkh.SetId(tfToInt64Pointer(planAttrValues["id"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["rel"]))+" using SetRel")
	tkh.SetRel(tfToStringPointer(planAttrValues["rel"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["type_escaped"]))+" using SetTypeEscaped")
	tkh.SetTypeEscaped(tfToStringPointer(planAttrValues["type_escaped"]))
	return tkh, diags
}

func tfObjectToTKHDSRORestLinkRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.RestLinkable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.RestLinkable
	tkh = keyhubmodel.NewRestLink()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["href"]))+" using SetHref")
	tkh.SetHref(tfToStringPointer(planAttrValues["href"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["id"]))+" using SetId")
	tkh.SetId(tfToInt64Pointer(planAttrValues["id"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["rel"]))+" using SetRel")
	tkh.SetRel(tfToStringPointer(planAttrValues["rel"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["type_escaped"]))+" using SetTypeEscaped")
	tkh.SetTypeEscaped(tfToStringPointer(planAttrValues["type_escaped"]))
	return tkh, diags
}

func tfObjectToTKHDSROAuditGroupAuditRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.AuditGroupAuditable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.AuditGroupAuditable
	tkh = keyhubmodel.NewAuditGroupAudit()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["accounts"]), toListValue(configAttrValues["accounts"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuditGroupAuditAccountable {
			tkh, d := tfObjectToTKHDSROAuditGroupAuditAccountRO(ctx, false, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAccounts")
		tkh.SetAccounts(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["comment"]))+" using SetComment")
	tkh.SetComment(tfToStringPointer(planAttrValues["comment"]))
	{
		val, d := tfToTimePointer(planAttrValues["created_at"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetCreatedAt")
		tkh.SetCreatedAt(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["created_by"]))+" using SetCreatedBy")
	tkh.SetCreatedBy(tfToStringPointer(planAttrValues["created_by"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["group_name"]))+" using SetGroupName")
	tkh.SetGroupName(tfToStringPointer(planAttrValues["group_name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name_on_audit"]))+" using SetNameOnAudit")
	tkh.SetNameOnAudit(tfToStringPointer(planAttrValues["name_on_audit"]))
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["nested_groups"]), toListValue(configAttrValues["nested_groups"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuditNestedGroupAuditable {
			tkh, d := tfObjectToTKHDSROAuditNestedGroupAuditRO(ctx, false, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetNestedGroups")
		tkh.SetNestedGroups(val)
	}
	{
		val, d := tfToTimePointer(planAttrValues["reviewed_at"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetReviewedAt")
		tkh.SetReviewedAt(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["reviewed_by"]))+" using SetReviewedBy")
	tkh.SetReviewedBy(tfToStringPointer(planAttrValues["reviewed_by"]))
	{
		val, d := parseCastPointer(planAttrValues["status"].(basetypes.StringValue), keyhubmodel.ParseAuditGroupAuditStatus, func(val any) keyhubmodel.AuditGroupAuditStatus { return *val.(*keyhubmodel.AuditGroupAuditStatus) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetStatus")
		tkh.SetStatus(val)
	}
	{
		val, d := tfToTimePointer(planAttrValues["submitted_at"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSubmittedAt")
		tkh.SetSubmittedAt(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["submitted_by"]))+" using SetSubmittedBy")
	tkh.SetSubmittedBy(tfToStringPointer(planAttrValues["submitted_by"]))
	if recurse {
		{
			val, d := tfObjectToTKHDSROAuditGroupAudit_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROAuditGroupAuditAccountRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.AuditGroupAuditAccountable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.AuditGroupAuditAccountable
	tkh = keyhubmodel.NewAuditGroupAuditAccount()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["account_uuid"]))+" using SetAccountUuid")
	tkh.SetAccountUuid(tfToStringPointer(planAttrValues["account_uuid"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["account_valid"]))+" using SetAccountValid")
	tkh.SetAccountValid(tfToBooleanPointer(planAttrValues["account_valid"]))
	{
		val, d := parseCastPointer(planAttrValues["action"].(basetypes.StringValue), keyhubmodel.ParseAuditAuditAccountAction, func(val any) keyhubmodel.AuditAuditAccountAction { return *val.(*keyhubmodel.AuditAuditAccountAction) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAction")
		tkh.SetAction(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["comment"]))+" using SetComment")
	tkh.SetComment(tfToStringPointer(planAttrValues["comment"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["disconnected_nested"]))+" using SetDisconnectedNested")
	tkh.SetDisconnectedNested(tfToBooleanPointer(planAttrValues["disconnected_nested"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["display_name"]))+" using SetDisplayName")
	tkh.SetDisplayName(tfToStringPointer(planAttrValues["display_name"]))
	{
		val, d := parsePointer2(planAttrValues["end_date"].(basetypes.StringValue), serialization.ParseDateOnly)
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetEndDate")
		tkh.SetEndDate(val)
	}
	{
		val, d := tfToTimePointer(planAttrValues["last_active"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLastActive")
		tkh.SetLastActive(val)
	}
	{
		val, d := parsePointer2(planAttrValues["last_used"].(basetypes.StringValue), serialization.ParseDateOnly)
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLastUsed")
		tkh.SetLastUsed(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["nested"]))+" using SetNested")
	tkh.SetNested(tfToBooleanPointer(planAttrValues["nested"]))
	{
		val, d := parseCastPointer(planAttrValues["rights"].(basetypes.StringValue), keyhubmodel.ParseGroupGroupRights, func(val any) keyhubmodel.GroupGroupRights { return *val.(*keyhubmodel.GroupGroupRights) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetRights")
		tkh.SetRights(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["username"]))+" using SetUsername")
	tkh.SetUsername(tfToStringPointer(planAttrValues["username"]))
	return tkh, diags
}

func tfObjectToTKHDSROAuditGroupAuditLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.AuditGroupAuditLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.AuditGroupAuditLinkableWrapperable
	tkh = keyhubmodel.NewAuditGroupAuditLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuditGroupAuditable {
			tkh, d := tfObjectToTKHDSROAuditGroupAuditRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROAuditGroupAudit_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.AuditGroupAudit_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.AuditGroupAudit_additionalObjectsable
	tkh = keyhubmodel.NewAuditGroupAudit_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROAuditNestedGroupAuditRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.AuditNestedGroupAuditable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.AuditNestedGroupAuditable
	tkh = keyhubmodel.NewAuditNestedGroupAudit()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["action"].(basetypes.StringValue), keyhubmodel.ParseAuditAuditNestedGroupAction, func(val any) keyhubmodel.AuditAuditNestedGroupAction {
			return *val.(*keyhubmodel.AuditAuditNestedGroupAction)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAction")
		tkh.SetAction(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["comment"]))+" using SetComment")
	tkh.SetComment(tfToStringPointer(planAttrValues["comment"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["group_uuid"]))+" using SetGroupUuid")
	tkh.SetGroupUuid(tfToStringPointer(planAttrValues["group_uuid"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	return tkh, diags
}

func tfObjectToTKHDSAuthAccount(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.AuthAccountable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.AuthAccountable
	tkh = keyhubmodel.NewAuthAccount()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["display_name"]))+" using SetDisplayName")
	tkh.SetDisplayName(tfToStringPointer(planAttrValues["display_name"]))
	{
		val, d := tfToTimePointer(planAttrValues["last_active"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLastActive")
		tkh.SetLastActive(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["username"]))+" using SetUsername")
	tkh.SetUsername(tfToStringPointer(planAttrValues["username"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	{
		val, d := parseCastPointer(planAttrValues["validity"].(basetypes.StringValue), keyhubmodel.ParseAuthAccountValidity, func(val any) keyhubmodel.AuthAccountValidity { return *val.(*keyhubmodel.AuthAccountValidity) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetValidity")
		tkh.SetValidity(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["account_permissions"]), toListValue(configAttrValues["account_permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, false, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAccountPermissions")
		tkh.SetAccountPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["active"]))+" using SetActive")
	tkh.SetActive(tfToBooleanPointer(planAttrValues["active"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["can_request_groups"]))+" using SetCanRequestGroups")
	tkh.SetCanRequestGroups(tfToBooleanPointer(planAttrValues["can_request_groups"]))
	{
		val, d := tfObjectToTKHDSRODirectoryAccountDirectoryPrimerRO(ctx, false, toObjectValue(planAttrValues["directory"]), toObjectValue(configAttrValues["directory"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDirectory")
		tkh.SetDirectory(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["directory_name"]))+" using SetDirectoryName")
	tkh.SetDirectoryName(tfToStringPointer(planAttrValues["directory_name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["directory_password_change_required"]))+" using SetDirectoryPasswordChangeRequired")
	tkh.SetDirectoryPasswordChangeRequired(tfToBooleanPointer(planAttrValues["directory_password_change_required"]))
	{
		val, d := parseCastPointer(planAttrValues["directory_rotating_password"].(basetypes.StringValue), keyhubmodel.ParseDirectoryDirectoryRotatingPassword, func(val any) keyhubmodel.DirectoryDirectoryRotatingPassword {
			return *val.(*keyhubmodel.DirectoryDirectoryRotatingPassword)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDirectoryRotatingPassword")
		tkh.SetDirectoryRotatingPassword(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["directory_type"].(basetypes.StringValue), keyhubmodel.ParseDirectoryAccountDirectoryType, func(val any) keyhubmodel.DirectoryAccountDirectoryType {
			return *val.(*keyhubmodel.DirectoryAccountDirectoryType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDirectoryType")
		tkh.SetDirectoryType(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["email"]))+" using SetEmail")
	tkh.SetEmail(tfToStringPointer(planAttrValues["email"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["id_in_directory"]))+" using SetIdInDirectory")
	tkh.SetIdInDirectory(tfToStringPointer(planAttrValues["id_in_directory"]))
	{
		val, d := tfObjectToTKHDSIdentityIdentity(ctx, false, toObjectValue(planAttrValues["identity"]), toObjectValue(configAttrValues["identity"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetIdentity")
		tkh.SetIdentity(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["key_hub_password_change_required"]))+" using SetKeyHubPasswordChangeRequired")
	tkh.SetKeyHubPasswordChangeRequired(tfToBooleanPointer(planAttrValues["key_hub_password_change_required"]))
	{
		val, d := tfToTimePointer(planAttrValues["last_modified_at"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLastModifiedAt")
		tkh.SetLastModifiedAt(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["license_role"].(basetypes.StringValue), keyhubmodel.ParseAuthAccountLicenseRole, func(val any) keyhubmodel.AuthAccountLicenseRole { return *val.(*keyhubmodel.AuthAccountLicenseRole) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLicenseRole")
		tkh.SetLicenseRole(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["locale"]))+" using SetLocale")
	tkh.SetLocale(tfToStringPointer(planAttrValues["locale"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["reregistration_required"]))+" using SetReregistrationRequired")
	tkh.SetReregistrationRequired(tfToBooleanPointer(planAttrValues["reregistration_required"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["token_password_enabled"]))+" using SetTokenPasswordEnabled")
	tkh.SetTokenPasswordEnabled(tfToBooleanPointer(planAttrValues["token_password_enabled"]))
	{
		val, d := parseCastPointer(planAttrValues["two_factor_status"].(basetypes.StringValue), keyhubmodel.ParseAuthTwoFactorAuthenticationStatus, func(val any) keyhubmodel.AuthTwoFactorAuthenticationStatus {
			return *val.(*keyhubmodel.AuthTwoFactorAuthenticationStatus)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTwoFactorStatus")
		tkh.SetTwoFactorStatus(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["valid_in_directory"]))+" using SetValidInDirectory")
	tkh.SetValidInDirectory(tfToBooleanPointer(planAttrValues["valid_in_directory"]))
	if recurse {
		{
			val, d := tfObjectToTKHDSAuthAccount_additionalObjects(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSAuthAccountPrimer(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.AuthAccountPrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.AuthAccountPrimerable
	tkh = keyhubmodel.NewAuthAccountPrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["display_name"]))+" using SetDisplayName")
	tkh.SetDisplayName(tfToStringPointer(planAttrValues["display_name"]))
	{
		val, d := tfToTimePointer(planAttrValues["last_active"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLastActive")
		tkh.SetLastActive(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["username"]))+" using SetUsername")
	tkh.SetUsername(tfToStringPointer(planAttrValues["username"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	{
		val, d := parseCastPointer(planAttrValues["validity"].(basetypes.StringValue), keyhubmodel.ParseAuthAccountValidity, func(val any) keyhubmodel.AuthAccountValidity { return *val.(*keyhubmodel.AuthAccountValidity) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetValidity")
		tkh.SetValidity(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROAuthAccountPrimerRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.AuthAccountPrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.AuthAccountPrimerable
	tkh = keyhubmodel.NewAuthAccountPrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["display_name"]))+" using SetDisplayName")
	tkh.SetDisplayName(tfToStringPointer(planAttrValues["display_name"]))
	{
		val, d := tfToTimePointer(planAttrValues["last_active"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLastActive")
		tkh.SetLastActive(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["username"]))+" using SetUsername")
	tkh.SetUsername(tfToStringPointer(planAttrValues["username"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	{
		val, d := parseCastPointer(planAttrValues["validity"].(basetypes.StringValue), keyhubmodel.ParseAuthAccountValidity, func(val any) keyhubmodel.AuthAccountValidity { return *val.(*keyhubmodel.AuthAccountValidity) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetValidity")
		tkh.SetValidity(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROAuthAccountRecoveryStatusRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.AuthAccountRecoveryStatusable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.AuthAccountRecoveryStatusable
	tkh = keyhubmodel.NewAuthAccountRecoveryStatus()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["pending2fa_recovery_request"]))+" using SetPending2FARecoveryRequest")
	tkh.SetPending2FARecoveryRequest(tfToBooleanPointer(planAttrValues["pending2fa_recovery_request"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["pending_password_recovery_request"]))+" using SetPendingPasswordRecoveryRequest")
	tkh.SetPendingPasswordRecoveryRequest(tfToBooleanPointer(planAttrValues["pending_password_recovery_request"]))
	return tkh, diags
}

func tfObjectToTKHDSROAuthAccountSettingsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.AuthAccountSettingsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.AuthAccountSettingsable
	tkh = keyhubmodel.NewAuthAccountSettings()
	{
		val, d := tfObjectToTKHDSROOrganizationOrganizationalUnitPrimerRO(ctx, recurse, toObjectValue(planAttrValues["default_organizational_unit"]), toObjectValue(configAttrValues["default_organizational_unit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDefaultOrganizationalUnit")
		tkh.SetDefaultOrganizationalUnit(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["directory_name"]))+" using SetDirectoryName")
	tkh.SetDirectoryName(tfToStringPointer(planAttrValues["directory_name"]))
	{
		val, d := parseCastPointer(planAttrValues["directory_type"].(basetypes.StringValue), keyhubmodel.ParseDirectoryAccountDirectoryType, func(val any) keyhubmodel.DirectoryAccountDirectoryType {
			return *val.(*keyhubmodel.DirectoryAccountDirectoryType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDirectoryType")
		tkh.SetDirectoryType(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["in_groups"]))+" using SetInGroups")
	tkh.SetInGroups(tfToBooleanPointer(planAttrValues["in_groups"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["in_multiple_organizational_units"]))+" using SetInMultipleOrganizationalUnits")
	tkh.SetInMultipleOrganizationalUnits(tfToBooleanPointer(planAttrValues["in_multiple_organizational_units"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["key_hub_admin"]))+" using SetKeyHubAdmin")
	tkh.SetKeyHubAdmin(tfToBooleanPointer(planAttrValues["key_hub_admin"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["multiple_organizational_units_exist"]))+" using SetMultipleOrganizationalUnitsExist")
	tkh.SetMultipleOrganizationalUnitsExist(tfToBooleanPointer(planAttrValues["multiple_organizational_units_exist"]))
	{
		val, d := parseCastPointer(planAttrValues["password_mode"].(basetypes.StringValue), keyhubmodel.ParseAuthPasswordMode, func(val any) keyhubmodel.AuthPasswordMode { return *val.(*keyhubmodel.AuthPasswordMode) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPasswordMode")
		tkh.SetPasswordMode(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["ssh_public_key"]))+" using SetSshPublicKey")
	tkh.SetSshPublicKey(tfToStringPointer(planAttrValues["ssh_public_key"]))
	{
		val, d := parseCastPointer(planAttrValues["two_factor_authentication"].(basetypes.StringValue), keyhubmodel.ParseAuthTwoFactorAuthenticationStatus, func(val any) keyhubmodel.AuthTwoFactorAuthenticationStatus {
			return *val.(*keyhubmodel.AuthTwoFactorAuthenticationStatus)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTwoFactorAuthentication")
		tkh.SetTwoFactorAuthentication(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["use_token_password"]))+" using SetUseTokenPassword")
	tkh.SetUseTokenPassword(tfToBooleanPointer(planAttrValues["use_token_password"]))
	{
		val, d := parseCastPointer(planAttrValues["vault_status"].(basetypes.StringValue), keyhubmodel.ParseVaultAccountVaultStatus, func(val any) keyhubmodel.VaultAccountVaultStatus { return *val.(*keyhubmodel.VaultAccountVaultStatus) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetVaultStatus")
		tkh.SetVaultStatus(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSAuthAccount_additionalObjects(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.AuthAccount_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.AuthAccount_additionalObjectsable
	tkh = keyhubmodel.NewAuthAccount_additionalObjects()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["active_login"]))+" using SetActiveLogin")
	tkh.SetActiveLogin(tfToBooleanPointer(planAttrValues["active_login"]))
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupAccountGroupLinkableWrapperWithCountRO(ctx, recurse, toItemsList(ctx, planAttrValues["groups"]), toItemsList(ctx, configAttrValues["groups"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroups")
		tkh.SetGroups(val)
	}
	{
		val, d := tfObjectToTKHDSROAuthAccountRecoveryStatusRO(ctx, recurse, toObjectValue(planAttrValues["pending_recovery_requests"]), toObjectValue(configAttrValues["pending_recovery_requests"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPendingRecoveryRequests")
		tkh.SetPendingRecoveryRequests(val)
	}
	{
		val, d := tfObjectToTKHDSROAuthAccountSettingsRO(ctx, recurse, toObjectValue(planAttrValues["settings"]), toObjectValue(configAttrValues["settings"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSettings")
		tkh.SetSettings(val)
	}
	{
		val, d := tfObjectToTKHDSROAuthStoredAccountAttributesRO(ctx, recurse, toObjectValue(planAttrValues["stored_attributes"]), toObjectValue(configAttrValues["stored_attributes"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetStoredAttributes")
		tkh.SetStoredAttributes(val)
	}
	{
		val, d := tfObjectToTKHDSROVaultVaultRO(ctx, recurse, toObjectValue(planAttrValues["vault"]), toObjectValue(configAttrValues["vault"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetVault")
		tkh.SetVault(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSAuthPermission(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.AuthPermissionable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.AuthPermissionable
	tkh = keyhubmodel.NewAuthPermission()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["full"]))+" using SetFull")
	tkh.SetFull(tfToStringPointer(planAttrValues["full"]))
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["instances"]), toListValue(configAttrValues["instances"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) string {
			return planValue.(basetypes.StringValue).ValueString()
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetInstances")
		tkh.SetInstances(val)
	}
	{
		val, d := tfToSliceSet(toSetValue(planAttrValues["operations"]), toSetValue(configAttrValues["operations"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermittedOperation {
			tkh, d := parseCast(planValue.(basetypes.StringValue), keyhubmodel.ParseAuthPermittedOperation, func(val any) keyhubmodel.AuthPermittedOperation { return *val.(*keyhubmodel.AuthPermittedOperation) })
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOperations")
		tkh.SetOperations(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["type_escaped"]))+" using SetTypeEscaped")
	tkh.SetTypeEscaped(tfToStringPointer(planAttrValues["type_escaped"]))
	return tkh, diags
}

func tfObjectToTKHDSROAuthPermissionRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.AuthPermissionable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.AuthPermissionable
	tkh = keyhubmodel.NewAuthPermission()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["full"]))+" using SetFull")
	tkh.SetFull(tfToStringPointer(planAttrValues["full"]))
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["instances"]), toListValue(configAttrValues["instances"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) string {
			return planValue.(basetypes.StringValue).ValueString()
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetInstances")
		tkh.SetInstances(val)
	}
	{
		val, d := tfToSliceSet(toSetValue(planAttrValues["operations"]), toSetValue(configAttrValues["operations"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermittedOperation {
			tkh, d := parseCast(planValue.(basetypes.StringValue), keyhubmodel.ParseAuthPermittedOperation, func(val any) keyhubmodel.AuthPermittedOperation { return *val.(*keyhubmodel.AuthPermittedOperation) })
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOperations")
		tkh.SetOperations(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["type_escaped"]))+" using SetTypeEscaped")
	tkh.SetTypeEscaped(tfToStringPointer(planAttrValues["type_escaped"]))
	return tkh, diags
}

func tfObjectToTKHDSROAuthStoredAccountAttributeRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.AuthStoredAccountAttributeable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.AuthStoredAccountAttributeable
	tkh = keyhubmodel.NewAuthStoredAccountAttribute()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["value"]))+" using SetValue")
	tkh.SetValue(tfToStringPointer(planAttrValues["value"]))
	return tkh, diags
}

func tfObjectToTKHDSROAuthStoredAccountAttributesRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.AuthStoredAccountAttributesable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.AuthStoredAccountAttributesable
	tkh = keyhubmodel.NewAuthStoredAccountAttributes()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["attributes"]), toListValue(configAttrValues["attributes"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthStoredAccountAttributeable {
			tkh, d := tfObjectToTKHDSROAuthStoredAccountAttributeRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAttributes")
		tkh.SetAttributes(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSCertificateCertificate(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.CertificateCertificateable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.CertificateCertificateable
	tkh = keyhubmodel.NewCertificateCertificate()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["alias"]))+" using SetAlias")
	tkh.SetAlias(tfToStringPointer(planAttrValues["alias"]))
	{
		val, d := parseCastPointer(planAttrValues["type"].(basetypes.StringValue), keyhubmodel.ParseCertificateCertificateType, func(val any) keyhubmodel.CertificateCertificateType {
			return *val.(*keyhubmodel.CertificateCertificateType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetCertificateCertificatePrimerType")
		tkh.SetCertificateCertificatePrimerType(val)
	}
	{
		val, d := tfBase64ToByteArray(planAttrValues["certificate_data"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetCertificateData")
		tkh.SetCertificateData(val)
	}
	{
		val, d := tfToTimePointer(planAttrValues["expiration"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetExpiration")
		tkh.SetExpiration(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["fingerprint_sha1"]))+" using SetFingerprintSha1")
	tkh.SetFingerprintSha1(tfToStringPointer(planAttrValues["fingerprint_sha1"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["fingerprint_sha256"]))+" using SetFingerprintSha256")
	tkh.SetFingerprintSha256(tfToStringPointer(planAttrValues["fingerprint_sha256"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["global"]))+" using SetGlobal")
	tkh.SetGlobal(tfToBooleanPointer(planAttrValues["global"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["subject_dn"]))+" using SetSubjectDN")
	tkh.SetSubjectDN(tfToStringPointer(planAttrValues["subject_dn"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	{
		val, d := tfBase64ToByteArray(planAttrValues["key_data"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetKeyData")
		tkh.SetKeyData(val)
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSCertificateCertificate_additionalObjects(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSCertificateCertificatePrimer(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.CertificateCertificatePrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.CertificateCertificatePrimerable
	tkh = keyhubmodel.NewCertificateCertificatePrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["alias"]))+" using SetAlias")
	tkh.SetAlias(tfToStringPointer(planAttrValues["alias"]))
	{
		val, d := parseCastPointer(planAttrValues["type"].(basetypes.StringValue), keyhubmodel.ParseCertificateCertificateType, func(val any) keyhubmodel.CertificateCertificateType {
			return *val.(*keyhubmodel.CertificateCertificateType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetCertificateCertificatePrimerType")
		tkh.SetCertificateCertificatePrimerType(val)
	}
	{
		val, d := tfBase64ToByteArray(planAttrValues["certificate_data"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetCertificateData")
		tkh.SetCertificateData(val)
	}
	{
		val, d := tfToTimePointer(planAttrValues["expiration"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetExpiration")
		tkh.SetExpiration(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["fingerprint_sha1"]))+" using SetFingerprintSha1")
	tkh.SetFingerprintSha1(tfToStringPointer(planAttrValues["fingerprint_sha1"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["fingerprint_sha256"]))+" using SetFingerprintSha256")
	tkh.SetFingerprintSha256(tfToStringPointer(planAttrValues["fingerprint_sha256"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["global"]))+" using SetGlobal")
	tkh.SetGlobal(tfToBooleanPointer(planAttrValues["global"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["subject_dn"]))+" using SetSubjectDN")
	tkh.SetSubjectDN(tfToStringPointer(planAttrValues["subject_dn"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	return tkh, diags
}

func tfObjectToTKHDSROCertificateCertificatePrimerRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.CertificateCertificatePrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.CertificateCertificatePrimerable
	tkh = keyhubmodel.NewCertificateCertificatePrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["alias"]))+" using SetAlias")
	tkh.SetAlias(tfToStringPointer(planAttrValues["alias"]))
	{
		val, d := parseCastPointer(planAttrValues["type"].(basetypes.StringValue), keyhubmodel.ParseCertificateCertificateType, func(val any) keyhubmodel.CertificateCertificateType {
			return *val.(*keyhubmodel.CertificateCertificateType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetCertificateCertificatePrimerType")
		tkh.SetCertificateCertificatePrimerType(val)
	}
	{
		val, d := tfBase64ToByteArray(planAttrValues["certificate_data"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetCertificateData")
		tkh.SetCertificateData(val)
	}
	{
		val, d := tfToTimePointer(planAttrValues["expiration"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetExpiration")
		tkh.SetExpiration(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["fingerprint_sha1"]))+" using SetFingerprintSha1")
	tkh.SetFingerprintSha1(tfToStringPointer(planAttrValues["fingerprint_sha1"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["fingerprint_sha256"]))+" using SetFingerprintSha256")
	tkh.SetFingerprintSha256(tfToStringPointer(planAttrValues["fingerprint_sha256"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["global"]))+" using SetGlobal")
	tkh.SetGlobal(tfToBooleanPointer(planAttrValues["global"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["subject_dn"]))+" using SetSubjectDN")
	tkh.SetSubjectDN(tfToStringPointer(planAttrValues["subject_dn"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	return tkh, diags
}

func tfObjectToTKHDSCertificateCertificate_additionalObjects(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.CertificateCertificate_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.CertificateCertificate_additionalObjectsable
	tkh = keyhubmodel.NewCertificateCertificate_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSClientClientApplication(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ClientClientApplicationable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ClientClientApplicationable
	tkh = keyhubmodel.NewClientClientApplication()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["type"].(basetypes.StringValue), keyhubmodel.ParseClientClientApplicationType, func(val any) keyhubmodel.ClientClientApplicationType {
			return *val.(*keyhubmodel.ClientClientApplicationType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClientClientApplicationPrimerType")
		tkh.SetClientClientApplicationPrimerType(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["client_id"]))+" using SetClientId")
	tkh.SetClientId(tfToStringPointer(planAttrValues["client_id"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["scopes"]), toListValue(configAttrValues["scopes"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) string {
			return planValue.(basetypes.StringValue).ValueString()
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetScopes")
		tkh.SetScopes(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["sso_application"]))+" using SetSsoApplication")
	tkh.SetSsoApplication(tfToBooleanPointer(planAttrValues["sso_application"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	{
		val, d := tfToTimePointer(planAttrValues["last_modified_at"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLastModifiedAt")
		tkh.SetLastModifiedAt(val)
	}
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["owner"]), toObjectValue(configAttrValues["owner"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwner")
		tkh.SetOwner(val)
	}
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["technical_administrator"]), toObjectValue(configAttrValues["technical_administrator"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTechnicalAdministrator")
		tkh.SetTechnicalAdministrator(val)
	}
	if !planAttrValues["ldap_client"].IsNull() {
		val, d := tfObjectToTKHDSClientLdapClient(ctx, false, planAttrValues["ldap_client"].(basetypes.ObjectValue), configAttrValues["ldap_client"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ClientLdapClient)).ClientClientApplication = *tkh.(*keyhubmodel.ClientClientApplication)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["oauth2_client"].IsNull() {
		val, d := tfObjectToTKHDSClientOAuth2Client(ctx, false, planAttrValues["oauth2_client"].(basetypes.ObjectValue), configAttrValues["oauth2_client"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ClientOAuth2Client)).ClientClientApplication = *tkh.(*keyhubmodel.ClientClientApplication)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["saml2_client"].IsNull() {
		val, d := tfObjectToTKHDSClientSaml2Client(ctx, false, planAttrValues["saml2_client"].(basetypes.ObjectValue), configAttrValues["saml2_client"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ClientSaml2Client)).ClientClientApplication = *tkh.(*keyhubmodel.ClientClientApplication)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSClientClientApplication_additionalObjects(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROClientClientApplicationRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ClientClientApplicationable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ClientClientApplicationable
	tkh = keyhubmodel.NewClientClientApplication()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["type"].(basetypes.StringValue), keyhubmodel.ParseClientClientApplicationType, func(val any) keyhubmodel.ClientClientApplicationType {
			return *val.(*keyhubmodel.ClientClientApplicationType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClientClientApplicationPrimerType")
		tkh.SetClientClientApplicationPrimerType(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["client_id"]))+" using SetClientId")
	tkh.SetClientId(tfToStringPointer(planAttrValues["client_id"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["scopes"]), toListValue(configAttrValues["scopes"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) string {
			return planValue.(basetypes.StringValue).ValueString()
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetScopes")
		tkh.SetScopes(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["sso_application"]))+" using SetSsoApplication")
	tkh.SetSsoApplication(tfToBooleanPointer(planAttrValues["sso_application"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	{
		val, d := tfToTimePointer(planAttrValues["last_modified_at"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLastModifiedAt")
		tkh.SetLastModifiedAt(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["owner"]), toObjectValue(configAttrValues["owner"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwner")
		tkh.SetOwner(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["technical_administrator"]), toObjectValue(configAttrValues["technical_administrator"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTechnicalAdministrator")
		tkh.SetTechnicalAdministrator(val)
	}
	if !planAttrValues["ldap_client"].IsNull() {
		val, d := tfObjectToTKHDSROClientLdapClientRO(ctx, false, planAttrValues["ldap_client"].(basetypes.ObjectValue), configAttrValues["ldap_client"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ClientLdapClient)).ClientClientApplication = *tkh.(*keyhubmodel.ClientClientApplication)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["oauth2_client"].IsNull() {
		val, d := tfObjectToTKHDSROClientOAuth2ClientRO(ctx, false, planAttrValues["oauth2_client"].(basetypes.ObjectValue), configAttrValues["oauth2_client"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ClientOAuth2Client)).ClientClientApplication = *tkh.(*keyhubmodel.ClientClientApplication)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["saml2_client"].IsNull() {
		val, d := tfObjectToTKHDSROClientSaml2ClientRO(ctx, false, planAttrValues["saml2_client"].(basetypes.ObjectValue), configAttrValues["saml2_client"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ClientSaml2Client)).ClientClientApplication = *tkh.(*keyhubmodel.ClientClientApplication)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSROClientClientApplication_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROClientClientApplicationLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ClientClientApplicationLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ClientClientApplicationLinkableWrapperable
	tkh = keyhubmodel.NewClientClientApplicationLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.ClientClientApplicationable {
			tkh, d := tfObjectToTKHDSROClientClientApplicationRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSClientClientApplicationPrimer(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ClientClientApplicationPrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ClientClientApplicationPrimerable
	tkh = keyhubmodel.NewClientClientApplicationPrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["type"].(basetypes.StringValue), keyhubmodel.ParseClientClientApplicationType, func(val any) keyhubmodel.ClientClientApplicationType {
			return *val.(*keyhubmodel.ClientClientApplicationType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClientClientApplicationPrimerType")
		tkh.SetClientClientApplicationPrimerType(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["client_id"]))+" using SetClientId")
	tkh.SetClientId(tfToStringPointer(planAttrValues["client_id"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["scopes"]), toListValue(configAttrValues["scopes"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) string {
			return planValue.(basetypes.StringValue).ValueString()
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetScopes")
		tkh.SetScopes(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["sso_application"]))+" using SetSsoApplication")
	tkh.SetSsoApplication(tfToBooleanPointer(planAttrValues["sso_application"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	return tkh, diags
}

func tfObjectToTKHDSROClientClientApplicationPrimerRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ClientClientApplicationPrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ClientClientApplicationPrimerable
	tkh = keyhubmodel.NewClientClientApplicationPrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["type"].(basetypes.StringValue), keyhubmodel.ParseClientClientApplicationType, func(val any) keyhubmodel.ClientClientApplicationType {
			return *val.(*keyhubmodel.ClientClientApplicationType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClientClientApplicationPrimerType")
		tkh.SetClientClientApplicationPrimerType(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["client_id"]))+" using SetClientId")
	tkh.SetClientId(tfToStringPointer(planAttrValues["client_id"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["scopes"]), toListValue(configAttrValues["scopes"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) string {
			return planValue.(basetypes.StringValue).ValueString()
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetScopes")
		tkh.SetScopes(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["sso_application"]))+" using SetSsoApplication")
	tkh.SetSsoApplication(tfToBooleanPointer(planAttrValues["sso_application"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	return tkh, diags
}

func tfObjectToTKHDSClientClientApplication_additionalObjects(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ClientClientApplication_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ClientClientApplication_additionalObjectsable
	tkh = keyhubmodel.NewClientClientApplication_additionalObjects()
	{
		val, d := tfObjectToTKHDSProfileAccessProfileClientLinkableWrapperWithCount(ctx, recurse, toItemsList(ctx, planAttrValues["accessprofileclients"]), toItemsList(ctx, configAttrValues["accessprofileclients"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAccessprofileclients")
		tkh.SetAccessprofileclients(val)
	}
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	{
		val, d := tfObjectToTKHDSGroupGroupClientLinkableWrapperWithCount(ctx, recurse, toItemsList(ctx, planAttrValues["groupclients"]), toItemsList(ctx, configAttrValues["groupclients"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroupclients")
		tkh.SetGroupclients(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["groups"]), toItemsList(ctx, configAttrValues["groups"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroups")
		tkh.SetGroups(val)
	}
	{
		val, d := tfObjectToTKHDSROOrganizationClientApplicationOrganizationalUnitLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["organizational_units"]), toItemsList(ctx, configAttrValues["organizational_units"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOrganizationalUnits")
		tkh.SetOrganizationalUnits(val)
	}
	{
		val, d := tfObjectToTKHDSGeneratedSecret(ctx, recurse, toObjectValue(planAttrValues["secret"]), toObjectValue(configAttrValues["secret"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSecret")
		tkh.SetSecret(val)
	}
	{
		val, d := tfObjectToTKHDSLaunchpadSsoApplicationLaunchpadTile(ctx, recurse, toObjectValue(planAttrValues["tile"]), toObjectValue(configAttrValues["tile"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTile")
		tkh.SetTile(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["vault_record_count"])))+" using SetVaultRecordCount")
	tkh.SetVaultRecordCount(int64PToInt32P(tfToInt64Pointer(planAttrValues["vault_record_count"])))
	return tkh, diags
}

func tfObjectToTKHDSROClientClientApplication_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ClientClientApplication_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ClientClientApplication_additionalObjectsable
	tkh = keyhubmodel.NewClientClientApplication_additionalObjects()
	{
		val, d := tfObjectToTKHDSROProfileAccessProfileClientLinkableWrapperWithCountRO(ctx, recurse, toItemsList(ctx, planAttrValues["accessprofileclients"]), toItemsList(ctx, configAttrValues["accessprofileclients"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAccessprofileclients")
		tkh.SetAccessprofileclients(val)
	}
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupClientLinkableWrapperWithCountRO(ctx, recurse, toItemsList(ctx, planAttrValues["groupclients"]), toItemsList(ctx, configAttrValues["groupclients"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroupclients")
		tkh.SetGroupclients(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["groups"]), toItemsList(ctx, configAttrValues["groups"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroups")
		tkh.SetGroups(val)
	}
	{
		val, d := tfObjectToTKHDSROOrganizationClientApplicationOrganizationalUnitLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["organizational_units"]), toItemsList(ctx, configAttrValues["organizational_units"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOrganizationalUnits")
		tkh.SetOrganizationalUnits(val)
	}
	{
		val, d := tfObjectToTKHDSROGeneratedSecretRO(ctx, recurse, toObjectValue(planAttrValues["secret"]), toObjectValue(configAttrValues["secret"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSecret")
		tkh.SetSecret(val)
	}
	{
		val, d := tfObjectToTKHDSROLaunchpadSsoApplicationLaunchpadTileRO(ctx, recurse, toObjectValue(planAttrValues["tile"]), toObjectValue(configAttrValues["tile"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTile")
		tkh.SetTile(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["vault_record_count"])))+" using SetVaultRecordCount")
	tkh.SetVaultRecordCount(int64PToInt32P(tfToInt64Pointer(planAttrValues["vault_record_count"])))
	return tkh, diags
}

func tfObjectToTKHDSClientLdapClient(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ClientLdapClientable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ClientLdapClientable
	tkh = keyhubmodel.NewClientLdapClient()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["bind_dn"]))+" using SetBindDn")
	tkh.SetBindDn(tfToStringPointer(planAttrValues["bind_dn"]))
	{
		val, d := tfObjectToTKHDSCertificateCertificatePrimer(ctx, recurse, toObjectValue(planAttrValues["client_certificate"]), toObjectValue(configAttrValues["client_certificate"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClientCertificate")
		tkh.SetClientCertificate(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["share_secret_in_vault"]))+" using SetShareSecretInVault")
	tkh.SetShareSecretInVault(tfToBooleanPointer(planAttrValues["share_secret_in_vault"]))
	{
		val, d := tfObjectToTKHDSROVaultVaultRecordPrimerRO(ctx, recurse, toObjectValue(planAttrValues["shared_secret"]), toObjectValue(configAttrValues["shared_secret"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSharedSecret")
		tkh.SetSharedSecret(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["used_for_provisioning"]))+" using SetUsedForProvisioning")
	tkh.SetUsedForProvisioning(tfToBooleanPointer(planAttrValues["used_for_provisioning"]))
	return tkh, diags
}

func tfObjectToTKHDSROClientLdapClientRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ClientLdapClientable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ClientLdapClientable
	tkh = keyhubmodel.NewClientLdapClient()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["bind_dn"]))+" using SetBindDn")
	tkh.SetBindDn(tfToStringPointer(planAttrValues["bind_dn"]))
	{
		val, d := tfObjectToTKHDSROCertificateCertificatePrimerRO(ctx, recurse, toObjectValue(planAttrValues["client_certificate"]), toObjectValue(configAttrValues["client_certificate"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClientCertificate")
		tkh.SetClientCertificate(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["share_secret_in_vault"]))+" using SetShareSecretInVault")
	tkh.SetShareSecretInVault(tfToBooleanPointer(planAttrValues["share_secret_in_vault"]))
	{
		val, d := tfObjectToTKHDSROVaultVaultRecordPrimerRO(ctx, recurse, toObjectValue(planAttrValues["shared_secret"]), toObjectValue(configAttrValues["shared_secret"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSharedSecret")
		tkh.SetSharedSecret(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["used_for_provisioning"]))+" using SetUsedForProvisioning")
	tkh.SetUsedForProvisioning(tfToBooleanPointer(planAttrValues["used_for_provisioning"]))
	return tkh, diags
}

func tfObjectToTKHDSClientOAuth2Client(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ClientOAuth2Clientable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ClientOAuth2Clientable
	tkh = keyhubmodel.NewClientOAuth2Client()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["account_permissions"]), toListValue(configAttrValues["account_permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAccountPermissions")
		tkh.SetAccountPermissions(val)
	}
	{
		val, d := tfToMap(toMapValue(planAttrValues["attributes"]), toMapValue(configAttrValues["attributes"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) any {
			return planValue.(basetypes.StringValue).ValueString()
		}, keyhubmodel.NewClientOAuth2Client_attributes())
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAttributes")
		tkh.SetAttributes(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["callback_uri"]))+" using SetCallbackURI")
	tkh.SetCallbackURI(tfToStringPointer(planAttrValues["callback_uri"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["debug_mode"]))+" using SetDebugMode")
	tkh.SetDebugMode(tfToBooleanPointer(planAttrValues["debug_mode"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["for_identity_source"]))+" using SetForIdentitySource")
	tkh.SetForIdentitySource(tfToBooleanPointer(planAttrValues["for_identity_source"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["id_token_claims"]))+" using SetIdTokenClaims")
	tkh.SetIdTokenClaims(tfToStringPointer(planAttrValues["id_token_claims"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["initiate_login_uri"]))+" using SetInitiateLoginURI")
	tkh.SetInitiateLoginURI(tfToStringPointer(planAttrValues["initiate_login_uri"]))
	{
		val, d := parseCastPointer(planAttrValues["profile"].(basetypes.StringValue), keyhubmodel.ParseClientOAuth2ClientProfile, func(val any) keyhubmodel.ClientOAuth2ClientProfile {
			return *val.(*keyhubmodel.ClientOAuth2ClientProfile)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetProfile")
		tkh.SetProfile(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["resource_uris"]))+" using SetResourceURIs")
	tkh.SetResourceURIs(tfToStringPointer(planAttrValues["resource_uris"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["share_secret_in_vault"]))+" using SetShareSecretInVault")
	tkh.SetShareSecretInVault(tfToBooleanPointer(planAttrValues["share_secret_in_vault"]))
	{
		val, d := tfObjectToTKHDSROVaultVaultRecordPrimerRO(ctx, recurse, toObjectValue(planAttrValues["shared_secret"]), toObjectValue(configAttrValues["shared_secret"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSharedSecret")
		tkh.SetSharedSecret(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["show_landing_page"]))+" using SetShowLandingPage")
	tkh.SetShowLandingPage(tfToBooleanPointer(planAttrValues["show_landing_page"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["use_client_credentials"]))+" using SetUseClientCredentials")
	tkh.SetUseClientCredentials(tfToBooleanPointer(planAttrValues["use_client_credentials"]))
	return tkh, diags
}

func tfObjectToTKHDSROClientOAuth2ClientRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ClientOAuth2Clientable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ClientOAuth2Clientable
	tkh = keyhubmodel.NewClientOAuth2Client()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["account_permissions"]), toListValue(configAttrValues["account_permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAccountPermissions")
		tkh.SetAccountPermissions(val)
	}
	{
		val, d := tfToMap(toMapValue(planAttrValues["attributes"]), toMapValue(configAttrValues["attributes"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) any {
			return planValue.(basetypes.StringValue).ValueString()
		}, keyhubmodel.NewClientOAuth2Client_attributes())
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAttributes")
		tkh.SetAttributes(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["callback_uri"]))+" using SetCallbackURI")
	tkh.SetCallbackURI(tfToStringPointer(planAttrValues["callback_uri"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["debug_mode"]))+" using SetDebugMode")
	tkh.SetDebugMode(tfToBooleanPointer(planAttrValues["debug_mode"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["for_identity_source"]))+" using SetForIdentitySource")
	tkh.SetForIdentitySource(tfToBooleanPointer(planAttrValues["for_identity_source"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["id_token_claims"]))+" using SetIdTokenClaims")
	tkh.SetIdTokenClaims(tfToStringPointer(planAttrValues["id_token_claims"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["initiate_login_uri"]))+" using SetInitiateLoginURI")
	tkh.SetInitiateLoginURI(tfToStringPointer(planAttrValues["initiate_login_uri"]))
	{
		val, d := parseCastPointer(planAttrValues["profile"].(basetypes.StringValue), keyhubmodel.ParseClientOAuth2ClientProfile, func(val any) keyhubmodel.ClientOAuth2ClientProfile {
			return *val.(*keyhubmodel.ClientOAuth2ClientProfile)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetProfile")
		tkh.SetProfile(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["resource_uris"]))+" using SetResourceURIs")
	tkh.SetResourceURIs(tfToStringPointer(planAttrValues["resource_uris"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["share_secret_in_vault"]))+" using SetShareSecretInVault")
	tkh.SetShareSecretInVault(tfToBooleanPointer(planAttrValues["share_secret_in_vault"]))
	{
		val, d := tfObjectToTKHDSROVaultVaultRecordPrimerRO(ctx, recurse, toObjectValue(planAttrValues["shared_secret"]), toObjectValue(configAttrValues["shared_secret"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSharedSecret")
		tkh.SetSharedSecret(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["show_landing_page"]))+" using SetShowLandingPage")
	tkh.SetShowLandingPage(tfToBooleanPointer(planAttrValues["show_landing_page"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["use_client_credentials"]))+" using SetUseClientCredentials")
	tkh.SetUseClientCredentials(tfToBooleanPointer(planAttrValues["use_client_credentials"]))
	return tkh, diags
}

func tfObjectToTKHDSClientOAuth2ClientPermission(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ClientOAuth2ClientPermissionable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ClientOAuth2ClientPermissionable
	tkh = keyhubmodel.NewClientOAuth2ClientPermission()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["for_group"]), toObjectValue(configAttrValues["for_group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetForGroup")
		tkh.SetForGroup(val)
	}
	{
		val, d := tfObjectToTKHDSProvisioningProvisionedSystemPrimer(ctx, false, toObjectValue(planAttrValues["for_system"]), toObjectValue(configAttrValues["for_system"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetForSystem")
		tkh.SetForSystem(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["value"].(basetypes.StringValue), keyhubmodel.ParseClientOAuth2ClientPermissionType, func(val any) keyhubmodel.ClientOAuth2ClientPermissionType {
			return *val.(*keyhubmodel.ClientOAuth2ClientPermissionType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetValue")
		tkh.SetValue(val)
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSClientOAuth2ClientPermission_additionalObjects(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROClientOAuth2ClientPermissionRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ClientOAuth2ClientPermissionable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ClientOAuth2ClientPermissionable
	tkh = keyhubmodel.NewClientOAuth2ClientPermission()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["for_group"]), toObjectValue(configAttrValues["for_group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetForGroup")
		tkh.SetForGroup(val)
	}
	{
		val, d := tfObjectToTKHDSROProvisioningProvisionedSystemPrimerRO(ctx, false, toObjectValue(planAttrValues["for_system"]), toObjectValue(configAttrValues["for_system"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetForSystem")
		tkh.SetForSystem(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["value"].(basetypes.StringValue), keyhubmodel.ParseClientOAuth2ClientPermissionType, func(val any) keyhubmodel.ClientOAuth2ClientPermissionType {
			return *val.(*keyhubmodel.ClientOAuth2ClientPermissionType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetValue")
		tkh.SetValue(val)
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSROClientOAuth2ClientPermission_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSClientOAuth2ClientPermissionWithClient(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ClientOAuth2ClientPermissionWithClientable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ClientOAuth2ClientPermissionWithClientable
	tkh = keyhubmodel.NewClientOAuth2ClientPermissionWithClient()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["for_group"]), toObjectValue(configAttrValues["for_group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetForGroup")
		tkh.SetForGroup(val)
	}
	{
		val, d := tfObjectToTKHDSProvisioningProvisionedSystemPrimer(ctx, false, toObjectValue(planAttrValues["for_system"]), toObjectValue(configAttrValues["for_system"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetForSystem")
		tkh.SetForSystem(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["value"].(basetypes.StringValue), keyhubmodel.ParseClientOAuth2ClientPermissionType, func(val any) keyhubmodel.ClientOAuth2ClientPermissionType {
			return *val.(*keyhubmodel.ClientOAuth2ClientPermissionType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetValue")
		tkh.SetValue(val)
	}
	{
		val, d := tfObjectToTKHDSClientOAuth2Client(ctx, false, toObjectValue(planAttrValues["client"]), toObjectValue(configAttrValues["client"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClient")
		tkh.SetClient(val)
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSClientOAuth2ClientPermission_additionalObjects(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROClientOAuth2ClientPermissionWithClientRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ClientOAuth2ClientPermissionWithClientable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ClientOAuth2ClientPermissionWithClientable
	tkh = keyhubmodel.NewClientOAuth2ClientPermissionWithClient()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["for_group"]), toObjectValue(configAttrValues["for_group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetForGroup")
		tkh.SetForGroup(val)
	}
	{
		val, d := tfObjectToTKHDSROProvisioningProvisionedSystemPrimerRO(ctx, false, toObjectValue(planAttrValues["for_system"]), toObjectValue(configAttrValues["for_system"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetForSystem")
		tkh.SetForSystem(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["value"].(basetypes.StringValue), keyhubmodel.ParseClientOAuth2ClientPermissionType, func(val any) keyhubmodel.ClientOAuth2ClientPermissionType {
			return *val.(*keyhubmodel.ClientOAuth2ClientPermissionType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetValue")
		tkh.SetValue(val)
	}
	{
		val, d := tfObjectToTKHDSROClientOAuth2ClientRO(ctx, false, toObjectValue(planAttrValues["client"]), toObjectValue(configAttrValues["client"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClient")
		tkh.SetClient(val)
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSROClientOAuth2ClientPermission_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSClientOAuth2ClientPermissionWithClientLinkableWrapper(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ClientOAuth2ClientPermissionWithClientLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ClientOAuth2ClientPermissionWithClientLinkableWrapperable
	tkh = keyhubmodel.NewClientOAuth2ClientPermissionWithClientLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.ClientOAuth2ClientPermissionWithClientable {
			tkh, d := tfObjectToTKHDSClientOAuth2ClientPermissionWithClient(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROClientOAuth2ClientPermissionWithClientLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ClientOAuth2ClientPermissionWithClientLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ClientOAuth2ClientPermissionWithClientLinkableWrapperable
	tkh = keyhubmodel.NewClientOAuth2ClientPermissionWithClientLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.ClientOAuth2ClientPermissionWithClientable {
			tkh, d := tfObjectToTKHDSROClientOAuth2ClientPermissionWithClientRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSClientOAuth2ClientPermission_additionalObjects(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ClientOAuth2ClientPermission_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ClientOAuth2ClientPermission_additionalObjectsable
	tkh = keyhubmodel.NewClientOAuth2ClientPermission_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROClientOAuth2ClientPermission_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ClientOAuth2ClientPermission_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ClientOAuth2ClientPermission_additionalObjectsable
	tkh = keyhubmodel.NewClientOAuth2ClientPermission_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSClientSaml2Client(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ClientSaml2Clientable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ClientSaml2Clientable
	tkh = keyhubmodel.NewClientSaml2Client()
	{
		val, d := tfToMap(toMapValue(planAttrValues["attributes"]), toMapValue(configAttrValues["attributes"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) any {
			return planValue.(basetypes.StringValue).ValueString()
		}, keyhubmodel.NewClientSaml2Client_attributes())
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAttributes")
		tkh.SetAttributes(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["metadata"]))+" using SetMetadata")
	tkh.SetMetadata(tfToStringPointer(planAttrValues["metadata"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["metadata_url"]))+" using SetMetadataUrl")
	tkh.SetMetadataUrl(tfToStringPointer(planAttrValues["metadata_url"]))
	{
		val, d := parseCastPointer(planAttrValues["subject_format"].(basetypes.StringValue), keyhubmodel.ParseClientSubjectFormat, func(val any) keyhubmodel.ClientSubjectFormat { return *val.(*keyhubmodel.ClientSubjectFormat) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSubjectFormat")
		tkh.SetSubjectFormat(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROClientSaml2ClientRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ClientSaml2Clientable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ClientSaml2Clientable
	tkh = keyhubmodel.NewClientSaml2Client()
	{
		val, d := tfToMap(toMapValue(planAttrValues["attributes"]), toMapValue(configAttrValues["attributes"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) any {
			return planValue.(basetypes.StringValue).ValueString()
		}, keyhubmodel.NewClientSaml2Client_attributes())
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAttributes")
		tkh.SetAttributes(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["metadata"]))+" using SetMetadata")
	tkh.SetMetadata(tfToStringPointer(planAttrValues["metadata"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["metadata_url"]))+" using SetMetadataUrl")
	tkh.SetMetadataUrl(tfToStringPointer(planAttrValues["metadata_url"]))
	{
		val, d := parseCastPointer(planAttrValues["subject_format"].(basetypes.StringValue), keyhubmodel.ParseClientSubjectFormat, func(val any) keyhubmodel.ClientSubjectFormat { return *val.(*keyhubmodel.ClientSubjectFormat) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSubjectFormat")
		tkh.SetSubjectFormat(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSDirectoryAccountDirectory(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.DirectoryAccountDirectoryable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.DirectoryAccountDirectoryable
	tkh = keyhubmodel.NewDirectoryAccountDirectory()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["account_validity_supported"]))+" using SetAccountValiditySupported")
	tkh.SetAccountValiditySupported(tfToBooleanPointer(planAttrValues["account_validity_supported"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["active"]))+" using SetActive")
	tkh.SetActive(tfToBooleanPointer(planAttrValues["active"]))
	{
		val, d := parseCastPointer(planAttrValues["type"].(basetypes.StringValue), keyhubmodel.ParseDirectoryAccountDirectoryType, func(val any) keyhubmodel.DirectoryAccountDirectoryType {
			return *val.(*keyhubmodel.DirectoryAccountDirectoryType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDirectoryAccountDirectoryPrimerType")
		tkh.SetDirectoryAccountDirectoryPrimerType(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	{
		val, d := tfObjectToTKHDSOrganizationOrganizationalUnitPrimer(ctx, false, toObjectValue(planAttrValues["base_organizational_unit"]), toObjectValue(configAttrValues["base_organizational_unit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetBaseOrganizationalUnit")
		tkh.SetBaseOrganizationalUnit(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["default_directory"]))+" using SetDefaultDirectory")
	tkh.SetDefaultDirectory(tfToBooleanPointer(planAttrValues["default_directory"]))
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["helpdesk_group"]), toObjectValue(configAttrValues["helpdesk_group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetHelpdeskGroup")
		tkh.SetHelpdeskGroup(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["restrict2fa"]))+" using SetRestrict2fa")
	tkh.SetRestrict2fa(tfToBooleanPointer(planAttrValues["restrict2fa"]))
	{
		val, d := parseCastPointer(planAttrValues["rotating_password"].(basetypes.StringValue), keyhubmodel.ParseDirectoryDirectoryRotatingPassword, func(val any) keyhubmodel.DirectoryDirectoryRotatingPassword {
			return *val.(*keyhubmodel.DirectoryDirectoryRotatingPassword)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetRotatingPassword")
		tkh.SetRotatingPassword(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["username_customizable"]))+" using SetUsernameCustomizable")
	tkh.SetUsernameCustomizable(tfToBooleanPointer(planAttrValues["username_customizable"]))
	if !planAttrValues["internal_directory"].IsNull() {
		val, d := tfObjectToTKHDSDirectoryInternalDirectory(ctx, false, planAttrValues["internal_directory"].(basetypes.ObjectValue), configAttrValues["internal_directory"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.DirectoryInternalDirectory)).DirectoryAccountDirectory = *tkh.(*keyhubmodel.DirectoryAccountDirectory)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["ldap_directory"].IsNull() {
		val, d := tfObjectToTKHDSDirectoryLDAPDirectory(ctx, false, planAttrValues["ldap_directory"].(basetypes.ObjectValue), configAttrValues["ldap_directory"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.DirectoryLDAPDirectory)).DirectoryAccountDirectory = *tkh.(*keyhubmodel.DirectoryAccountDirectory)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["maintenance_directory"].IsNull() {
		val, d := tfObjectToTKHDSDirectoryMaintenanceDirectory(ctx, false, planAttrValues["maintenance_directory"].(basetypes.ObjectValue), configAttrValues["maintenance_directory"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.DirectoryMaintenanceDirectory)).DirectoryAccountDirectory = *tkh.(*keyhubmodel.DirectoryAccountDirectory)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["oidc_directory"].IsNull() {
		val, d := tfObjectToTKHDSDirectoryOIDCDirectory(ctx, false, planAttrValues["oidc_directory"].(basetypes.ObjectValue), configAttrValues["oidc_directory"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.DirectoryOIDCDirectory)).DirectoryAccountDirectory = *tkh.(*keyhubmodel.DirectoryAccountDirectory)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["pending_accounts_directory"].IsNull() {
		val, d := tfObjectToTKHDSDirectoryPendingAccountsDirectory(ctx, false, planAttrValues["pending_accounts_directory"].(basetypes.ObjectValue), configAttrValues["pending_accounts_directory"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.DirectoryPendingAccountsDirectory)).DirectoryAccountDirectory = *tkh.(*keyhubmodel.DirectoryAccountDirectory)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSDirectoryAccountDirectory_additionalObjects(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSRODirectoryAccountDirectoryRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.DirectoryAccountDirectoryable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.DirectoryAccountDirectoryable
	tkh = keyhubmodel.NewDirectoryAccountDirectory()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["account_validity_supported"]))+" using SetAccountValiditySupported")
	tkh.SetAccountValiditySupported(tfToBooleanPointer(planAttrValues["account_validity_supported"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["active"]))+" using SetActive")
	tkh.SetActive(tfToBooleanPointer(planAttrValues["active"]))
	{
		val, d := parseCastPointer(planAttrValues["type"].(basetypes.StringValue), keyhubmodel.ParseDirectoryAccountDirectoryType, func(val any) keyhubmodel.DirectoryAccountDirectoryType {
			return *val.(*keyhubmodel.DirectoryAccountDirectoryType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDirectoryAccountDirectoryPrimerType")
		tkh.SetDirectoryAccountDirectoryPrimerType(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	{
		val, d := tfObjectToTKHDSROOrganizationOrganizationalUnitPrimerRO(ctx, false, toObjectValue(planAttrValues["base_organizational_unit"]), toObjectValue(configAttrValues["base_organizational_unit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetBaseOrganizationalUnit")
		tkh.SetBaseOrganizationalUnit(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["default_directory"]))+" using SetDefaultDirectory")
	tkh.SetDefaultDirectory(tfToBooleanPointer(planAttrValues["default_directory"]))
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["helpdesk_group"]), toObjectValue(configAttrValues["helpdesk_group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetHelpdeskGroup")
		tkh.SetHelpdeskGroup(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["restrict2fa"]))+" using SetRestrict2fa")
	tkh.SetRestrict2fa(tfToBooleanPointer(planAttrValues["restrict2fa"]))
	{
		val, d := parseCastPointer(planAttrValues["rotating_password"].(basetypes.StringValue), keyhubmodel.ParseDirectoryDirectoryRotatingPassword, func(val any) keyhubmodel.DirectoryDirectoryRotatingPassword {
			return *val.(*keyhubmodel.DirectoryDirectoryRotatingPassword)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetRotatingPassword")
		tkh.SetRotatingPassword(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["username_customizable"]))+" using SetUsernameCustomizable")
	tkh.SetUsernameCustomizable(tfToBooleanPointer(planAttrValues["username_customizable"]))
	if !planAttrValues["internal_directory"].IsNull() {
		val, d := tfObjectToTKHDSRODirectoryInternalDirectoryRO(ctx, false, planAttrValues["internal_directory"].(basetypes.ObjectValue), configAttrValues["internal_directory"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.DirectoryInternalDirectory)).DirectoryAccountDirectory = *tkh.(*keyhubmodel.DirectoryAccountDirectory)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["ldap_directory"].IsNull() {
		val, d := tfObjectToTKHDSRODirectoryLDAPDirectoryRO(ctx, false, planAttrValues["ldap_directory"].(basetypes.ObjectValue), configAttrValues["ldap_directory"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.DirectoryLDAPDirectory)).DirectoryAccountDirectory = *tkh.(*keyhubmodel.DirectoryAccountDirectory)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["maintenance_directory"].IsNull() {
		val, d := tfObjectToTKHDSRODirectoryMaintenanceDirectoryRO(ctx, false, planAttrValues["maintenance_directory"].(basetypes.ObjectValue), configAttrValues["maintenance_directory"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.DirectoryMaintenanceDirectory)).DirectoryAccountDirectory = *tkh.(*keyhubmodel.DirectoryAccountDirectory)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["oidc_directory"].IsNull() {
		val, d := tfObjectToTKHDSRODirectoryOIDCDirectoryRO(ctx, false, planAttrValues["oidc_directory"].(basetypes.ObjectValue), configAttrValues["oidc_directory"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.DirectoryOIDCDirectory)).DirectoryAccountDirectory = *tkh.(*keyhubmodel.DirectoryAccountDirectory)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["pending_accounts_directory"].IsNull() {
		val, d := tfObjectToTKHDSRODirectoryPendingAccountsDirectoryRO(ctx, false, planAttrValues["pending_accounts_directory"].(basetypes.ObjectValue), configAttrValues["pending_accounts_directory"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.DirectoryPendingAccountsDirectory)).DirectoryAccountDirectory = *tkh.(*keyhubmodel.DirectoryAccountDirectory)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSRODirectoryAccountDirectory_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSRODirectoryAccountDirectoryLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.DirectoryAccountDirectoryLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.DirectoryAccountDirectoryLinkableWrapperable
	tkh = keyhubmodel.NewDirectoryAccountDirectoryLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.DirectoryAccountDirectoryable {
			tkh, d := tfObjectToTKHDSRODirectoryAccountDirectoryRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSDirectoryAccountDirectoryPrimer(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.DirectoryAccountDirectoryPrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.DirectoryAccountDirectoryPrimerable
	tkh = keyhubmodel.NewDirectoryAccountDirectoryPrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["account_validity_supported"]))+" using SetAccountValiditySupported")
	tkh.SetAccountValiditySupported(tfToBooleanPointer(planAttrValues["account_validity_supported"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["active"]))+" using SetActive")
	tkh.SetActive(tfToBooleanPointer(planAttrValues["active"]))
	{
		val, d := parseCastPointer(planAttrValues["type"].(basetypes.StringValue), keyhubmodel.ParseDirectoryAccountDirectoryType, func(val any) keyhubmodel.DirectoryAccountDirectoryType {
			return *val.(*keyhubmodel.DirectoryAccountDirectoryType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDirectoryAccountDirectoryPrimerType")
		tkh.SetDirectoryAccountDirectoryPrimerType(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	return tkh, diags
}

func tfObjectToTKHDSRODirectoryAccountDirectoryPrimerRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.DirectoryAccountDirectoryPrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.DirectoryAccountDirectoryPrimerable
	tkh = keyhubmodel.NewDirectoryAccountDirectoryPrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["account_validity_supported"]))+" using SetAccountValiditySupported")
	tkh.SetAccountValiditySupported(tfToBooleanPointer(planAttrValues["account_validity_supported"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["active"]))+" using SetActive")
	tkh.SetActive(tfToBooleanPointer(planAttrValues["active"]))
	{
		val, d := parseCastPointer(planAttrValues["type"].(basetypes.StringValue), keyhubmodel.ParseDirectoryAccountDirectoryType, func(val any) keyhubmodel.DirectoryAccountDirectoryType {
			return *val.(*keyhubmodel.DirectoryAccountDirectoryType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDirectoryAccountDirectoryPrimerType")
		tkh.SetDirectoryAccountDirectoryPrimerType(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	return tkh, diags
}

func tfObjectToTKHDSRODirectoryAccountDirectoryStatusReportRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.DirectoryAccountDirectoryStatusReportable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.DirectoryAccountDirectoryStatusReportable
	tkh = keyhubmodel.NewDirectoryAccountDirectoryStatusReport()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["accounts"]))+" using SetAccounts")
	tkh.SetAccounts(tfToInt64Pointer(planAttrValues["accounts"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["reason"]))+" using SetReason")
	tkh.SetReason(tfToStringPointer(planAttrValues["reason"]))
	{
		val, d := parseCastPointer(planAttrValues["status"].(basetypes.StringValue), keyhubmodel.ParseDirectoryAccountDirectoryStatus, func(val any) keyhubmodel.DirectoryAccountDirectoryStatus {
			return *val.(*keyhubmodel.DirectoryAccountDirectoryStatus)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetStatus")
		tkh.SetStatus(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSRODirectoryAccountDirectorySummaryRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.DirectoryAccountDirectorySummaryable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.DirectoryAccountDirectorySummaryable
	tkh = keyhubmodel.NewDirectoryAccountDirectorySummary()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["type"].(basetypes.StringValue), keyhubmodel.ParseDirectoryAccountDirectoryType, func(val any) keyhubmodel.DirectoryAccountDirectoryType {
			return *val.(*keyhubmodel.DirectoryAccountDirectoryType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDirectoryAccountDirectorySummaryType")
		tkh.SetDirectoryAccountDirectorySummaryType(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["domain_restriction"]))+" using SetDomainRestriction")
	tkh.SetDomainRestriction(tfToStringPointer(planAttrValues["domain_restriction"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["fully_resolved_issuer"]))+" using SetFullyResolvedIssuer")
	tkh.SetFullyResolvedIssuer(tfToStringPointer(planAttrValues["fully_resolved_issuer"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfObjectToTKHDSRODirectoryAccountDirectoryStatusReportRO(ctx, recurse, toObjectValue(planAttrValues["status"]), toObjectValue(configAttrValues["status"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetStatus")
		tkh.SetStatus(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["username_customizable"]))+" using SetUsernameCustomizable")
	tkh.SetUsernameCustomizable(tfToBooleanPointer(planAttrValues["username_customizable"]))
	return tkh, diags
}

func tfObjectToTKHDSRODirectoryAccountDirectorySummaryLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.DirectoryAccountDirectorySummaryLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.DirectoryAccountDirectorySummaryLinkableWrapperable
	tkh = keyhubmodel.NewDirectoryAccountDirectorySummaryLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.DirectoryAccountDirectorySummaryable {
			tkh, d := tfObjectToTKHDSRODirectoryAccountDirectorySummaryRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSDirectoryAccountDirectory_additionalObjects(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.DirectoryAccountDirectory_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.DirectoryAccountDirectory_additionalObjectsable
	tkh = keyhubmodel.NewDirectoryAccountDirectory_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	{
		val, d := tfObjectToTKHDSROMarkItemMarkersRO(ctx, recurse, toObjectValue(planAttrValues["markers"]), toObjectValue(configAttrValues["markers"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetMarkers")
		tkh.SetMarkers(val)
	}
	{
		val, d := tfObjectToTKHDSRODirectoryAccountDirectoryStatusReportRO(ctx, recurse, toObjectValue(planAttrValues["status"]), toObjectValue(configAttrValues["status"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetStatus")
		tkh.SetStatus(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSRODirectoryAccountDirectory_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.DirectoryAccountDirectory_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.DirectoryAccountDirectory_additionalObjectsable
	tkh = keyhubmodel.NewDirectoryAccountDirectory_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	{
		val, d := tfObjectToTKHDSROMarkItemMarkersRO(ctx, recurse, toObjectValue(planAttrValues["markers"]), toObjectValue(configAttrValues["markers"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetMarkers")
		tkh.SetMarkers(val)
	}
	{
		val, d := tfObjectToTKHDSRODirectoryAccountDirectoryStatusReportRO(ctx, recurse, toObjectValue(planAttrValues["status"]), toObjectValue(configAttrValues["status"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetStatus")
		tkh.SetStatus(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSDirectoryInternalDirectory(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.DirectoryInternalDirectoryable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.DirectoryInternalDirectoryable
	tkh = keyhubmodel.NewDirectoryInternalDirectory()
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, recurse, toObjectValue(planAttrValues["owner"]), toObjectValue(configAttrValues["owner"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwner")
		tkh.SetOwner(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSRODirectoryInternalDirectoryRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.DirectoryInternalDirectoryable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.DirectoryInternalDirectoryable
	tkh = keyhubmodel.NewDirectoryInternalDirectory()
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, recurse, toObjectValue(planAttrValues["owner"]), toObjectValue(configAttrValues["owner"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwner")
		tkh.SetOwner(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSDirectoryLDAPDirectory(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.DirectoryLDAPDirectoryable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.DirectoryLDAPDirectoryable
	tkh = keyhubmodel.NewDirectoryLDAPDirectory()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["attributes_to_store"]))+" using SetAttributesToStore")
	tkh.SetAttributesToStore(tfToStringPointer(planAttrValues["attributes_to_store"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["base_dn"]))+" using SetBaseDN")
	tkh.SetBaseDN(tfToStringPointer(planAttrValues["base_dn"]))
	{
		val, d := tfObjectToTKHDSCertificateCertificatePrimer(ctx, recurse, toObjectValue(planAttrValues["client_certificate"]), toObjectValue(configAttrValues["client_certificate"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClientCertificate")
		tkh.SetClientCertificate(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["dialect"].(basetypes.StringValue), keyhubmodel.ParseDirectoryLDAPDialect, func(val any) keyhubmodel.DirectoryLDAPDialect { return *val.(*keyhubmodel.DirectoryLDAPDialect) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDialect")
		tkh.SetDialect(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["failover_host"]))+" using SetFailoverHost")
	tkh.SetFailoverHost(tfToStringPointer(planAttrValues["failover_host"]))
	{
		val, d := tfObjectToTKHDSCertificateCertificatePrimer(ctx, recurse, toObjectValue(planAttrValues["failover_trusted_certificate"]), toObjectValue(configAttrValues["failover_trusted_certificate"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetFailoverTrustedCertificate")
		tkh.SetFailoverTrustedCertificate(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["host"]))+" using SetHost")
	tkh.SetHost(tfToStringPointer(planAttrValues["host"]))
	{
		val, d := parseCastPointer(planAttrValues["password_recovery"].(basetypes.StringValue), keyhubmodel.ParseDirectoryLDAPDirectoryPasswordRecovery, func(val any) keyhubmodel.DirectoryLDAPDirectoryPasswordRecovery {
			return *val.(*keyhubmodel.DirectoryLDAPDirectoryPasswordRecovery)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPasswordRecovery")
		tkh.SetPasswordRecovery(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["port"])))+" using SetPort")
	tkh.SetPort(int64PToInt32P(tfToInt64Pointer(planAttrValues["port"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["search_bind_dn"]))+" using SetSearchBindDN")
	tkh.SetSearchBindDN(tfToStringPointer(planAttrValues["search_bind_dn"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["search_bind_password"]))+" using SetSearchBindPassword")
	tkh.SetSearchBindPassword(tfToStringPointer(planAttrValues["search_bind_password"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["search_filter"]))+" using SetSearchFilter")
	tkh.SetSearchFilter(tfToStringPointer(planAttrValues["search_filter"]))
	{
		val, d := parseCastPointer(planAttrValues["tls"].(basetypes.StringValue), keyhubmodel.ParseTLSLevel, func(val any) keyhubmodel.TLSLevel { return *val.(*keyhubmodel.TLSLevel) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTls")
		tkh.SetTls(val)
	}
	{
		val, d := tfObjectToTKHDSCertificateCertificatePrimer(ctx, recurse, toObjectValue(planAttrValues["trusted_certificate"]), toObjectValue(configAttrValues["trusted_certificate"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTrustedCertificate")
		tkh.SetTrustedCertificate(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSRODirectoryLDAPDirectoryRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.DirectoryLDAPDirectoryable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.DirectoryLDAPDirectoryable
	tkh = keyhubmodel.NewDirectoryLDAPDirectory()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["attributes_to_store"]))+" using SetAttributesToStore")
	tkh.SetAttributesToStore(tfToStringPointer(planAttrValues["attributes_to_store"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["base_dn"]))+" using SetBaseDN")
	tkh.SetBaseDN(tfToStringPointer(planAttrValues["base_dn"]))
	{
		val, d := tfObjectToTKHDSROCertificateCertificatePrimerRO(ctx, recurse, toObjectValue(planAttrValues["client_certificate"]), toObjectValue(configAttrValues["client_certificate"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClientCertificate")
		tkh.SetClientCertificate(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["dialect"].(basetypes.StringValue), keyhubmodel.ParseDirectoryLDAPDialect, func(val any) keyhubmodel.DirectoryLDAPDialect { return *val.(*keyhubmodel.DirectoryLDAPDialect) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDialect")
		tkh.SetDialect(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["failover_host"]))+" using SetFailoverHost")
	tkh.SetFailoverHost(tfToStringPointer(planAttrValues["failover_host"]))
	{
		val, d := tfObjectToTKHDSROCertificateCertificatePrimerRO(ctx, recurse, toObjectValue(planAttrValues["failover_trusted_certificate"]), toObjectValue(configAttrValues["failover_trusted_certificate"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetFailoverTrustedCertificate")
		tkh.SetFailoverTrustedCertificate(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["host"]))+" using SetHost")
	tkh.SetHost(tfToStringPointer(planAttrValues["host"]))
	{
		val, d := parseCastPointer(planAttrValues["password_recovery"].(basetypes.StringValue), keyhubmodel.ParseDirectoryLDAPDirectoryPasswordRecovery, func(val any) keyhubmodel.DirectoryLDAPDirectoryPasswordRecovery {
			return *val.(*keyhubmodel.DirectoryLDAPDirectoryPasswordRecovery)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPasswordRecovery")
		tkh.SetPasswordRecovery(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["port"])))+" using SetPort")
	tkh.SetPort(int64PToInt32P(tfToInt64Pointer(planAttrValues["port"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["search_bind_dn"]))+" using SetSearchBindDN")
	tkh.SetSearchBindDN(tfToStringPointer(planAttrValues["search_bind_dn"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["search_bind_password"]))+" using SetSearchBindPassword")
	tkh.SetSearchBindPassword(tfToStringPointer(planAttrValues["search_bind_password"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["search_filter"]))+" using SetSearchFilter")
	tkh.SetSearchFilter(tfToStringPointer(planAttrValues["search_filter"]))
	{
		val, d := parseCastPointer(planAttrValues["tls"].(basetypes.StringValue), keyhubmodel.ParseTLSLevel, func(val any) keyhubmodel.TLSLevel { return *val.(*keyhubmodel.TLSLevel) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTls")
		tkh.SetTls(val)
	}
	{
		val, d := tfObjectToTKHDSROCertificateCertificatePrimerRO(ctx, recurse, toObjectValue(planAttrValues["trusted_certificate"]), toObjectValue(configAttrValues["trusted_certificate"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTrustedCertificate")
		tkh.SetTrustedCertificate(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSDirectoryMaintenanceDirectory(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.DirectoryMaintenanceDirectoryable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	var tkh keyhubmodel.DirectoryMaintenanceDirectoryable
	tkh = keyhubmodel.NewDirectoryMaintenanceDirectory()
	return tkh, diags
}

func tfObjectToTKHDSRODirectoryMaintenanceDirectoryRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.DirectoryMaintenanceDirectoryable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	var tkh keyhubmodel.DirectoryMaintenanceDirectoryable
	tkh = keyhubmodel.NewDirectoryMaintenanceDirectory()
	return tkh, diags
}

func tfObjectToTKHDSDirectoryOIDCDirectory(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.DirectoryOIDCDirectoryable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.DirectoryOIDCDirectoryable
	tkh = keyhubmodel.NewDirectoryOIDCDirectory()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["acr_values"]))+" using SetAcrValues")
	tkh.SetAcrValues(tfToStringPointer(planAttrValues["acr_values"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["attributes_to_store"]))+" using SetAttributesToStore")
	tkh.SetAttributesToStore(tfToStringPointer(planAttrValues["attributes_to_store"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["client_id"]))+" using SetClientId")
	tkh.SetClientId(tfToStringPointer(planAttrValues["client_id"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["client_secret"]))+" using SetClientSecret")
	tkh.SetClientSecret(tfToStringPointer(planAttrValues["client_secret"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["domain_restriction"]))+" using SetDomainRestriction")
	tkh.SetDomainRestriction(tfToStringPointer(planAttrValues["domain_restriction"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["enforces2fa"]))+" using SetEnforces2fa")
	tkh.SetEnforces2fa(tfToBooleanPointer(planAttrValues["enforces2fa"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["fully_resolved_issuer"]))+" using SetFullyResolvedIssuer")
	tkh.SetFullyResolvedIssuer(tfToStringPointer(planAttrValues["fully_resolved_issuer"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["issuer"]))+" using SetIssuer")
	tkh.SetIssuer(tfToStringPointer(planAttrValues["issuer"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["logout_url"]))+" using SetLogoutUrl")
	tkh.SetLogoutUrl(tfToStringPointer(planAttrValues["logout_url"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["send_login_hint"]))+" using SetSendLoginHint")
	tkh.SetSendLoginHint(tfToBooleanPointer(planAttrValues["send_login_hint"]))
	{
		val, d := parseCastPointer(planAttrValues["vendor_escaped"].(basetypes.StringValue), keyhubmodel.ParseDirectoryOIDCVendor, func(val any) keyhubmodel.DirectoryOIDCVendor { return *val.(*keyhubmodel.DirectoryOIDCVendor) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetVendorEscaped")
		tkh.SetVendorEscaped(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSRODirectoryOIDCDirectoryRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.DirectoryOIDCDirectoryable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.DirectoryOIDCDirectoryable
	tkh = keyhubmodel.NewDirectoryOIDCDirectory()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["acr_values"]))+" using SetAcrValues")
	tkh.SetAcrValues(tfToStringPointer(planAttrValues["acr_values"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["attributes_to_store"]))+" using SetAttributesToStore")
	tkh.SetAttributesToStore(tfToStringPointer(planAttrValues["attributes_to_store"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["client_id"]))+" using SetClientId")
	tkh.SetClientId(tfToStringPointer(planAttrValues["client_id"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["client_secret"]))+" using SetClientSecret")
	tkh.SetClientSecret(tfToStringPointer(planAttrValues["client_secret"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["domain_restriction"]))+" using SetDomainRestriction")
	tkh.SetDomainRestriction(tfToStringPointer(planAttrValues["domain_restriction"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["enforces2fa"]))+" using SetEnforces2fa")
	tkh.SetEnforces2fa(tfToBooleanPointer(planAttrValues["enforces2fa"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["fully_resolved_issuer"]))+" using SetFullyResolvedIssuer")
	tkh.SetFullyResolvedIssuer(tfToStringPointer(planAttrValues["fully_resolved_issuer"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["issuer"]))+" using SetIssuer")
	tkh.SetIssuer(tfToStringPointer(planAttrValues["issuer"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["logout_url"]))+" using SetLogoutUrl")
	tkh.SetLogoutUrl(tfToStringPointer(planAttrValues["logout_url"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["send_login_hint"]))+" using SetSendLoginHint")
	tkh.SetSendLoginHint(tfToBooleanPointer(planAttrValues["send_login_hint"]))
	{
		val, d := parseCastPointer(planAttrValues["vendor_escaped"].(basetypes.StringValue), keyhubmodel.ParseDirectoryOIDCVendor, func(val any) keyhubmodel.DirectoryOIDCVendor { return *val.(*keyhubmodel.DirectoryOIDCVendor) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetVendorEscaped")
		tkh.SetVendorEscaped(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSDirectoryPendingAccountsDirectory(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.DirectoryPendingAccountsDirectoryable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	var tkh keyhubmodel.DirectoryPendingAccountsDirectoryable
	tkh = keyhubmodel.NewDirectoryPendingAccountsDirectory()
	return tkh, diags
}

func tfObjectToTKHDSRODirectoryPendingAccountsDirectoryRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.DirectoryPendingAccountsDirectoryable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	var tkh keyhubmodel.DirectoryPendingAccountsDirectoryable
	tkh = keyhubmodel.NewDirectoryPendingAccountsDirectory()
	return tkh, diags
}

func tfObjectToTKHDSROGroupAccountGroupRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupAccountGroupable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupAccountGroupable
	tkh = keyhubmodel.NewGroupAccountGroup()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["admin"]))+" using SetAdmin")
	tkh.SetAdmin(tfToBooleanPointer(planAttrValues["admin"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfObjectToTKHDSROOrganizationOrganizationalUnitPrimerRO(ctx, recurse, toObjectValue(planAttrValues["organizational_unit"]), toObjectValue(configAttrValues["organizational_unit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOrganizationalUnit")
		tkh.SetOrganizationalUnit(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	{
		val, d := parsePointer2(planAttrValues["end_date"].(basetypes.StringValue), serialization.ParseDateOnly)
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetEndDate")
		tkh.SetEndDate(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupFolderRO(ctx, false, toObjectValue(planAttrValues["folder"]), toObjectValue(configAttrValues["folder"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetFolder")
		tkh.SetFolder(val)
	}
	{
		val, d := parsePointer2(planAttrValues["last_used"].(basetypes.StringValue), serialization.ParseDateOnly)
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLastUsed")
		tkh.SetLastUsed(val)
	}
	{
		val, d := tfToTimePointer(planAttrValues["provisioning_end_time"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetProvisioningEndTime")
		tkh.SetProvisioningEndTime(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["rights"].(basetypes.StringValue), keyhubmodel.ParseGroupGroupRights, func(val any) keyhubmodel.GroupGroupRights { return *val.(*keyhubmodel.GroupGroupRights) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetRights")
		tkh.SetRights(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["visible_for_provisioning"]))+" using SetVisibleForProvisioning")
	tkh.SetVisibleForProvisioning(tfToBooleanPointer(planAttrValues["visible_for_provisioning"]))
	if recurse {
		{
			val, d := tfObjectToTKHDSROGroupAccountGroup_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupAccountGroupLinkableWrapperWithCountRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupAccountGroupLinkableWrapperWithCountable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupAccountGroupLinkableWrapperWithCountable
	tkh = keyhubmodel.NewGroupAccountGroupLinkableWrapperWithCount()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["count"]))+" using SetCount")
	tkh.SetCount(tfToInt64Pointer(planAttrValues["count"]))
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.GroupAccountGroupable {
			tkh, d := tfObjectToTKHDSROGroupAccountGroupRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupAccountGroup_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupAccountGroup_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupAccountGroup_additionalObjectsable
	tkh = keyhubmodel.NewGroupAccountGroup_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	{
		val, d := tfObjectToTKHDSROVaultVaultRO(ctx, recurse, toObjectValue(planAttrValues["vault"]), toObjectValue(configAttrValues["vault"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetVault")
		tkh.SetVault(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSGroupGroup(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupable
	tkh = keyhubmodel.NewGroupGroup()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["admin"]))+" using SetAdmin")
	tkh.SetAdmin(tfToBooleanPointer(planAttrValues["admin"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfObjectToTKHDSOrganizationOrganizationalUnitPrimer(ctx, recurse, toObjectValue(planAttrValues["organizational_unit"]), toObjectValue(configAttrValues["organizational_unit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOrganizationalUnit")
		tkh.SetOrganizationalUnit(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["application_administration"]))+" using SetApplicationAdministration")
	tkh.SetApplicationAdministration(tfToBooleanPointer(planAttrValues["application_administration"]))
	{
		val, d := tfObjectToTKHDSGroupGroupAuditConfig(ctx, false, toObjectValue(planAttrValues["audit_config"]), toObjectValue(configAttrValues["audit_config"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAuditConfig")
		tkh.SetAuditConfig(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["audit_requested"]))+" using SetAuditRequested")
	tkh.SetAuditRequested(tfToBooleanPointer(planAttrValues["audit_requested"]))
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["authorizing_group_auditing"]), toObjectValue(configAttrValues["authorizing_group_auditing"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAuthorizingGroupAuditing")
		tkh.SetAuthorizingGroupAuditing(val)
	}
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["authorizing_group_delegation"]), toObjectValue(configAttrValues["authorizing_group_delegation"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAuthorizingGroupDelegation")
		tkh.SetAuthorizingGroupDelegation(val)
	}
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["authorizing_group_membership"]), toObjectValue(configAttrValues["authorizing_group_membership"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAuthorizingGroupMembership")
		tkh.SetAuthorizingGroupMembership(val)
	}
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["authorizing_group_provisioning"]), toObjectValue(configAttrValues["authorizing_group_provisioning"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAuthorizingGroupProvisioning")
		tkh.SetAuthorizingGroupProvisioning(val)
	}
	{
		val, d := tfToSliceSet(toSetValue(planAttrValues["authorizing_group_types"]), toSetValue(configAttrValues["authorizing_group_types"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RequestAuthorizingGroupType {
			tkh, d := parseCast(planValue.(basetypes.StringValue), keyhubmodel.ParseRequestAuthorizingGroupType, func(val any) keyhubmodel.RequestAuthorizingGroupType {
				return *val.(*keyhubmodel.RequestAuthorizingGroupType)
			})
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAuthorizingGroupTypes")
		tkh.SetAuthorizingGroupTypes(val)
	}
	{
		val, d := tfObjectToTKHDSGroupGroupClassificationPrimer(ctx, false, toObjectValue(planAttrValues["classification"]), toObjectValue(configAttrValues["classification"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClassification")
		tkh.SetClassification(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["description"]))+" using SetDescription")
	tkh.SetDescription(tfToStringPointer(planAttrValues["description"]))
	{
		val, d := parseCastPointer(planAttrValues["extended_access"].(basetypes.StringValue), keyhubmodel.ParseGroupGroupExtendedAccess, func(val any) keyhubmodel.GroupGroupExtendedAccess {
			return *val.(*keyhubmodel.GroupGroupExtendedAccess)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetExtendedAccess")
		tkh.SetExtendedAccess(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["hide_audit_trail"]))+" using SetHideAuditTrail")
	tkh.SetHideAuditTrail(tfToBooleanPointer(planAttrValues["hide_audit_trail"]))
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["nested_under"]), toObjectValue(configAttrValues["nested_under"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetNestedUnder")
		tkh.SetNestedUnder(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["private_group"]))+" using SetPrivateGroup")
	tkh.SetPrivateGroup(tfToBooleanPointer(planAttrValues["private_group"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["profile_administration"]))+" using SetProfileAdministration")
	tkh.SetProfileAdministration(tfToBooleanPointer(planAttrValues["profile_administration"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["record_trail"]))+" using SetRecordTrail")
	tkh.SetRecordTrail(tfToBooleanPointer(planAttrValues["record_trail"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["rotating_password_required"]))+" using SetRotatingPasswordRequired")
	tkh.SetRotatingPasswordRequired(tfToBooleanPointer(planAttrValues["rotating_password_required"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["single_managed"]))+" using SetSingleManaged")
	tkh.SetSingleManaged(tfToBooleanPointer(planAttrValues["single_managed"]))
	{
		val, d := parseCastPointer(planAttrValues["vault_recovery"].(basetypes.StringValue), keyhubmodel.ParseGroupVaultRecoveryAvailability, func(val any) keyhubmodel.GroupVaultRecoveryAvailability {
			return *val.(*keyhubmodel.GroupVaultRecoveryAvailability)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetVaultRecovery")
		tkh.SetVaultRecovery(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["vault_requires_activation"]))+" using SetVaultRequiresActivation")
	tkh.SetVaultRequiresActivation(tfToBooleanPointer(planAttrValues["vault_requires_activation"]))
	if recurse {
		{
			val, d := tfObjectToTKHDSGroupGroup_additionalObjects(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupGroupRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupable
	tkh = keyhubmodel.NewGroupGroup()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["admin"]))+" using SetAdmin")
	tkh.SetAdmin(tfToBooleanPointer(planAttrValues["admin"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfObjectToTKHDSROOrganizationOrganizationalUnitPrimerRO(ctx, recurse, toObjectValue(planAttrValues["organizational_unit"]), toObjectValue(configAttrValues["organizational_unit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOrganizationalUnit")
		tkh.SetOrganizationalUnit(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["application_administration"]))+" using SetApplicationAdministration")
	tkh.SetApplicationAdministration(tfToBooleanPointer(planAttrValues["application_administration"]))
	{
		val, d := tfObjectToTKHDSROGroupGroupAuditConfigRO(ctx, false, toObjectValue(planAttrValues["audit_config"]), toObjectValue(configAttrValues["audit_config"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAuditConfig")
		tkh.SetAuditConfig(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["audit_requested"]))+" using SetAuditRequested")
	tkh.SetAuditRequested(tfToBooleanPointer(planAttrValues["audit_requested"]))
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["authorizing_group_auditing"]), toObjectValue(configAttrValues["authorizing_group_auditing"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAuthorizingGroupAuditing")
		tkh.SetAuthorizingGroupAuditing(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["authorizing_group_delegation"]), toObjectValue(configAttrValues["authorizing_group_delegation"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAuthorizingGroupDelegation")
		tkh.SetAuthorizingGroupDelegation(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["authorizing_group_membership"]), toObjectValue(configAttrValues["authorizing_group_membership"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAuthorizingGroupMembership")
		tkh.SetAuthorizingGroupMembership(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["authorizing_group_provisioning"]), toObjectValue(configAttrValues["authorizing_group_provisioning"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAuthorizingGroupProvisioning")
		tkh.SetAuthorizingGroupProvisioning(val)
	}
	{
		val, d := tfToSliceSet(toSetValue(planAttrValues["authorizing_group_types"]), toSetValue(configAttrValues["authorizing_group_types"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RequestAuthorizingGroupType {
			tkh, d := parseCast(planValue.(basetypes.StringValue), keyhubmodel.ParseRequestAuthorizingGroupType, func(val any) keyhubmodel.RequestAuthorizingGroupType {
				return *val.(*keyhubmodel.RequestAuthorizingGroupType)
			})
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAuthorizingGroupTypes")
		tkh.SetAuthorizingGroupTypes(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupClassificationPrimerRO(ctx, false, toObjectValue(planAttrValues["classification"]), toObjectValue(configAttrValues["classification"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClassification")
		tkh.SetClassification(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["description"]))+" using SetDescription")
	tkh.SetDescription(tfToStringPointer(planAttrValues["description"]))
	{
		val, d := parseCastPointer(planAttrValues["extended_access"].(basetypes.StringValue), keyhubmodel.ParseGroupGroupExtendedAccess, func(val any) keyhubmodel.GroupGroupExtendedAccess {
			return *val.(*keyhubmodel.GroupGroupExtendedAccess)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetExtendedAccess")
		tkh.SetExtendedAccess(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["hide_audit_trail"]))+" using SetHideAuditTrail")
	tkh.SetHideAuditTrail(tfToBooleanPointer(planAttrValues["hide_audit_trail"]))
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["nested_under"]), toObjectValue(configAttrValues["nested_under"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetNestedUnder")
		tkh.SetNestedUnder(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["private_group"]))+" using SetPrivateGroup")
	tkh.SetPrivateGroup(tfToBooleanPointer(planAttrValues["private_group"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["profile_administration"]))+" using SetProfileAdministration")
	tkh.SetProfileAdministration(tfToBooleanPointer(planAttrValues["profile_administration"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["record_trail"]))+" using SetRecordTrail")
	tkh.SetRecordTrail(tfToBooleanPointer(planAttrValues["record_trail"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["rotating_password_required"]))+" using SetRotatingPasswordRequired")
	tkh.SetRotatingPasswordRequired(tfToBooleanPointer(planAttrValues["rotating_password_required"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["single_managed"]))+" using SetSingleManaged")
	tkh.SetSingleManaged(tfToBooleanPointer(planAttrValues["single_managed"]))
	{
		val, d := parseCastPointer(planAttrValues["vault_recovery"].(basetypes.StringValue), keyhubmodel.ParseGroupVaultRecoveryAvailability, func(val any) keyhubmodel.GroupVaultRecoveryAvailability {
			return *val.(*keyhubmodel.GroupVaultRecoveryAvailability)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetVaultRecovery")
		tkh.SetVaultRecovery(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["vault_requires_activation"]))+" using SetVaultRequiresActivation")
	tkh.SetVaultRequiresActivation(tfToBooleanPointer(planAttrValues["vault_requires_activation"]))
	if recurse {
		{
			val, d := tfObjectToTKHDSROGroupGroup_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupGroupAccessInfoRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupAccessInfoable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupAccessInfoable
	tkh = keyhubmodel.NewGroupGroupAccessInfo()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["business_accounts"]))+" using SetBusinessAccounts")
	tkh.SetBusinessAccounts(tfToBooleanPointer(planAttrValues["business_accounts"]))
	return tkh, diags
}

func tfObjectToTKHDSGroupGroupAccount(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupAccountable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupAccountable
	tkh = keyhubmodel.NewGroupGroupAccount()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["display_name"]))+" using SetDisplayName")
	tkh.SetDisplayName(tfToStringPointer(planAttrValues["display_name"]))
	{
		val, d := tfToTimePointer(planAttrValues["last_active"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLastActive")
		tkh.SetLastActive(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["username"]))+" using SetUsername")
	tkh.SetUsername(tfToStringPointer(planAttrValues["username"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	{
		val, d := parseCastPointer(planAttrValues["validity"].(basetypes.StringValue), keyhubmodel.ParseAuthAccountValidity, func(val any) keyhubmodel.AuthAccountValidity { return *val.(*keyhubmodel.AuthAccountValidity) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetValidity")
		tkh.SetValidity(val)
	}
	{
		val, d := tfObjectToTKHDSRODirectoryAccountDirectoryPrimerRO(ctx, false, toObjectValue(planAttrValues["directory"]), toObjectValue(configAttrValues["directory"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDirectory")
		tkh.SetDirectory(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["disconnected_nested"]))+" using SetDisconnectedNested")
	tkh.SetDisconnectedNested(tfToBooleanPointer(planAttrValues["disconnected_nested"]))
	{
		val, d := parsePointer2(planAttrValues["end_date"].(basetypes.StringValue), serialization.ParseDateOnly)
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetEndDate")
		tkh.SetEndDate(val)
	}
	{
		val, d := parsePointer2(planAttrValues["last_used"].(basetypes.StringValue), serialization.ParseDateOnly)
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLastUsed")
		tkh.SetLastUsed(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["nested"]))+" using SetNested")
	tkh.SetNested(tfToBooleanPointer(planAttrValues["nested"]))
	{
		val, d := tfToTimePointer(planAttrValues["provisioning_end_time"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetProvisioningEndTime")
		tkh.SetProvisioningEndTime(val)
	}
	{
		val, d := tfToTimePointer(planAttrValues["provisioning_permission_end_time"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetProvisioningPermissionEndTime")
		tkh.SetProvisioningPermissionEndTime(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["rights"].(basetypes.StringValue), keyhubmodel.ParseGroupGroupRights, func(val any) keyhubmodel.GroupGroupRights { return *val.(*keyhubmodel.GroupGroupRights) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetRights")
		tkh.SetRights(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["two_factor_status"].(basetypes.StringValue), keyhubmodel.ParseAuthTwoFactorAuthenticationStatus, func(val any) keyhubmodel.AuthTwoFactorAuthenticationStatus {
			return *val.(*keyhubmodel.AuthTwoFactorAuthenticationStatus)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTwoFactorStatus")
		tkh.SetTwoFactorStatus(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["visible_for_provisioning"]))+" using SetVisibleForProvisioning")
	tkh.SetVisibleForProvisioning(tfToBooleanPointer(planAttrValues["visible_for_provisioning"]))
	if recurse {
		{
			val, d := tfObjectToTKHDSGroupGroupAccount_additionalObjects(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupGroupAccountRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupAccountable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupAccountable
	tkh = keyhubmodel.NewGroupGroupAccount()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["display_name"]))+" using SetDisplayName")
	tkh.SetDisplayName(tfToStringPointer(planAttrValues["display_name"]))
	{
		val, d := tfToTimePointer(planAttrValues["last_active"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLastActive")
		tkh.SetLastActive(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["username"]))+" using SetUsername")
	tkh.SetUsername(tfToStringPointer(planAttrValues["username"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	{
		val, d := parseCastPointer(planAttrValues["validity"].(basetypes.StringValue), keyhubmodel.ParseAuthAccountValidity, func(val any) keyhubmodel.AuthAccountValidity { return *val.(*keyhubmodel.AuthAccountValidity) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetValidity")
		tkh.SetValidity(val)
	}
	{
		val, d := tfObjectToTKHDSRODirectoryAccountDirectoryPrimerRO(ctx, false, toObjectValue(planAttrValues["directory"]), toObjectValue(configAttrValues["directory"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDirectory")
		tkh.SetDirectory(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["disconnected_nested"]))+" using SetDisconnectedNested")
	tkh.SetDisconnectedNested(tfToBooleanPointer(planAttrValues["disconnected_nested"]))
	{
		val, d := parsePointer2(planAttrValues["end_date"].(basetypes.StringValue), serialization.ParseDateOnly)
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetEndDate")
		tkh.SetEndDate(val)
	}
	{
		val, d := parsePointer2(planAttrValues["last_used"].(basetypes.StringValue), serialization.ParseDateOnly)
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLastUsed")
		tkh.SetLastUsed(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["nested"]))+" using SetNested")
	tkh.SetNested(tfToBooleanPointer(planAttrValues["nested"]))
	{
		val, d := tfToTimePointer(planAttrValues["provisioning_end_time"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetProvisioningEndTime")
		tkh.SetProvisioningEndTime(val)
	}
	{
		val, d := tfToTimePointer(planAttrValues["provisioning_permission_end_time"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetProvisioningPermissionEndTime")
		tkh.SetProvisioningPermissionEndTime(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["rights"].(basetypes.StringValue), keyhubmodel.ParseGroupGroupRights, func(val any) keyhubmodel.GroupGroupRights { return *val.(*keyhubmodel.GroupGroupRights) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetRights")
		tkh.SetRights(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["two_factor_status"].(basetypes.StringValue), keyhubmodel.ParseAuthTwoFactorAuthenticationStatus, func(val any) keyhubmodel.AuthTwoFactorAuthenticationStatus {
			return *val.(*keyhubmodel.AuthTwoFactorAuthenticationStatus)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTwoFactorStatus")
		tkh.SetTwoFactorStatus(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["visible_for_provisioning"]))+" using SetVisibleForProvisioning")
	tkh.SetVisibleForProvisioning(tfToBooleanPointer(planAttrValues["visible_for_provisioning"]))
	if recurse {
		{
			val, d := tfObjectToTKHDSROGroupGroupAccount_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSGroupGroupAccountLinkableWrapper(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupAccountLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupAccountLinkableWrapperable
	tkh = keyhubmodel.NewGroupGroupAccountLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.GroupGroupAccountable {
			tkh, d := tfObjectToTKHDSGroupGroupAccount(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupGroupAccountLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupAccountLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupAccountLinkableWrapperable
	tkh = keyhubmodel.NewGroupGroupAccountLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.GroupGroupAccountable {
			tkh, d := tfObjectToTKHDSROGroupGroupAccountRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSGroupGroupAccount_additionalObjects(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupAccount_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupAccount_additionalObjectsable
	tkh = keyhubmodel.NewGroupGroupAccount_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupGroupAccount_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupAccount_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupAccount_additionalObjectsable
	tkh = keyhubmodel.NewGroupGroupAccount_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSGroupGroupAuditConfig(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupAuditConfigable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupAuditConfigable
	tkh = keyhubmodel.NewGroupGroupAuditConfig()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := tfToSliceSet(toSetValue(planAttrValues["months"]), toSetValue(configAttrValues["months"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.Month {
			tkh, d := parseCast(planValue.(basetypes.StringValue), keyhubmodel.ParseMonth, func(val any) keyhubmodel.Month { return *val.(*keyhubmodel.Month) })
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetMonths")
		tkh.SetMonths(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupGroupAuditConfigRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupAuditConfigable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupAuditConfigable
	tkh = keyhubmodel.NewGroupGroupAuditConfig()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := tfToSliceSet(toSetValue(planAttrValues["months"]), toSetValue(configAttrValues["months"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.Month {
			tkh, d := parseCast(planValue.(basetypes.StringValue), keyhubmodel.ParseMonth, func(val any) keyhubmodel.Month { return *val.(*keyhubmodel.Month) })
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetMonths")
		tkh.SetMonths(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupGroupAuditingInfoRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupAuditingInfoable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupAuditingInfoable
	tkh = keyhubmodel.NewGroupGroupAuditingInfo()
	{
		val, d := parsePointer2(planAttrValues["audit_due_date"].(basetypes.StringValue), serialization.ParseDateOnly)
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAuditDueDate")
		tkh.SetAuditDueDate(val)
	}
	{
		val, d := parsePointer2(planAttrValues["last_audit_date"].(basetypes.StringValue), serialization.ParseDateOnly)
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLastAuditDate")
		tkh.SetLastAuditDate(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["nr_accounts"]))+" using SetNrAccounts")
	tkh.SetNrAccounts(tfToInt64Pointer(planAttrValues["nr_accounts"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["nr_disabled_accounts"]))+" using SetNrDisabledAccounts")
	tkh.SetNrDisabledAccounts(tfToInt64Pointer(planAttrValues["nr_disabled_accounts"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["nr_disabled_managers"]))+" using SetNrDisabledManagers")
	tkh.SetNrDisabledManagers(tfToInt64Pointer(planAttrValues["nr_disabled_managers"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["nr_expired_vault_records"]))+" using SetNrExpiredVaultRecords")
	tkh.SetNrExpiredVaultRecords(tfToInt64Pointer(planAttrValues["nr_expired_vault_records"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["nr_managers"]))+" using SetNrManagers")
	tkh.SetNrManagers(tfToInt64Pointer(planAttrValues["nr_managers"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["nr_vault_records_with_end_date"]))+" using SetNrVaultRecordsWithEndDate")
	tkh.SetNrVaultRecordsWithEndDate(tfToInt64Pointer(planAttrValues["nr_vault_records_with_end_date"]))
	return tkh, diags
}

func tfObjectToTKHDSGroupGroupClassification(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupClassificationable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupClassificationable
	tkh = keyhubmodel.NewGroupGroupClassification()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["authorizing_group_auditing_required"]))+" using SetAuthorizingGroupAuditingRequired")
	tkh.SetAuthorizingGroupAuditingRequired(tfToBooleanPointer(planAttrValues["authorizing_group_auditing_required"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["authorizing_group_delegation_required"]))+" using SetAuthorizingGroupDelegationRequired")
	tkh.SetAuthorizingGroupDelegationRequired(tfToBooleanPointer(planAttrValues["authorizing_group_delegation_required"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["authorizing_group_membership_required"]))+" using SetAuthorizingGroupMembershipRequired")
	tkh.SetAuthorizingGroupMembershipRequired(tfToBooleanPointer(planAttrValues["authorizing_group_membership_required"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["authorizing_group_provisioning_required"]))+" using SetAuthorizingGroupProvisioningRequired")
	tkh.SetAuthorizingGroupProvisioningRequired(tfToBooleanPointer(planAttrValues["authorizing_group_provisioning_required"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["default_classification"]))+" using SetDefaultClassification")
	tkh.SetDefaultClassification(tfToBooleanPointer(planAttrValues["default_classification"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["description"]))+" using SetDescription")
	tkh.SetDescription(tfToStringPointer(planAttrValues["description"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["maximum_audit_interval"])))+" using SetMaximumAuditInterval")
	tkh.SetMaximumAuditInterval(int64PToInt32P(tfToInt64Pointer(planAttrValues["maximum_audit_interval"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["minimum_nr_managers"])))+" using SetMinimumNrManagers")
	tkh.SetMinimumNrManagers(int64PToInt32P(tfToInt64Pointer(planAttrValues["minimum_nr_managers"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["record_trail_required"]))+" using SetRecordTrailRequired")
	tkh.SetRecordTrailRequired(tfToBooleanPointer(planAttrValues["record_trail_required"]))
	{
		val, d := tfToSliceSet(toSetValue(planAttrValues["required_months"]), toSetValue(configAttrValues["required_months"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.Month {
			tkh, d := parseCast(planValue.(basetypes.StringValue), keyhubmodel.ParseMonth, func(val any) keyhubmodel.Month { return *val.(*keyhubmodel.Month) })
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetRequiredMonths")
		tkh.SetRequiredMonths(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["rotating_password_required"]))+" using SetRotatingPasswordRequired")
	tkh.SetRotatingPasswordRequired(tfToBooleanPointer(planAttrValues["rotating_password_required"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["vault_requires_activation"]))+" using SetVaultRequiresActivation")
	tkh.SetVaultRequiresActivation(tfToBooleanPointer(planAttrValues["vault_requires_activation"]))
	if recurse {
		{
			val, d := tfObjectToTKHDSGroupGroupClassification_additionalObjects(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupGroupClassificationInfoRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupClassificationInfoable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupClassificationInfoable
	tkh = keyhubmodel.NewGroupGroupClassificationInfo()
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["nr_groups"])))+" using SetNrGroups")
	tkh.SetNrGroups(int64PToInt32P(tfToInt64Pointer(planAttrValues["nr_groups"])))
	return tkh, diags
}

func tfObjectToTKHDSGroupGroupClassificationPrimer(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupClassificationPrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupClassificationPrimerable
	tkh = keyhubmodel.NewGroupGroupClassificationPrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	return tkh, diags
}

func tfObjectToTKHDSROGroupGroupClassificationPrimerRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupClassificationPrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupClassificationPrimerable
	tkh = keyhubmodel.NewGroupGroupClassificationPrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	return tkh, diags
}

func tfObjectToTKHDSGroupGroupClassification_additionalObjects(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupClassification_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupClassification_additionalObjectsable
	tkh = keyhubmodel.NewGroupGroupClassification_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupClassificationInfoRO(ctx, recurse, toObjectValue(planAttrValues["info"]), toObjectValue(configAttrValues["info"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetInfo")
		tkh.SetInfo(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSGroupGroupClient(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupClientable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupClientable
	tkh = keyhubmodel.NewGroupGroupClient()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["activation_required"]))+" using SetActivationRequired")
	tkh.SetActivationRequired(tfToBooleanPointer(planAttrValues["activation_required"]))
	{
		val, d := tfObjectToTKHDSROClientClientApplicationPrimerRO(ctx, false, toObjectValue(planAttrValues["client"]), toObjectValue(configAttrValues["client"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClient")
		tkh.SetClient(val)
	}
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["group"]), toObjectValue(configAttrValues["group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroup")
		tkh.SetGroup(val)
	}
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["owner"]), toObjectValue(configAttrValues["owner"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwner")
		tkh.SetOwner(val)
	}
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["technical_administrator"]), toObjectValue(configAttrValues["technical_administrator"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTechnicalAdministrator")
		tkh.SetTechnicalAdministrator(val)
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSGroupGroupClient_additionalObjects(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupGroupClientRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupClientable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupClientable
	tkh = keyhubmodel.NewGroupGroupClient()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["activation_required"]))+" using SetActivationRequired")
	tkh.SetActivationRequired(tfToBooleanPointer(planAttrValues["activation_required"]))
	{
		val, d := tfObjectToTKHDSROClientClientApplicationPrimerRO(ctx, false, toObjectValue(planAttrValues["client"]), toObjectValue(configAttrValues["client"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClient")
		tkh.SetClient(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["group"]), toObjectValue(configAttrValues["group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroup")
		tkh.SetGroup(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["owner"]), toObjectValue(configAttrValues["owner"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwner")
		tkh.SetOwner(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["technical_administrator"]), toObjectValue(configAttrValues["technical_administrator"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTechnicalAdministrator")
		tkh.SetTechnicalAdministrator(val)
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSROGroupGroupClient_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupGroupClientLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupClientLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupClientLinkableWrapperable
	tkh = keyhubmodel.NewGroupGroupClientLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.GroupGroupClientable {
			tkh, d := tfObjectToTKHDSROGroupGroupClientRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSGroupGroupClientLinkableWrapperWithCount(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupClientLinkableWrapperWithCountable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupClientLinkableWrapperWithCountable
	tkh = keyhubmodel.NewGroupGroupClientLinkableWrapperWithCount()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["count"]))+" using SetCount")
	tkh.SetCount(tfToInt64Pointer(planAttrValues["count"]))
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.GroupGroupClientable {
			tkh, d := tfObjectToTKHDSGroupGroupClient(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupGroupClientLinkableWrapperWithCountRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupClientLinkableWrapperWithCountable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupClientLinkableWrapperWithCountable
	tkh = keyhubmodel.NewGroupGroupClientLinkableWrapperWithCount()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["count"]))+" using SetCount")
	tkh.SetCount(tfToInt64Pointer(planAttrValues["count"]))
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.GroupGroupClientable {
			tkh, d := tfObjectToTKHDSROGroupGroupClientRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSGroupGroupClient_additionalObjects(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupClient_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupClient_additionalObjectsable
	tkh = keyhubmodel.NewGroupGroupClient_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupGroupClient_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupClient_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupClient_additionalObjectsable
	tkh = keyhubmodel.NewGroupGroupClient_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupGroupFolderRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupFolderable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupFolderable
	tkh = keyhubmodel.NewGroupGroupFolder()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	if recurse {
		{
			val, d := tfObjectToTKHDSROGroupGroupFolder_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupGroupFolder_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupFolder_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupFolder_additionalObjectsable
	tkh = keyhubmodel.NewGroupGroupFolder_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupGroupGlobalRoleInfoRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupGlobalRoleInfoable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupGlobalRoleInfoable
	tkh = keyhubmodel.NewGroupGroupGlobalRoleInfo()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["auditor_group_for"]), toListValue(configAttrValues["auditor_group_for"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.OrganizationOrganizationalUnitPrimerable {
			tkh, d := tfObjectToTKHDSROOrganizationOrganizationalUnitPrimerRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAuditorGroupFor")
		tkh.SetAuditorGroupFor(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["create_group_approve_group_for"]), toListValue(configAttrValues["create_group_approve_group_for"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.OrganizationOrganizationalUnitPrimerable {
			tkh, d := tfObjectToTKHDSROOrganizationOrganizationalUnitPrimerRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetCreateGroupApproveGroupFor")
		tkh.SetCreateGroupApproveGroupFor(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["enable_tech_admin_approve_group_for"]), toListValue(configAttrValues["enable_tech_admin_approve_group_for"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.OrganizationOrganizationalUnitPrimerable {
			tkh, d := tfObjectToTKHDSROOrganizationOrganizationalUnitPrimerRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetEnableTechAdminApproveGroupFor")
		tkh.SetEnableTechAdminApproveGroupFor(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["recovery_fallback_group_for"]), toListValue(configAttrValues["recovery_fallback_group_for"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.OrganizationOrganizationalUnitPrimerable {
			tkh, d := tfObjectToTKHDSROOrganizationOrganizationalUnitPrimerRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetRecoveryFallbackGroupFor")
		tkh.SetRecoveryFallbackGroupFor(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["remove_group_approve_group_for"]), toListValue(configAttrValues["remove_group_approve_group_for"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.OrganizationOrganizationalUnitPrimerable {
			tkh, d := tfObjectToTKHDSROOrganizationOrganizationalUnitPrimerRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetRemoveGroupApproveGroupFor")
		tkh.SetRemoveGroupApproveGroupFor(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupGroupInfoRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupInfoable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupInfoable
	tkh = keyhubmodel.NewGroupGroupInfo()
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["nr_accounts"])))+" using SetNrAccounts")
	tkh.SetNrAccounts(int64PToInt32P(tfToInt64Pointer(planAttrValues["nr_accounts"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["nr_accounts_with_vault"])))+" using SetNrAccountsWithVault")
	tkh.SetNrAccountsWithVault(int64PToInt32P(tfToInt64Pointer(planAttrValues["nr_accounts_with_vault"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["nr_audits"])))+" using SetNrAudits")
	tkh.SetNrAudits(int64PToInt32P(tfToInt64Pointer(planAttrValues["nr_audits"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["nr_clients"])))+" using SetNrClients")
	tkh.SetNrClients(int64PToInt32P(tfToInt64Pointer(planAttrValues["nr_clients"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["nr_provisioned_systems"])))+" using SetNrProvisionedSystems")
	tkh.SetNrProvisionedSystems(int64PToInt32P(tfToInt64Pointer(planAttrValues["nr_provisioned_systems"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["nr_vault_records"])))+" using SetNrVaultRecords")
	tkh.SetNrVaultRecords(int64PToInt32P(tfToInt64Pointer(planAttrValues["nr_vault_records"])))
	return tkh, diags
}

func tfObjectToTKHDSROGroupGroupLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupLinkableWrapperable
	tkh = keyhubmodel.NewGroupGroupLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.GroupGroupable {
			tkh, d := tfObjectToTKHDSROGroupGroupRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupGroupLinkableWrapperWithCountRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupLinkableWrapperWithCountable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupLinkableWrapperWithCountable
	tkh = keyhubmodel.NewGroupGroupLinkableWrapperWithCount()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["count"]))+" using SetCount")
	tkh.SetCount(tfToInt64Pointer(planAttrValues["count"]))
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.GroupGroupable {
			tkh, d := tfObjectToTKHDSROGroupGroupRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSGroupGroupPrimer(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupPrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupPrimerable
	tkh = keyhubmodel.NewGroupGroupPrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["admin"]))+" using SetAdmin")
	tkh.SetAdmin(tfToBooleanPointer(planAttrValues["admin"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfObjectToTKHDSOrganizationOrganizationalUnitPrimer(ctx, recurse, toObjectValue(planAttrValues["organizational_unit"]), toObjectValue(configAttrValues["organizational_unit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOrganizationalUnit")
		tkh.SetOrganizationalUnit(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	return tkh, diags
}

func tfObjectToTKHDSROGroupGroupPrimerRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupPrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupPrimerable
	tkh = keyhubmodel.NewGroupGroupPrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["admin"]))+" using SetAdmin")
	tkh.SetAdmin(tfToBooleanPointer(planAttrValues["admin"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfObjectToTKHDSROOrganizationOrganizationalUnitPrimerRO(ctx, recurse, toObjectValue(planAttrValues["organizational_unit"]), toObjectValue(configAttrValues["organizational_unit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOrganizationalUnit")
		tkh.SetOrganizationalUnit(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	return tkh, diags
}

func tfObjectToTKHDSROGroupGroupPrimerLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroupPrimerLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroupPrimerLinkableWrapperable
	tkh = keyhubmodel.NewGroupGroupPrimerLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.GroupGroupPrimerable {
			tkh, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSGroupGroup_additionalObjects(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroup_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroup_additionalObjectsable
	tkh = keyhubmodel.NewGroupGroup_additionalObjects()
	{
		val, d := tfObjectToTKHDSGroupGroupAccountLinkableWrapper(ctx, recurse, toItemsList(ctx, planAttrValues["accounts"]), toItemsList(ctx, configAttrValues["accounts"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAccounts")
		tkh.SetAccounts(val)
	}
	{
		val, d := tfObjectToTKHDSROClientClientApplicationLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["administered_clients"]), toItemsList(ctx, configAttrValues["administered_clients"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdministeredClients")
		tkh.SetAdministeredClients(val)
	}
	{
		val, d := tfObjectToTKHDSROProvisioningProvisionedSystemLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["administered_systems"]), toItemsList(ctx, configAttrValues["administered_systems"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdministeredSystems")
		tkh.SetAdministeredSystems(val)
	}
	{
		val, d := tfObjectToTKHDSGroupGroupAccountLinkableWrapper(ctx, recurse, toItemsList(ctx, planAttrValues["admins"]), toItemsList(ctx, configAttrValues["admins"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdmins")
		tkh.SetAdmins(val)
	}
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupLinkableWrapperWithCountRO(ctx, recurse, toItemsList(ctx, planAttrValues["authorized_groups"]), toItemsList(ctx, configAttrValues["authorized_groups"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAuthorizedGroups")
		tkh.SetAuthorizedGroups(val)
	}
	{
		val, d := tfObjectToTKHDSClientOAuth2ClientPermissionWithClientLinkableWrapper(ctx, recurse, toItemsList(ctx, planAttrValues["client_permissions"]), toItemsList(ctx, configAttrValues["client_permissions"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClientPermissions")
		tkh.SetClientPermissions(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupClientLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["clients"]), toItemsList(ctx, configAttrValues["clients"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClients")
		tkh.SetClients(val)
	}
	{
		val, d := tfObjectToTKHDSROProvisioningProvisionedSystemLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["content_administered_systems"]), toItemsList(ctx, configAttrValues["content_administered_systems"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetContentAdministeredSystems")
		tkh.SetContentAdministeredSystems(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupGlobalRoleInfoRO(ctx, recurse, toObjectValue(planAttrValues["global_roles"]), toObjectValue(configAttrValues["global_roles"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGlobalRoles")
		tkh.SetGlobalRoles(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupAccessInfoRO(ctx, recurse, toObjectValue(planAttrValues["group_access_info"]), toObjectValue(configAttrValues["group_access_info"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroupAccessInfo")
		tkh.SetGroupAccessInfo(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupAuditingInfoRO(ctx, recurse, toObjectValue(planAttrValues["groupauditinginfo"]), toObjectValue(configAttrValues["groupauditinginfo"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroupauditinginfo")
		tkh.SetGroupauditinginfo(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupInfoRO(ctx, recurse, toObjectValue(planAttrValues["groupinfo"]), toObjectValue(configAttrValues["groupinfo"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroupinfo")
		tkh.SetGroupinfo(val)
	}
	{
		val, d := tfObjectToTKHDSRODirectoryAccountDirectorySummaryLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["helpdesk"]), toItemsList(ctx, configAttrValues["helpdesk"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetHelpdesk")
		tkh.SetHelpdesk(val)
	}
	{
		val, d := tfObjectToTKHDSROMarkItemMarkersRO(ctx, recurse, toObjectValue(planAttrValues["markers"]), toObjectValue(configAttrValues["markers"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetMarkers")
		tkh.SetMarkers(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupAccountRO(ctx, recurse, toObjectValue(planAttrValues["myaccount"]), toObjectValue(configAttrValues["myaccount"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetMyaccount")
		tkh.SetMyaccount(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupAccountRO(ctx, recurse, toObjectValue(planAttrValues["mydelegatedaccount"]), toObjectValue(configAttrValues["mydelegatedaccount"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetMydelegatedaccount")
		tkh.SetMydelegatedaccount(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["nested_groups"]), toItemsList(ctx, configAttrValues["nested_groups"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetNestedGroups")
		tkh.SetNestedGroups(val)
	}
	{
		val, d := tfObjectToTKHDSROProfileAccessProfileLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["owned_access_profiles"]), toItemsList(ctx, configAttrValues["owned_access_profiles"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwnedAccessProfiles")
		tkh.SetOwnedAccessProfiles(val)
	}
	{
		val, d := tfObjectToTKHDSROClientClientApplicationLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["owned_clients"]), toItemsList(ctx, configAttrValues["owned_clients"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwnedClients")
		tkh.SetOwnedClients(val)
	}
	{
		val, d := tfObjectToTKHDSRODirectoryAccountDirectoryLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["owned_directories"]), toItemsList(ctx, configAttrValues["owned_directories"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwnedDirectories")
		tkh.SetOwnedDirectories(val)
	}
	{
		val, d := tfObjectToTKHDSROProvisioningOwnedGroupOnSystemsWrapperRO(ctx, recurse, toObjectValue(planAttrValues["owned_groups_on_system"]), toObjectValue(configAttrValues["owned_groups_on_system"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwnedGroupsOnSystem")
		tkh.SetOwnedGroupsOnSystem(val)
	}
	{
		val, d := tfObjectToTKHDSROOrganizationOrganizationalUnitLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["owned_organizational_units"]), toItemsList(ctx, configAttrValues["owned_organizational_units"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwnedOrganizationalUnits")
		tkh.SetOwnedOrganizationalUnits(val)
	}
	{
		val, d := tfObjectToTKHDSROProvisioningProvisionedSystemLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["owned_systems"]), toItemsList(ctx, configAttrValues["owned_systems"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwnedSystems")
		tkh.SetOwnedSystems(val)
	}
	{
		val, d := tfObjectToTKHDSROAuditGroupAuditLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["recent_audits"]), toItemsList(ctx, configAttrValues["recent_audits"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetRecentAudits")
		tkh.SetRecentAudits(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["requeststatus"].(basetypes.StringValue), keyhubmodel.ParseGroupGroupRequestStatus, func(val any) keyhubmodel.GroupGroupRequestStatus { return *val.(*keyhubmodel.GroupGroupRequestStatus) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetRequeststatus")
		tkh.SetRequeststatus(val)
	}
	{
		val, d := tfObjectToTKHDSROServiceaccountServiceAccountLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["service_accounts"]), toItemsList(ctx, configAttrValues["service_accounts"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetServiceAccounts")
		tkh.SetServiceAccounts(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupProvisioningGroupLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["systems"]), toItemsList(ctx, configAttrValues["systems"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSystems")
		tkh.SetSystems(val)
	}
	{
		val, d := tfObjectToTKHDSROVaultVaultRO(ctx, recurse, toObjectValue(planAttrValues["vault"]), toObjectValue(configAttrValues["vault"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetVault")
		tkh.SetVault(val)
	}
	{
		val, d := tfObjectToTKHDSROWebhookWebhookLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["webhooks"]), toItemsList(ctx, configAttrValues["webhooks"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetWebhooks")
		tkh.SetWebhooks(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupGroup_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupGroup_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupGroup_additionalObjectsable
	tkh = keyhubmodel.NewGroupGroup_additionalObjects()
	{
		val, d := tfObjectToTKHDSROGroupGroupAccountLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["accounts"]), toItemsList(ctx, configAttrValues["accounts"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAccounts")
		tkh.SetAccounts(val)
	}
	{
		val, d := tfObjectToTKHDSROClientClientApplicationLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["administered_clients"]), toItemsList(ctx, configAttrValues["administered_clients"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdministeredClients")
		tkh.SetAdministeredClients(val)
	}
	{
		val, d := tfObjectToTKHDSROProvisioningProvisionedSystemLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["administered_systems"]), toItemsList(ctx, configAttrValues["administered_systems"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdministeredSystems")
		tkh.SetAdministeredSystems(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupAccountLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["admins"]), toItemsList(ctx, configAttrValues["admins"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdmins")
		tkh.SetAdmins(val)
	}
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupLinkableWrapperWithCountRO(ctx, recurse, toItemsList(ctx, planAttrValues["authorized_groups"]), toItemsList(ctx, configAttrValues["authorized_groups"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAuthorizedGroups")
		tkh.SetAuthorizedGroups(val)
	}
	{
		val, d := tfObjectToTKHDSROClientOAuth2ClientPermissionWithClientLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["client_permissions"]), toItemsList(ctx, configAttrValues["client_permissions"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClientPermissions")
		tkh.SetClientPermissions(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupClientLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["clients"]), toItemsList(ctx, configAttrValues["clients"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClients")
		tkh.SetClients(val)
	}
	{
		val, d := tfObjectToTKHDSROProvisioningProvisionedSystemLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["content_administered_systems"]), toItemsList(ctx, configAttrValues["content_administered_systems"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetContentAdministeredSystems")
		tkh.SetContentAdministeredSystems(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupGlobalRoleInfoRO(ctx, recurse, toObjectValue(planAttrValues["global_roles"]), toObjectValue(configAttrValues["global_roles"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGlobalRoles")
		tkh.SetGlobalRoles(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupAccessInfoRO(ctx, recurse, toObjectValue(planAttrValues["group_access_info"]), toObjectValue(configAttrValues["group_access_info"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroupAccessInfo")
		tkh.SetGroupAccessInfo(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupAuditingInfoRO(ctx, recurse, toObjectValue(planAttrValues["groupauditinginfo"]), toObjectValue(configAttrValues["groupauditinginfo"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroupauditinginfo")
		tkh.SetGroupauditinginfo(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupInfoRO(ctx, recurse, toObjectValue(planAttrValues["groupinfo"]), toObjectValue(configAttrValues["groupinfo"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroupinfo")
		tkh.SetGroupinfo(val)
	}
	{
		val, d := tfObjectToTKHDSRODirectoryAccountDirectorySummaryLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["helpdesk"]), toItemsList(ctx, configAttrValues["helpdesk"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetHelpdesk")
		tkh.SetHelpdesk(val)
	}
	{
		val, d := tfObjectToTKHDSROMarkItemMarkersRO(ctx, recurse, toObjectValue(planAttrValues["markers"]), toObjectValue(configAttrValues["markers"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetMarkers")
		tkh.SetMarkers(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupAccountRO(ctx, recurse, toObjectValue(planAttrValues["myaccount"]), toObjectValue(configAttrValues["myaccount"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetMyaccount")
		tkh.SetMyaccount(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupAccountRO(ctx, recurse, toObjectValue(planAttrValues["mydelegatedaccount"]), toObjectValue(configAttrValues["mydelegatedaccount"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetMydelegatedaccount")
		tkh.SetMydelegatedaccount(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["nested_groups"]), toItemsList(ctx, configAttrValues["nested_groups"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetNestedGroups")
		tkh.SetNestedGroups(val)
	}
	{
		val, d := tfObjectToTKHDSROProfileAccessProfileLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["owned_access_profiles"]), toItemsList(ctx, configAttrValues["owned_access_profiles"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwnedAccessProfiles")
		tkh.SetOwnedAccessProfiles(val)
	}
	{
		val, d := tfObjectToTKHDSROClientClientApplicationLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["owned_clients"]), toItemsList(ctx, configAttrValues["owned_clients"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwnedClients")
		tkh.SetOwnedClients(val)
	}
	{
		val, d := tfObjectToTKHDSRODirectoryAccountDirectoryLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["owned_directories"]), toItemsList(ctx, configAttrValues["owned_directories"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwnedDirectories")
		tkh.SetOwnedDirectories(val)
	}
	{
		val, d := tfObjectToTKHDSROProvisioningOwnedGroupOnSystemsWrapperRO(ctx, recurse, toObjectValue(planAttrValues["owned_groups_on_system"]), toObjectValue(configAttrValues["owned_groups_on_system"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwnedGroupsOnSystem")
		tkh.SetOwnedGroupsOnSystem(val)
	}
	{
		val, d := tfObjectToTKHDSROOrganizationOrganizationalUnitLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["owned_organizational_units"]), toItemsList(ctx, configAttrValues["owned_organizational_units"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwnedOrganizationalUnits")
		tkh.SetOwnedOrganizationalUnits(val)
	}
	{
		val, d := tfObjectToTKHDSROProvisioningProvisionedSystemLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["owned_systems"]), toItemsList(ctx, configAttrValues["owned_systems"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwnedSystems")
		tkh.SetOwnedSystems(val)
	}
	{
		val, d := tfObjectToTKHDSROAuditGroupAuditLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["recent_audits"]), toItemsList(ctx, configAttrValues["recent_audits"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetRecentAudits")
		tkh.SetRecentAudits(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["requeststatus"].(basetypes.StringValue), keyhubmodel.ParseGroupGroupRequestStatus, func(val any) keyhubmodel.GroupGroupRequestStatus { return *val.(*keyhubmodel.GroupGroupRequestStatus) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetRequeststatus")
		tkh.SetRequeststatus(val)
	}
	{
		val, d := tfObjectToTKHDSROServiceaccountServiceAccountLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["service_accounts"]), toItemsList(ctx, configAttrValues["service_accounts"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetServiceAccounts")
		tkh.SetServiceAccounts(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupProvisioningGroupLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["systems"]), toItemsList(ctx, configAttrValues["systems"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSystems")
		tkh.SetSystems(val)
	}
	{
		val, d := tfObjectToTKHDSROVaultVaultRO(ctx, recurse, toObjectValue(planAttrValues["vault"]), toObjectValue(configAttrValues["vault"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetVault")
		tkh.SetVault(val)
	}
	{
		val, d := tfObjectToTKHDSROWebhookWebhookLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["webhooks"]), toItemsList(ctx, configAttrValues["webhooks"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetWebhooks")
		tkh.SetWebhooks(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupProvisioningGroupRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupProvisioningGroupable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupProvisioningGroupable
	tkh = keyhubmodel.NewGroupProvisioningGroup()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["activation_required"]))+" using SetActivationRequired")
	tkh.SetActivationRequired(tfToBooleanPointer(planAttrValues["activation_required"]))
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["group"]), toObjectValue(configAttrValues["group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroup")
		tkh.SetGroup(val)
	}
	{
		val, d := tfObjectToTKHDSROProvisioningGroupOnSystemRO(ctx, false, toObjectValue(planAttrValues["group_on_system"]), toObjectValue(configAttrValues["group_on_system"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroupOnSystem")
		tkh.SetGroupOnSystem(val)
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSROGroupProvisioningGroup_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupProvisioningGroupLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupProvisioningGroupLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupProvisioningGroupLinkableWrapperable
	tkh = keyhubmodel.NewGroupProvisioningGroupLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.GroupProvisioningGroupable {
			tkh, d := tfObjectToTKHDSROGroupProvisioningGroupRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupProvisioningGroupLinkableWrapperWithCountRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupProvisioningGroupLinkableWrapperWithCountable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupProvisioningGroupLinkableWrapperWithCountable
	tkh = keyhubmodel.NewGroupProvisioningGroupLinkableWrapperWithCount()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["count"]))+" using SetCount")
	tkh.SetCount(tfToInt64Pointer(planAttrValues["count"]))
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.GroupProvisioningGroupable {
			tkh, d := tfObjectToTKHDSROGroupProvisioningGroupRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROGroupProvisioningGroup_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.GroupProvisioningGroup_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.GroupProvisioningGroup_additionalObjectsable
	tkh = keyhubmodel.NewGroupProvisioningGroup_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSIdentityAccountAttributeDefinition(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.IdentityAccountAttributeDefinitionable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.IdentityAccountAttributeDefinitionable
	tkh = keyhubmodel.NewIdentityAccountAttributeDefinition()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["format"].(basetypes.StringValue), keyhubmodel.ParseIdentityAccountAttributeFormat, func(val any) keyhubmodel.IdentityAccountAttributeFormat {
			return *val.(*keyhubmodel.IdentityAccountAttributeFormat)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetFormat")
		tkh.SetFormat(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["list"]))+" using SetList")
	tkh.SetList(tfToBooleanPointer(planAttrValues["list"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["required"]))+" using SetRequired")
	tkh.SetRequired(tfToBooleanPointer(planAttrValues["required"]))
	{
		val, d := parseCastPointer(planAttrValues["system_definition"].(basetypes.StringValue), keyhubmodel.ParseIdentityAccountAttributeSystemDefinition, func(val any) keyhubmodel.IdentityAccountAttributeSystemDefinition {
			return *val.(*keyhubmodel.IdentityAccountAttributeSystemDefinition)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSystemDefinition")
		tkh.SetSystemDefinition(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["unique"]))+" using SetUnique")
	tkh.SetUnique(tfToBooleanPointer(planAttrValues["unique"]))
	if recurse {
		{
			val, d := tfObjectToTKHDSIdentityAccountAttributeDefinition_additionalObjects(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROIdentityAccountAttributeDefinitionRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.IdentityAccountAttributeDefinitionable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.IdentityAccountAttributeDefinitionable
	tkh = keyhubmodel.NewIdentityAccountAttributeDefinition()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["format"].(basetypes.StringValue), keyhubmodel.ParseIdentityAccountAttributeFormat, func(val any) keyhubmodel.IdentityAccountAttributeFormat {
			return *val.(*keyhubmodel.IdentityAccountAttributeFormat)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetFormat")
		tkh.SetFormat(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["list"]))+" using SetList")
	tkh.SetList(tfToBooleanPointer(planAttrValues["list"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["required"]))+" using SetRequired")
	tkh.SetRequired(tfToBooleanPointer(planAttrValues["required"]))
	{
		val, d := parseCastPointer(planAttrValues["system_definition"].(basetypes.StringValue), keyhubmodel.ParseIdentityAccountAttributeSystemDefinition, func(val any) keyhubmodel.IdentityAccountAttributeSystemDefinition {
			return *val.(*keyhubmodel.IdentityAccountAttributeSystemDefinition)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSystemDefinition")
		tkh.SetSystemDefinition(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["unique"]))+" using SetUnique")
	tkh.SetUnique(tfToBooleanPointer(planAttrValues["unique"]))
	if recurse {
		{
			val, d := tfObjectToTKHDSROIdentityAccountAttributeDefinition_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSIdentityAccountAttributeDefinition_additionalObjects(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.IdentityAccountAttributeDefinition_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.IdentityAccountAttributeDefinition_additionalObjectsable
	tkh = keyhubmodel.NewIdentityAccountAttributeDefinition_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROIdentityAccountAttributeDefinition_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.IdentityAccountAttributeDefinition_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.IdentityAccountAttributeDefinition_additionalObjectsable
	tkh = keyhubmodel.NewIdentityAccountAttributeDefinition_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROIdentityAccountAttributeRuleRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.IdentityAccountAttributeRuleable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.IdentityAccountAttributeRuleable
	tkh = keyhubmodel.NewIdentityAccountAttributeRule()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["allow_override"]))+" using SetAllowOverride")
	tkh.SetAllowOverride(tfToBooleanPointer(planAttrValues["allow_override"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["allow_self_service"]))+" using SetAllowSelfService")
	tkh.SetAllowSelfService(tfToBooleanPointer(planAttrValues["allow_self_service"]))
	{
		val, d := tfObjectToTKHDSROIdentityAccountAttributeDefinitionRO(ctx, false, toObjectValue(planAttrValues["attribute"]), toObjectValue(configAttrValues["attribute"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAttribute")
		tkh.SetAttribute(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["default_value"]))+" using SetDefaultValue")
	tkh.SetDefaultValue(tfToStringPointer(planAttrValues["default_value"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["priority_directory"])))+" using SetPriorityDirectory")
	tkh.SetPriorityDirectory(int64PToInt32P(tfToInt64Pointer(planAttrValues["priority_directory"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["priority_external_source"])))+" using SetPriorityExternalSource")
	tkh.SetPriorityExternalSource(int64PToInt32P(tfToInt64Pointer(planAttrValues["priority_external_source"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["priority_formula"])))+" using SetPriorityFormula")
	tkh.SetPriorityFormula(int64PToInt32P(tfToInt64Pointer(planAttrValues["priority_formula"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["priority_scim"])))+" using SetPrioritySCIM")
	tkh.SetPrioritySCIM(int64PToInt32P(tfToInt64Pointer(planAttrValues["priority_scim"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["script"]))+" using SetScript")
	tkh.SetScript(tfToStringPointer(planAttrValues["script"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["update_automatically"]))+" using SetUpdateAutomatically")
	tkh.SetUpdateAutomatically(tfToBooleanPointer(planAttrValues["update_automatically"]))
	if recurse {
		{
			val, d := tfObjectToTKHDSROIdentityAccountAttributeRule_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROIdentityAccountAttributeRuleLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.IdentityAccountAttributeRuleLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.IdentityAccountAttributeRuleLinkableWrapperable
	tkh = keyhubmodel.NewIdentityAccountAttributeRuleLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.IdentityAccountAttributeRuleable {
			tkh, d := tfObjectToTKHDSROIdentityAccountAttributeRuleRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROIdentityAccountAttributeRule_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.IdentityAccountAttributeRule_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.IdentityAccountAttributeRule_additionalObjectsable
	tkh = keyhubmodel.NewIdentityAccountAttributeRule_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROIdentityAccountAttributeValueSummaryRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.IdentityAccountAttributeValueSummaryable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.IdentityAccountAttributeValueSummaryable
	tkh = keyhubmodel.NewIdentityAccountAttributeValueSummary()
	{
		val, d := tfObjectToTKHDSROIdentityAccountAttributeDefinitionRO(ctx, recurse, toObjectValue(planAttrValues["attribute"]), toObjectValue(configAttrValues["attribute"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAttribute")
		tkh.SetAttribute(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["context"]))+" using SetContext")
	tkh.SetContext(tfToStringPointer(planAttrValues["context"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["current_value"]))+" using SetCurrentValue")
	tkh.SetCurrentValue(tfToStringPointer(planAttrValues["current_value"]))
	{
		val, d := tfToTimePointer(planAttrValues["date"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDate")
		tkh.SetDate(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["expected_value"]))+" using SetExpectedValue")
	tkh.SetExpectedValue(tfToStringPointer(planAttrValues["expected_value"]))
	{
		val, d := parseCastPointer(planAttrValues["source"].(basetypes.StringValue), keyhubmodel.ParseIdentityAccountAttributeSource, func(val any) keyhubmodel.IdentityAccountAttributeSource {
			return *val.(*keyhubmodel.IdentityAccountAttributeSource)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSource")
		tkh.SetSource(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["status"].(basetypes.StringValue), keyhubmodel.ParseIdentityAccountAttributeValueSelectionStatus, func(val any) keyhubmodel.IdentityAccountAttributeValueSelectionStatus {
			return *val.(*keyhubmodel.IdentityAccountAttributeValueSelectionStatus)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetStatus")
		tkh.SetStatus(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSIdentityIdentity(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.IdentityIdentityable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.IdentityIdentityable
	tkh = keyhubmodel.NewIdentityIdentity()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["display_name"]))+" using SetDisplayName")
	tkh.SetDisplayName(tfToStringPointer(planAttrValues["display_name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["family_name"]))+" using SetFamilyName")
	tkh.SetFamilyName(tfToStringPointer(planAttrValues["family_name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["given_name"]))+" using SetGivenName")
	tkh.SetGivenName(tfToStringPointer(planAttrValues["given_name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["middle_name"]))+" using SetMiddleName")
	tkh.SetMiddleName(tfToStringPointer(planAttrValues["middle_name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["private_email"]))+" using SetPrivateEmail")
	tkh.SetPrivateEmail(tfToStringPointer(planAttrValues["private_email"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["private_telephone"]))+" using SetPrivateTelephone")
	tkh.SetPrivateTelephone(tfToStringPointer(planAttrValues["private_telephone"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["telephone"]))+" using SetTelephone")
	tkh.SetTelephone(tfToStringPointer(planAttrValues["telephone"]))
	return tkh, diags
}

func tfObjectToTKHDSLaunchpadSsoApplicationLaunchpadTile(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.LaunchpadSsoApplicationLaunchpadTileable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.LaunchpadSsoApplicationLaunchpadTileable
	tkh = keyhubmodel.NewLaunchpadSsoApplicationLaunchpadTile()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uri"]))+" using SetUri")
	tkh.SetUri(tfToStringPointer(planAttrValues["uri"]))
	return tkh, diags
}

func tfObjectToTKHDSROLaunchpadSsoApplicationLaunchpadTileRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.LaunchpadSsoApplicationLaunchpadTileable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.LaunchpadSsoApplicationLaunchpadTileable
	tkh = keyhubmodel.NewLaunchpadSsoApplicationLaunchpadTile()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uri"]))+" using SetUri")
	tkh.SetUri(tfToStringPointer(planAttrValues["uri"]))
	return tkh, diags
}

func tfObjectToTKHDSLaunchpadVaultRecordLaunchpadTile(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.LaunchpadVaultRecordLaunchpadTileable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	var tkh keyhubmodel.LaunchpadVaultRecordLaunchpadTileable
	tkh = keyhubmodel.NewLaunchpadVaultRecordLaunchpadTile()
	return tkh, diags
}

func tfObjectToTKHDSROLaunchpadVaultRecordLaunchpadTileRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.LaunchpadVaultRecordLaunchpadTileable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	var tkh keyhubmodel.LaunchpadVaultRecordLaunchpadTileable
	tkh = keyhubmodel.NewLaunchpadVaultRecordLaunchpadTile()
	return tkh, diags
}

func tfObjectToTKHDSROMarkItemMarkerRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.MarkItemMarkerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.MarkItemMarkerable
	tkh = keyhubmodel.NewMarkItemMarker()
	{
		val, d := parseCastPointer(planAttrValues["level"].(basetypes.StringValue), keyhubmodel.ParseMarkItemMarkerLevel, func(val any) keyhubmodel.MarkItemMarkerLevel { return *val.(*keyhubmodel.MarkItemMarkerLevel) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLevel")
		tkh.SetLevel(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["type"].(basetypes.StringValue), keyhubmodel.ParseMarkItemMarkerType, func(val any) keyhubmodel.MarkItemMarkerType { return *val.(*keyhubmodel.MarkItemMarkerType) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetMarkItemMarkerType")
		tkh.SetMarkItemMarkerType(val)
	}
	{
		val, d := tfToMap(toMapValue(planAttrValues["parameters"]), toMapValue(configAttrValues["parameters"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) any {
			return planValue.(basetypes.StringValue).ValueString()
		}, keyhubmodel.NewMarkItemMarker_parameters())
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetParameters")
		tkh.SetParameters(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROMarkItemMarkersRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.MarkItemMarkersable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.MarkItemMarkersable
	tkh = keyhubmodel.NewMarkItemMarkers()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["markers"]), toListValue(configAttrValues["markers"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.MarkItemMarkerable {
			tkh, d := tfObjectToTKHDSROMarkItemMarkerRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetMarkers")
		tkh.SetMarkers(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSMiscAttributeCustomization(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.MiscAttributeCustomizationable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.MiscAttributeCustomizationable
	tkh = keyhubmodel.NewMiscAttributeCustomization()
	{
		val, d := tfObjectToTKHDSIdentityAccountAttributeDefinition(ctx, recurse, toObjectValue(planAttrValues["attribute_definition"]), toObjectValue(configAttrValues["attribute_definition"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAttributeDefinition")
		tkh.SetAttributeDefinition(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["script"]))+" using SetScript")
	tkh.SetScript(tfToStringPointer(planAttrValues["script"]))
	return tkh, diags
}

func tfObjectToTKHDSROMiscAttributeCustomizationRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.MiscAttributeCustomizationable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.MiscAttributeCustomizationable
	tkh = keyhubmodel.NewMiscAttributeCustomization()
	{
		val, d := tfObjectToTKHDSROIdentityAccountAttributeDefinitionRO(ctx, recurse, toObjectValue(planAttrValues["attribute_definition"]), toObjectValue(configAttrValues["attribute_definition"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAttributeDefinition")
		tkh.SetAttributeDefinition(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["script"]))+" using SetScript")
	tkh.SetScript(tfToStringPointer(planAttrValues["script"]))
	return tkh, diags
}

func tfObjectToTKHDSROOrganizationClientApplicationOrganizationalUnitRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.OrganizationClientApplicationOrganizationalUnitable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.OrganizationClientApplicationOrganizationalUnitable
	tkh = keyhubmodel.NewOrganizationClientApplicationOrganizationalUnit()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	return tkh, diags
}

func tfObjectToTKHDSROOrganizationClientApplicationOrganizationalUnitLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.OrganizationClientApplicationOrganizationalUnitLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.OrganizationClientApplicationOrganizationalUnitLinkableWrapperable
	tkh = keyhubmodel.NewOrganizationClientApplicationOrganizationalUnitLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.OrganizationClientApplicationOrganizationalUnitable {
			tkh, d := tfObjectToTKHDSROOrganizationClientApplicationOrganizationalUnitRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSOrganizationOrganizationalUnit(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.OrganizationOrganizationalUnitable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.OrganizationOrganizationalUnitable
	tkh = keyhubmodel.NewOrganizationOrganizationalUnit()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["auditor_group"]), toObjectValue(configAttrValues["auditor_group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAuditorGroup")
		tkh.SetAuditorGroup(val)
	}
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["create_group_approve_group"]), toObjectValue(configAttrValues["create_group_approve_group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetCreateGroupApproveGroup")
		tkh.SetCreateGroupApproveGroup(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["create_group_placeholder"]))+" using SetCreateGroupPlaceholder")
	tkh.SetCreateGroupPlaceholder(tfToStringPointer(planAttrValues["create_group_placeholder"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["depth"])))+" using SetDepth")
	tkh.SetDepth(int64PToInt32P(tfToInt64Pointer(planAttrValues["depth"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["description"]))+" using SetDescription")
	tkh.SetDescription(tfToStringPointer(planAttrValues["description"]))
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["enable_tech_admin_approve_group"]), toObjectValue(configAttrValues["enable_tech_admin_approve_group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetEnableTechAdminApproveGroup")
		tkh.SetEnableTechAdminApproveGroup(val)
	}
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["owner"]), toObjectValue(configAttrValues["owner"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwner")
		tkh.SetOwner(val)
	}
	{
		val, d := tfObjectToTKHDSROOrganizationOrganizationalUnitPrimerRO(ctx, false, toObjectValue(planAttrValues["parent"]), toObjectValue(configAttrValues["parent"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetParent")
		tkh.SetParent(val)
	}
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["recovery_fallback_group"]), toObjectValue(configAttrValues["recovery_fallback_group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetRecoveryFallbackGroup")
		tkh.SetRecoveryFallbackGroup(val)
	}
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["remove_group_approve_group"]), toObjectValue(configAttrValues["remove_group_approve_group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetRemoveGroupApproveGroup")
		tkh.SetRemoveGroupApproveGroup(val)
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSOrganizationOrganizationalUnit_additionalObjects(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROOrganizationOrganizationalUnitRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.OrganizationOrganizationalUnitable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.OrganizationOrganizationalUnitable
	tkh = keyhubmodel.NewOrganizationOrganizationalUnit()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["auditor_group"]), toObjectValue(configAttrValues["auditor_group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAuditorGroup")
		tkh.SetAuditorGroup(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["create_group_approve_group"]), toObjectValue(configAttrValues["create_group_approve_group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetCreateGroupApproveGroup")
		tkh.SetCreateGroupApproveGroup(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["create_group_placeholder"]))+" using SetCreateGroupPlaceholder")
	tkh.SetCreateGroupPlaceholder(tfToStringPointer(planAttrValues["create_group_placeholder"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["depth"])))+" using SetDepth")
	tkh.SetDepth(int64PToInt32P(tfToInt64Pointer(planAttrValues["depth"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["description"]))+" using SetDescription")
	tkh.SetDescription(tfToStringPointer(planAttrValues["description"]))
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["enable_tech_admin_approve_group"]), toObjectValue(configAttrValues["enable_tech_admin_approve_group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetEnableTechAdminApproveGroup")
		tkh.SetEnableTechAdminApproveGroup(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["owner"]), toObjectValue(configAttrValues["owner"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwner")
		tkh.SetOwner(val)
	}
	{
		val, d := tfObjectToTKHDSROOrganizationOrganizationalUnitPrimerRO(ctx, false, toObjectValue(planAttrValues["parent"]), toObjectValue(configAttrValues["parent"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetParent")
		tkh.SetParent(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["recovery_fallback_group"]), toObjectValue(configAttrValues["recovery_fallback_group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetRecoveryFallbackGroup")
		tkh.SetRecoveryFallbackGroup(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["remove_group_approve_group"]), toObjectValue(configAttrValues["remove_group_approve_group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetRemoveGroupApproveGroup")
		tkh.SetRemoveGroupApproveGroup(val)
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSROOrganizationOrganizationalUnit_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROOrganizationOrganizationalUnitLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.OrganizationOrganizationalUnitLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.OrganizationOrganizationalUnitLinkableWrapperable
	tkh = keyhubmodel.NewOrganizationOrganizationalUnitLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.OrganizationOrganizationalUnitable {
			tkh, d := tfObjectToTKHDSROOrganizationOrganizationalUnitRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSOrganizationOrganizationalUnitPrimer(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.OrganizationOrganizationalUnitPrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.OrganizationOrganizationalUnitPrimerable
	tkh = keyhubmodel.NewOrganizationOrganizationalUnitPrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	return tkh, diags
}

func tfObjectToTKHDSROOrganizationOrganizationalUnitPrimerRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.OrganizationOrganizationalUnitPrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.OrganizationOrganizationalUnitPrimerable
	tkh = keyhubmodel.NewOrganizationOrganizationalUnitPrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	return tkh, diags
}

func tfObjectToTKHDSROOrganizationOrganizationalUnitSettingsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.OrganizationOrganizationalUnitSettingsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.OrganizationOrganizationalUnitSettingsable
	tkh = keyhubmodel.NewOrganizationOrganizationalUnitSettings()
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, recurse, toObjectValue(planAttrValues["create_group_approve_group"]), toObjectValue(configAttrValues["create_group_approve_group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetCreateGroupApproveGroup")
		tkh.SetCreateGroupApproveGroup(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["create_group_placeholder"]))+" using SetCreateGroupPlaceholder")
	tkh.SetCreateGroupPlaceholder(tfToStringPointer(planAttrValues["create_group_placeholder"]))
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, recurse, toObjectValue(planAttrValues["enable_tech_admin_approve_group"]), toObjectValue(configAttrValues["enable_tech_admin_approve_group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetEnableTechAdminApproveGroup")
		tkh.SetEnableTechAdminApproveGroup(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, recurse, toObjectValue(planAttrValues["recovery_fallback_group"]), toObjectValue(configAttrValues["recovery_fallback_group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetRecoveryFallbackGroup")
		tkh.SetRecoveryFallbackGroup(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, recurse, toObjectValue(planAttrValues["remove_group_approve_group"]), toObjectValue(configAttrValues["remove_group_approve_group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetRemoveGroupApproveGroup")
		tkh.SetRemoveGroupApproveGroup(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSOrganizationOrganizationalUnit_additionalObjects(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.OrganizationOrganizationalUnit_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.OrganizationOrganizationalUnit_additionalObjectsable
	tkh = keyhubmodel.NewOrganizationOrganizationalUnit_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	{
		val, d := tfObjectToTKHDSROOrganizationOrganizationalUnitSettingsRO(ctx, recurse, toObjectValue(planAttrValues["settings"]), toObjectValue(configAttrValues["settings"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSettings")
		tkh.SetSettings(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROOrganizationOrganizationalUnit_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.OrganizationOrganizationalUnit_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.OrganizationOrganizationalUnit_additionalObjectsable
	tkh = keyhubmodel.NewOrganizationOrganizationalUnit_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	{
		val, d := tfObjectToTKHDSROOrganizationOrganizationalUnitSettingsRO(ctx, recurse, toObjectValue(planAttrValues["settings"]), toObjectValue(configAttrValues["settings"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSettings")
		tkh.SetSettings(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROProfileAccessProfileRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfileable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfileable
	tkh = keyhubmodel.NewProfileAccessProfile()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["activate_rule_script"]))+" using SetActivateRuleScript")
	tkh.SetActivateRuleScript(tfToStringPointer(planAttrValues["activate_rule_script"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["description"]))+" using SetDescription")
	tkh.SetDescription(tfToStringPointer(planAttrValues["description"]))
	{
		val, d := tfObjectToTKHDSRODirectoryAccountDirectoryPrimerRO(ctx, false, toObjectValue(planAttrValues["directory"]), toObjectValue(configAttrValues["directory"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDirectory")
		tkh.SetDirectory(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["match_rule_script"]))+" using SetMatchRuleScript")
	tkh.SetMatchRuleScript(tfToStringPointer(planAttrValues["match_rule_script"]))
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["owner"]), toObjectValue(configAttrValues["owner"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwner")
		tkh.SetOwner(val)
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSROProfileAccessProfile_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROProfileAccessProfileAccountRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfileAccountable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfileAccountable
	tkh = keyhubmodel.NewProfileAccessProfileAccount()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["display_name"]))+" using SetDisplayName")
	tkh.SetDisplayName(tfToStringPointer(planAttrValues["display_name"]))
	{
		val, d := tfToTimePointer(planAttrValues["last_active"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLastActive")
		tkh.SetLastActive(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["username"]))+" using SetUsername")
	tkh.SetUsername(tfToStringPointer(planAttrValues["username"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	{
		val, d := parseCastPointer(planAttrValues["validity"].(basetypes.StringValue), keyhubmodel.ParseAuthAccountValidity, func(val any) keyhubmodel.AuthAccountValidity { return *val.(*keyhubmodel.AuthAccountValidity) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetValidity")
		tkh.SetValidity(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["activation"].(basetypes.StringValue), keyhubmodel.ParseProfileAccessProfileAccountActivation, func(val any) keyhubmodel.ProfileAccessProfileAccountActivation {
			return *val.(*keyhubmodel.ProfileAccessProfileAccountActivation)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetActivation")
		tkh.SetActivation(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["manual"]))+" using SetManual")
	tkh.SetManual(tfToBooleanPointer(planAttrValues["manual"]))
	if recurse {
		{
			val, d := tfObjectToTKHDSROProfileAccessProfileAccount_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROProfileAccessProfileAccountWithAttributesRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfileAccountWithAttributesable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfileAccountWithAttributesable
	tkh = keyhubmodel.NewProfileAccessProfileAccountWithAttributes()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["display_name"]))+" using SetDisplayName")
	tkh.SetDisplayName(tfToStringPointer(planAttrValues["display_name"]))
	{
		val, d := tfToTimePointer(planAttrValues["last_active"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLastActive")
		tkh.SetLastActive(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["username"]))+" using SetUsername")
	tkh.SetUsername(tfToStringPointer(planAttrValues["username"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	{
		val, d := parseCastPointer(planAttrValues["validity"].(basetypes.StringValue), keyhubmodel.ParseAuthAccountValidity, func(val any) keyhubmodel.AuthAccountValidity { return *val.(*keyhubmodel.AuthAccountValidity) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetValidity")
		tkh.SetValidity(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["activation"].(basetypes.StringValue), keyhubmodel.ParseProfileAccessProfileAccountActivation, func(val any) keyhubmodel.ProfileAccessProfileAccountActivation {
			return *val.(*keyhubmodel.ProfileAccessProfileAccountActivation)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetActivation")
		tkh.SetActivation(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["manual"]))+" using SetManual")
	tkh.SetManual(tfToBooleanPointer(planAttrValues["manual"]))
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["attributes"]), toListValue(configAttrValues["attributes"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.IdentityAccountAttributeValueSummaryable {
			tkh, d := tfObjectToTKHDSROIdentityAccountAttributeValueSummaryRO(ctx, false, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAttributes")
		tkh.SetAttributes(val)
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSROProfileAccessProfileAccount_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROProfileAccessProfileAccountWithAttributesLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfileAccountWithAttributesLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfileAccountWithAttributesLinkableWrapperable
	tkh = keyhubmodel.NewProfileAccessProfileAccountWithAttributesLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.ProfileAccessProfileAccountWithAttributesable {
			tkh, d := tfObjectToTKHDSROProfileAccessProfileAccountWithAttributesRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROProfileAccessProfileAccount_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfileAccount_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfileAccount_additionalObjectsable
	tkh = keyhubmodel.NewProfileAccessProfileAccount_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSProfileAccessProfileClient(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfileClientable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfileClientable
	tkh = keyhubmodel.NewProfileAccessProfileClient()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := tfObjectToTKHDSProfileAccessProfilePrimer(ctx, false, toObjectValue(planAttrValues["access_profile"]), toObjectValue(configAttrValues["access_profile"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAccessProfile")
		tkh.SetAccessProfile(val)
	}
	{
		val, d := tfObjectToTKHDSROClientClientApplicationPrimerRO(ctx, false, toObjectValue(planAttrValues["client"]), toObjectValue(configAttrValues["client"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClient")
		tkh.SetClient(val)
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSProfileAccessProfileClient_additionalObjects(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROProfileAccessProfileClientRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfileClientable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfileClientable
	tkh = keyhubmodel.NewProfileAccessProfileClient()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := tfObjectToTKHDSROProfileAccessProfilePrimerRO(ctx, false, toObjectValue(planAttrValues["access_profile"]), toObjectValue(configAttrValues["access_profile"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAccessProfile")
		tkh.SetAccessProfile(val)
	}
	{
		val, d := tfObjectToTKHDSROClientClientApplicationPrimerRO(ctx, false, toObjectValue(planAttrValues["client"]), toObjectValue(configAttrValues["client"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClient")
		tkh.SetClient(val)
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSROProfileAccessProfileClient_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROProfileAccessProfileClientLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfileClientLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfileClientLinkableWrapperable
	tkh = keyhubmodel.NewProfileAccessProfileClientLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.ProfileAccessProfileClientable {
			tkh, d := tfObjectToTKHDSROProfileAccessProfileClientRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSProfileAccessProfileClientLinkableWrapperWithCount(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfileClientLinkableWrapperWithCountable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfileClientLinkableWrapperWithCountable
	tkh = keyhubmodel.NewProfileAccessProfileClientLinkableWrapperWithCount()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["count"]))+" using SetCount")
	tkh.SetCount(tfToInt64Pointer(planAttrValues["count"]))
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.ProfileAccessProfileClientable {
			tkh, d := tfObjectToTKHDSProfileAccessProfileClient(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROProfileAccessProfileClientLinkableWrapperWithCountRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfileClientLinkableWrapperWithCountable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfileClientLinkableWrapperWithCountable
	tkh = keyhubmodel.NewProfileAccessProfileClientLinkableWrapperWithCount()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["count"]))+" using SetCount")
	tkh.SetCount(tfToInt64Pointer(planAttrValues["count"]))
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.ProfileAccessProfileClientable {
			tkh, d := tfObjectToTKHDSROProfileAccessProfileClientRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSProfileAccessProfileClient_additionalObjects(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfileClient_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfileClient_additionalObjectsable
	tkh = keyhubmodel.NewProfileAccessProfileClient_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROProfileAccessProfileClient_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfileClient_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfileClient_additionalObjectsable
	tkh = keyhubmodel.NewProfileAccessProfileClient_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROProfileAccessProfileGroupRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfileGroupable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfileGroupable
	tkh = keyhubmodel.NewProfileAccessProfileGroup()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := tfObjectToTKHDSROProfileAccessProfilePrimerRO(ctx, false, toObjectValue(planAttrValues["access_profile"]), toObjectValue(configAttrValues["access_profile"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAccessProfile")
		tkh.SetAccessProfile(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["group"]), toObjectValue(configAttrValues["group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroup")
		tkh.SetGroup(val)
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSROProfileAccessProfileGroup_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROProfileAccessProfileGroupLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfileGroupLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfileGroupLinkableWrapperable
	tkh = keyhubmodel.NewProfileAccessProfileGroupLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.ProfileAccessProfileGroupable {
			tkh, d := tfObjectToTKHDSROProfileAccessProfileGroupRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROProfileAccessProfileGroup_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfileGroup_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfileGroup_additionalObjectsable
	tkh = keyhubmodel.NewProfileAccessProfileGroup_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROProfileAccessProfileLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfileLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfileLinkableWrapperable
	tkh = keyhubmodel.NewProfileAccessProfileLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.ProfileAccessProfileable {
			tkh, d := tfObjectToTKHDSROProfileAccessProfileRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSProfileAccessProfilePrimer(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfilePrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfilePrimerable
	tkh = keyhubmodel.NewProfileAccessProfilePrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	return tkh, diags
}

func tfObjectToTKHDSROProfileAccessProfilePrimerRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfilePrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfilePrimerable
	tkh = keyhubmodel.NewProfileAccessProfilePrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	return tkh, diags
}

func tfObjectToTKHDSROProfileAccessProfileProvisioningRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfileProvisioningable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfileProvisioningable
	tkh = keyhubmodel.NewProfileAccessProfileProvisioning()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := tfObjectToTKHDSROProfileAccessProfilePrimerRO(ctx, false, toObjectValue(planAttrValues["access_profile"]), toObjectValue(configAttrValues["access_profile"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAccessProfile")
		tkh.SetAccessProfile(val)
	}
	{
		val, d := tfObjectToTKHDSROProvisioningGroupOnSystemRO(ctx, false, toObjectValue(planAttrValues["group_on_system"]), toObjectValue(configAttrValues["group_on_system"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroupOnSystem")
		tkh.SetGroupOnSystem(val)
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSROProfileAccessProfileProvisioning_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROProfileAccessProfileProvisioningLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfileProvisioningLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfileProvisioningLinkableWrapperable
	tkh = keyhubmodel.NewProfileAccessProfileProvisioningLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.ProfileAccessProfileProvisioningable {
			tkh, d := tfObjectToTKHDSROProfileAccessProfileProvisioningRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROProfileAccessProfileProvisioningLinkableWrapperWithCountRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfileProvisioningLinkableWrapperWithCountable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfileProvisioningLinkableWrapperWithCountable
	tkh = keyhubmodel.NewProfileAccessProfileProvisioningLinkableWrapperWithCount()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["count"]))+" using SetCount")
	tkh.SetCount(tfToInt64Pointer(planAttrValues["count"]))
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.ProfileAccessProfileProvisioningable {
			tkh, d := tfObjectToTKHDSROProfileAccessProfileProvisioningRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROProfileAccessProfileProvisioning_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfileProvisioning_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfileProvisioning_additionalObjectsable
	tkh = keyhubmodel.NewProfileAccessProfileProvisioning_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROProfileAccessProfile_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProfileAccessProfile_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProfileAccessProfile_additionalObjectsable
	tkh = keyhubmodel.NewProfileAccessProfile_additionalObjects()
	{
		val, d := tfObjectToTKHDSROProfileAccessProfileAccountWithAttributesLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["accounts_with_attributes"]), toItemsList(ctx, configAttrValues["accounts_with_attributes"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAccountsWithAttributes")
		tkh.SetAccountsWithAttributes(val)
	}
	{
		val, d := tfObjectToTKHDSROIdentityAccountAttributeRuleLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["attribute_rules"]), toItemsList(ctx, configAttrValues["attribute_rules"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAttributeRules")
		tkh.SetAttributeRules(val)
	}
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	{
		val, d := tfObjectToTKHDSROProfileAccessProfileClientLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["clients"]), toItemsList(ctx, configAttrValues["clients"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClients")
		tkh.SetClients(val)
	}
	{
		val, d := tfObjectToTKHDSROProfileAccessProfileGroupLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["groups"]), toItemsList(ctx, configAttrValues["groups"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroups")
		tkh.SetGroups(val)
	}
	{
		val, d := tfObjectToTKHDSROProfileAccessProfileProvisioningLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["provisioning"]), toItemsList(ctx, configAttrValues["provisioning"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetProvisioning")
		tkh.SetProvisioning(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSProvisioningAbstractProvisionedLDAP(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningAbstractProvisionedLDAPable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningAbstractProvisionedLDAPable
	tkh = keyhubmodel.NewProvisioningAbstractProvisionedLDAP()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["attributes"]), toListValue(configAttrValues["attributes"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.MiscAttributeCustomizationable {
			tkh, d := tfObjectToTKHDSMiscAttributeCustomization(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAttributes")
		tkh.SetAttributes(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["base_dn"]))+" using SetBaseDN")
	tkh.SetBaseDN(tfToStringPointer(planAttrValues["base_dn"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["bind_dn"]))+" using SetBindDN")
	tkh.SetBindDN(tfToStringPointer(planAttrValues["bind_dn"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["bind_password"]))+" using SetBindPassword")
	tkh.SetBindPassword(tfToStringPointer(planAttrValues["bind_password"]))
	{
		val, d := tfObjectToTKHDSCertificateCertificatePrimer(ctx, recurse, toObjectValue(planAttrValues["client_certificate"]), toObjectValue(configAttrValues["client_certificate"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClientCertificate")
		tkh.SetClientCertificate(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["failover_host"]))+" using SetFailoverHost")
	tkh.SetFailoverHost(tfToStringPointer(planAttrValues["failover_host"]))
	{
		val, d := tfObjectToTKHDSCertificateCertificatePrimer(ctx, recurse, toObjectValue(planAttrValues["failover_trusted_certificate"]), toObjectValue(configAttrValues["failover_trusted_certificate"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetFailoverTrustedCertificate")
		tkh.SetFailoverTrustedCertificate(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["group_dn"]))+" using SetGroupDN")
	tkh.SetGroupDN(tfToStringPointer(planAttrValues["group_dn"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["host"]))+" using SetHost")
	tkh.SetHost(tfToStringPointer(planAttrValues["host"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["object_classes"]))+" using SetObjectClasses")
	tkh.SetObjectClasses(tfToStringPointer(planAttrValues["object_classes"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["port"])))+" using SetPort")
	tkh.SetPort(int64PToInt32P(tfToInt64Pointer(planAttrValues["port"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["service_account_dn"]))+" using SetServiceAccountDN")
	tkh.SetServiceAccountDN(tfToStringPointer(planAttrValues["service_account_dn"]))
	{
		val, d := parseCastPointer(planAttrValues["ssh_public_key_support"].(basetypes.StringValue), keyhubmodel.ParseProvisioningLDAPSshPublicKeySupport, func(val any) keyhubmodel.ProvisioningLDAPSshPublicKeySupport {
			return *val.(*keyhubmodel.ProvisioningLDAPSshPublicKeySupport)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSshPublicKeySupport")
		tkh.SetSshPublicKeySupport(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["tls"].(basetypes.StringValue), keyhubmodel.ParseTLSLevel, func(val any) keyhubmodel.TLSLevel { return *val.(*keyhubmodel.TLSLevel) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTls")
		tkh.SetTls(val)
	}
	{
		val, d := tfObjectToTKHDSCertificateCertificatePrimer(ctx, recurse, toObjectValue(planAttrValues["trusted_certificate"]), toObjectValue(configAttrValues["trusted_certificate"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTrustedCertificate")
		tkh.SetTrustedCertificate(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["user_dn"]))+" using SetUserDN")
	tkh.SetUserDN(tfToStringPointer(planAttrValues["user_dn"]))
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningAbstractProvisionedLDAPRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningAbstractProvisionedLDAPable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningAbstractProvisionedLDAPable
	tkh = keyhubmodel.NewProvisioningAbstractProvisionedLDAP()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["attributes"]), toListValue(configAttrValues["attributes"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.MiscAttributeCustomizationable {
			tkh, d := tfObjectToTKHDSROMiscAttributeCustomizationRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAttributes")
		tkh.SetAttributes(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["base_dn"]))+" using SetBaseDN")
	tkh.SetBaseDN(tfToStringPointer(planAttrValues["base_dn"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["bind_dn"]))+" using SetBindDN")
	tkh.SetBindDN(tfToStringPointer(planAttrValues["bind_dn"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["bind_password"]))+" using SetBindPassword")
	tkh.SetBindPassword(tfToStringPointer(planAttrValues["bind_password"]))
	{
		val, d := tfObjectToTKHDSROCertificateCertificatePrimerRO(ctx, recurse, toObjectValue(planAttrValues["client_certificate"]), toObjectValue(configAttrValues["client_certificate"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClientCertificate")
		tkh.SetClientCertificate(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["failover_host"]))+" using SetFailoverHost")
	tkh.SetFailoverHost(tfToStringPointer(planAttrValues["failover_host"]))
	{
		val, d := tfObjectToTKHDSROCertificateCertificatePrimerRO(ctx, recurse, toObjectValue(planAttrValues["failover_trusted_certificate"]), toObjectValue(configAttrValues["failover_trusted_certificate"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetFailoverTrustedCertificate")
		tkh.SetFailoverTrustedCertificate(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["group_dn"]))+" using SetGroupDN")
	tkh.SetGroupDN(tfToStringPointer(planAttrValues["group_dn"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["host"]))+" using SetHost")
	tkh.SetHost(tfToStringPointer(planAttrValues["host"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["object_classes"]))+" using SetObjectClasses")
	tkh.SetObjectClasses(tfToStringPointer(planAttrValues["object_classes"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["port"])))+" using SetPort")
	tkh.SetPort(int64PToInt32P(tfToInt64Pointer(planAttrValues["port"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["service_account_dn"]))+" using SetServiceAccountDN")
	tkh.SetServiceAccountDN(tfToStringPointer(planAttrValues["service_account_dn"]))
	{
		val, d := parseCastPointer(planAttrValues["ssh_public_key_support"].(basetypes.StringValue), keyhubmodel.ParseProvisioningLDAPSshPublicKeySupport, func(val any) keyhubmodel.ProvisioningLDAPSshPublicKeySupport {
			return *val.(*keyhubmodel.ProvisioningLDAPSshPublicKeySupport)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSshPublicKeySupport")
		tkh.SetSshPublicKeySupport(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["tls"].(basetypes.StringValue), keyhubmodel.ParseTLSLevel, func(val any) keyhubmodel.TLSLevel { return *val.(*keyhubmodel.TLSLevel) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTls")
		tkh.SetTls(val)
	}
	{
		val, d := tfObjectToTKHDSROCertificateCertificatePrimerRO(ctx, recurse, toObjectValue(planAttrValues["trusted_certificate"]), toObjectValue(configAttrValues["trusted_certificate"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTrustedCertificate")
		tkh.SetTrustedCertificate(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["user_dn"]))+" using SetUserDN")
	tkh.SetUserDN(tfToStringPointer(planAttrValues["user_dn"]))
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningCircuitBreakerStatisticsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningCircuitBreakerStatisticsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningCircuitBreakerStatisticsable
	tkh = keyhubmodel.NewProvisioningCircuitBreakerStatistics()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["number_of_failed_calls"]))+" using SetNumberOfFailedCalls")
	tkh.SetNumberOfFailedCalls(tfToInt64Pointer(planAttrValues["number_of_failed_calls"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["number_of_not_permitted_calls"]))+" using SetNumberOfNotPermittedCalls")
	tkh.SetNumberOfNotPermittedCalls(tfToInt64Pointer(planAttrValues["number_of_not_permitted_calls"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["number_of_successful_calls"]))+" using SetNumberOfSuccessfulCalls")
	tkh.SetNumberOfSuccessfulCalls(tfToInt64Pointer(planAttrValues["number_of_successful_calls"]))
	{
		val, d := parseCastPointer(planAttrValues["state"].(basetypes.StringValue), keyhubmodel.ParseProvisioningCircuitBreakerState, func(val any) keyhubmodel.ProvisioningCircuitBreakerState {
			return *val.(*keyhubmodel.ProvisioningCircuitBreakerState)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetState")
		tkh.SetState(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningGroupOnSystemRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningGroupOnSystemable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningGroupOnSystemable
	tkh = keyhubmodel.NewProvisioningGroupOnSystem()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["display_name"]))+" using SetDisplayName")
	tkh.SetDisplayName(tfToStringPointer(planAttrValues["display_name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name_in_system"]))+" using SetNameInSystem")
	tkh.SetNameInSystem(tfToStringPointer(planAttrValues["name_in_system"]))
	{
		val, d := parseCastPointer(planAttrValues["type"].(basetypes.StringValue), keyhubmodel.ParseProvisioningGroupOnSystemType, func(val any) keyhubmodel.ProvisioningGroupOnSystemType {
			return *val.(*keyhubmodel.ProvisioningGroupOnSystemType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetProvisioningGroupOnSystemPrimerType")
		tkh.SetProvisioningGroupOnSystemPrimerType(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["short_name_in_system"]))+" using SetShortNameInSystem")
	tkh.SetShortNameInSystem(tfToStringPointer(planAttrValues["short_name_in_system"]))
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["owner"]), toObjectValue(configAttrValues["owner"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwner")
		tkh.SetOwner(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["provisioning_enabled"]))+" using SetProvisioningEnabled")
	tkh.SetProvisioningEnabled(tfToBooleanPointer(planAttrValues["provisioning_enabled"]))
	if recurse {
		{
			val, d := tfObjectToTKHDSROProvisioningGroupOnSystem_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningGroupOnSystemLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningGroupOnSystemLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningGroupOnSystemLinkableWrapperable
	tkh = keyhubmodel.NewProvisioningGroupOnSystemLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.ProvisioningGroupOnSystemable {
			tkh, d := tfObjectToTKHDSROProvisioningGroupOnSystemRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningGroupOnSystemPrimerRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningGroupOnSystemPrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningGroupOnSystemPrimerable
	tkh = keyhubmodel.NewProvisioningGroupOnSystemPrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["display_name"]))+" using SetDisplayName")
	tkh.SetDisplayName(tfToStringPointer(planAttrValues["display_name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name_in_system"]))+" using SetNameInSystem")
	tkh.SetNameInSystem(tfToStringPointer(planAttrValues["name_in_system"]))
	{
		val, d := parseCastPointer(planAttrValues["type"].(basetypes.StringValue), keyhubmodel.ParseProvisioningGroupOnSystemType, func(val any) keyhubmodel.ProvisioningGroupOnSystemType {
			return *val.(*keyhubmodel.ProvisioningGroupOnSystemType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetProvisioningGroupOnSystemPrimerType")
		tkh.SetProvisioningGroupOnSystemPrimerType(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["short_name_in_system"]))+" using SetShortNameInSystem")
	tkh.SetShortNameInSystem(tfToStringPointer(planAttrValues["short_name_in_system"]))
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningGroupOnSystemTypesRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningGroupOnSystemTypesable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningGroupOnSystemTypesable
	tkh = keyhubmodel.NewProvisioningGroupOnSystemTypes()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["types"]), toListValue(configAttrValues["types"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.ProvisioningGroupOnSystemType {
			tkh, d := parseCast(planValue.(basetypes.StringValue), keyhubmodel.ParseProvisioningGroupOnSystemType, func(val any) keyhubmodel.ProvisioningGroupOnSystemType {
				return *val.(*keyhubmodel.ProvisioningGroupOnSystemType)
			})
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTypes")
		tkh.SetTypes(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningGroupOnSystem_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningGroupOnSystem_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningGroupOnSystem_additionalObjectsable
	tkh = keyhubmodel.NewProvisioningGroupOnSystem_additionalObjects()
	{
		val, d := tfObjectToTKHDSROProfileAccessProfileProvisioningLinkableWrapperWithCountRO(ctx, recurse, toItemsList(ctx, planAttrValues["access_profile_provisioning"]), toItemsList(ctx, configAttrValues["access_profile_provisioning"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAccessProfileProvisioning")
		tkh.SetAccessProfileProvisioning(val)
	}
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupProvisioningGroupLinkableWrapperWithCountRO(ctx, recurse, toItemsList(ctx, planAttrValues["provgroups"]), toItemsList(ctx, configAttrValues["provgroups"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetProvgroups")
		tkh.SetProvgroups(val)
	}
	{
		val, d := tfObjectToTKHDSROServiceaccountServiceAccountPrimerLinkableWrapperWithCountRO(ctx, recurse, toItemsList(ctx, planAttrValues["service_accounts"]), toItemsList(ctx, configAttrValues["service_accounts"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetServiceAccounts")
		tkh.SetServiceAccounts(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningOwnedGroupOnSystemsWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningOwnedGroupOnSystemsWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningOwnedGroupOnSystemsWrapperable
	tkh = keyhubmodel.NewProvisioningOwnedGroupOnSystemsWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.ProvisioningGroupOnSystemable {
			tkh, d := tfObjectToTKHDSROProvisioningGroupOnSystemRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["unlinked_count"]))+" using SetUnlinkedCount")
	tkh.SetUnlinkedCount(tfToInt64Pointer(planAttrValues["unlinked_count"]))
	return tkh, diags
}

func tfObjectToTKHDSProvisioningProvisionNumberSequence(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionNumberSequenceable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionNumberSequenceable
	tkh = keyhubmodel.NewProvisioningProvisionNumberSequence()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["next_id"]))+" using SetNextID")
	tkh.SetNextID(tfToInt64Pointer(planAttrValues["next_id"]))
	if recurse {
		{
			val, d := tfObjectToTKHDSProvisioningProvisionNumberSequence_additionalObjects(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningProvisionNumberSequenceRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionNumberSequenceable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionNumberSequenceable
	tkh = keyhubmodel.NewProvisioningProvisionNumberSequence()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["next_id"]))+" using SetNextID")
	tkh.SetNextID(tfToInt64Pointer(planAttrValues["next_id"]))
	if recurse {
		{
			val, d := tfObjectToTKHDSROProvisioningProvisionNumberSequence_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSProvisioningProvisionNumberSequence_additionalObjects(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionNumberSequence_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionNumberSequence_additionalObjectsable
	tkh = keyhubmodel.NewProvisioningProvisionNumberSequence_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	{
		val, d := tfObjectToTKHDSROProvisioningProvisionedSystemPrimerLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["systems"]), toItemsList(ctx, configAttrValues["systems"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSystems")
		tkh.SetSystems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningProvisionNumberSequence_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionNumberSequence_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionNumberSequence_additionalObjectsable
	tkh = keyhubmodel.NewProvisioningProvisionNumberSequence_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	{
		val, d := tfObjectToTKHDSROProvisioningProvisionedSystemPrimerLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["systems"]), toItemsList(ctx, configAttrValues["systems"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSystems")
		tkh.SetSystems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSProvisioningProvisionedAD(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedADable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedADable
	tkh = keyhubmodel.NewProvisioningProvisionedAD()
	{
		val, d := parseCastPointer(planAttrValues["sam_account_name_scheme"].(basetypes.StringValue), keyhubmodel.ParseProvisioningADSamAccountNameScheme, func(val any) keyhubmodel.ProvisioningADSamAccountNameScheme {
			return *val.(*keyhubmodel.ProvisioningADSamAccountNameScheme)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSamAccountNameScheme")
		tkh.SetSamAccountNameScheme(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningProvisionedADRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedADable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedADable
	tkh = keyhubmodel.NewProvisioningProvisionedAD()
	{
		val, d := parseCastPointer(planAttrValues["sam_account_name_scheme"].(basetypes.StringValue), keyhubmodel.ParseProvisioningADSamAccountNameScheme, func(val any) keyhubmodel.ProvisioningADSamAccountNameScheme {
			return *val.(*keyhubmodel.ProvisioningADSamAccountNameScheme)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSamAccountNameScheme")
		tkh.SetSamAccountNameScheme(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningProvisionedAccountRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedAccountable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedAccountable
	tkh = keyhubmodel.NewProvisioningProvisionedAccount()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["display_name"]))+" using SetDisplayName")
	tkh.SetDisplayName(tfToStringPointer(planAttrValues["display_name"]))
	{
		val, d := tfToTimePointer(planAttrValues["last_active"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLastActive")
		tkh.SetLastActive(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["username"]))+" using SetUsername")
	tkh.SetUsername(tfToStringPointer(planAttrValues["username"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	{
		val, d := parseCastPointer(planAttrValues["validity"].(basetypes.StringValue), keyhubmodel.ParseAuthAccountValidity, func(val any) keyhubmodel.AuthAccountValidity { return *val.(*keyhubmodel.AuthAccountValidity) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetValidity")
		tkh.SetValidity(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["uid"]))+" using SetUid")
	tkh.SetUid(tfToInt64Pointer(planAttrValues["uid"]))
	if recurse {
		{
			val, d := tfObjectToTKHDSROProvisioningProvisionedAccount_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningProvisionedAccount_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedAccount_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedAccount_additionalObjectsable
	tkh = keyhubmodel.NewProvisioningProvisionedAccount_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSProvisioningProvisionedAzureOIDCDirectory(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedAzureOIDCDirectoryable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedAzureOIDCDirectoryable
	tkh = keyhubmodel.NewProvisioningProvisionedAzureOIDCDirectory()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["accounts_writable"]))+" using SetAccountsWritable")
	tkh.SetAccountsWritable(tfToBooleanPointer(planAttrValues["accounts_writable"]))
	{
		val, d := tfObjectToTKHDSDirectoryAccountDirectoryPrimer(ctx, recurse, toObjectValue(planAttrValues["directory"]), toObjectValue(configAttrValues["directory"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDirectory")
		tkh.SetDirectory(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["tenant"]))+" using SetTenant")
	tkh.SetTenant(tfToStringPointer(planAttrValues["tenant"]))
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningProvisionedAzureOIDCDirectoryRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedAzureOIDCDirectoryable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedAzureOIDCDirectoryable
	tkh = keyhubmodel.NewProvisioningProvisionedAzureOIDCDirectory()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["accounts_writable"]))+" using SetAccountsWritable")
	tkh.SetAccountsWritable(tfToBooleanPointer(planAttrValues["accounts_writable"]))
	{
		val, d := tfObjectToTKHDSRODirectoryAccountDirectoryPrimerRO(ctx, recurse, toObjectValue(planAttrValues["directory"]), toObjectValue(configAttrValues["directory"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDirectory")
		tkh.SetDirectory(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["tenant"]))+" using SetTenant")
	tkh.SetTenant(tfToStringPointer(planAttrValues["tenant"]))
	return tkh, diags
}

func tfObjectToTKHDSProvisioningProvisionedAzureSyncLDAPDirectory(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedAzureSyncLDAPDirectoryable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedAzureSyncLDAPDirectoryable
	tkh = keyhubmodel.NewProvisioningProvisionedAzureSyncLDAPDirectory()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["client_id"]))+" using SetClientId")
	tkh.SetClientId(tfToStringPointer(planAttrValues["client_id"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["client_secret"]))+" using SetClientSecret")
	tkh.SetClientSecret(tfToStringPointer(planAttrValues["client_secret"]))
	{
		val, d := tfObjectToTKHDSDirectoryAccountDirectoryPrimer(ctx, recurse, toObjectValue(planAttrValues["directory"]), toObjectValue(configAttrValues["directory"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDirectory")
		tkh.SetDirectory(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["tenant"]))+" using SetTenant")
	tkh.SetTenant(tfToStringPointer(planAttrValues["tenant"]))
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningProvisionedAzureSyncLDAPDirectoryRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedAzureSyncLDAPDirectoryable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedAzureSyncLDAPDirectoryable
	tkh = keyhubmodel.NewProvisioningProvisionedAzureSyncLDAPDirectory()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["client_id"]))+" using SetClientId")
	tkh.SetClientId(tfToStringPointer(planAttrValues["client_id"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["client_secret"]))+" using SetClientSecret")
	tkh.SetClientSecret(tfToStringPointer(planAttrValues["client_secret"]))
	{
		val, d := tfObjectToTKHDSRODirectoryAccountDirectoryPrimerRO(ctx, recurse, toObjectValue(planAttrValues["directory"]), toObjectValue(configAttrValues["directory"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDirectory")
		tkh.SetDirectory(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["tenant"]))+" using SetTenant")
	tkh.SetTenant(tfToStringPointer(planAttrValues["tenant"]))
	return tkh, diags
}

func tfObjectToTKHDSProvisioningProvisionedAzureTenant(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedAzureTenantable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedAzureTenantable
	tkh = keyhubmodel.NewProvisioningProvisionedAzureTenant()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["client_id"]))+" using SetClientId")
	tkh.SetClientId(tfToStringPointer(planAttrValues["client_id"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["client_secret"]))+" using SetClientSecret")
	tkh.SetClientSecret(tfToStringPointer(planAttrValues["client_secret"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["idp_domain"]))+" using SetIdpDomain")
	tkh.SetIdpDomain(tfToStringPointer(planAttrValues["idp_domain"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["tenant"]))+" using SetTenant")
	tkh.SetTenant(tfToStringPointer(planAttrValues["tenant"]))
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningProvisionedAzureTenantRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedAzureTenantable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedAzureTenantable
	tkh = keyhubmodel.NewProvisioningProvisionedAzureTenant()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["client_id"]))+" using SetClientId")
	tkh.SetClientId(tfToStringPointer(planAttrValues["client_id"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["client_secret"]))+" using SetClientSecret")
	tkh.SetClientSecret(tfToStringPointer(planAttrValues["client_secret"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["idp_domain"]))+" using SetIdpDomain")
	tkh.SetIdpDomain(tfToStringPointer(planAttrValues["idp_domain"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["tenant"]))+" using SetTenant")
	tkh.SetTenant(tfToStringPointer(planAttrValues["tenant"]))
	return tkh, diags
}

func tfObjectToTKHDSProvisioningProvisionedInternalLDAP(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedInternalLDAPable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedInternalLDAPable
	tkh = keyhubmodel.NewProvisioningProvisionedInternalLDAP()
	{
		val, d := tfObjectToTKHDSClientLdapClient(ctx, recurse, toObjectValue(planAttrValues["client"]), toObjectValue(configAttrValues["client"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClient")
		tkh.SetClient(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningProvisionedInternalLDAPRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedInternalLDAPable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedInternalLDAPable
	tkh = keyhubmodel.NewProvisioningProvisionedInternalLDAP()
	{
		val, d := tfObjectToTKHDSROClientLdapClientRO(ctx, recurse, toObjectValue(planAttrValues["client"]), toObjectValue(configAttrValues["client"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClient")
		tkh.SetClient(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSProvisioningProvisionedLDAP(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedLDAPable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedLDAPable
	tkh = keyhubmodel.NewProvisioningProvisionedLDAP()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["gid"]))+" using SetGid")
	tkh.SetGid(tfToInt64Pointer(planAttrValues["gid"]))
	{
		val, d := tfObjectToTKHDSProvisioningProvisionNumberSequence(ctx, recurse, toObjectValue(planAttrValues["gid_numbering"]), toObjectValue(configAttrValues["gid_numbering"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGidNumbering")
		tkh.SetGidNumbering(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["hashing_scheme"].(basetypes.StringValue), keyhubmodel.ParseProvisioningLDAPPasswordHashingScheme, func(val any) keyhubmodel.ProvisioningLDAPPasswordHashingScheme {
			return *val.(*keyhubmodel.ProvisioningLDAPPasswordHashingScheme)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetHashingScheme")
		tkh.SetHashingScheme(val)
	}
	{
		val, d := tfObjectToTKHDSProvisioningProvisionNumberSequence(ctx, recurse, toObjectValue(planAttrValues["numbering"]), toObjectValue(configAttrValues["numbering"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetNumbering")
		tkh.SetNumbering(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningProvisionedLDAPRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedLDAPable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedLDAPable
	tkh = keyhubmodel.NewProvisioningProvisionedLDAP()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["gid"]))+" using SetGid")
	tkh.SetGid(tfToInt64Pointer(planAttrValues["gid"]))
	{
		val, d := tfObjectToTKHDSROProvisioningProvisionNumberSequenceRO(ctx, recurse, toObjectValue(planAttrValues["gid_numbering"]), toObjectValue(configAttrValues["gid_numbering"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGidNumbering")
		tkh.SetGidNumbering(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["hashing_scheme"].(basetypes.StringValue), keyhubmodel.ParseProvisioningLDAPPasswordHashingScheme, func(val any) keyhubmodel.ProvisioningLDAPPasswordHashingScheme {
			return *val.(*keyhubmodel.ProvisioningLDAPPasswordHashingScheme)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetHashingScheme")
		tkh.SetHashingScheme(val)
	}
	{
		val, d := tfObjectToTKHDSROProvisioningProvisionNumberSequenceRO(ctx, recurse, toObjectValue(planAttrValues["numbering"]), toObjectValue(configAttrValues["numbering"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetNumbering")
		tkh.SetNumbering(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSProvisioningProvisionedLDAPDirectory(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedLDAPDirectoryable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedLDAPDirectoryable
	tkh = keyhubmodel.NewProvisioningProvisionedLDAPDirectory()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["accounts_writable"]))+" using SetAccountsWritable")
	tkh.SetAccountsWritable(tfToBooleanPointer(planAttrValues["accounts_writable"]))
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["attributes"]), toListValue(configAttrValues["attributes"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.MiscAttributeCustomizationable {
			tkh, d := tfObjectToTKHDSMiscAttributeCustomization(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAttributes")
		tkh.SetAttributes(val)
	}
	{
		val, d := tfObjectToTKHDSDirectoryAccountDirectoryPrimer(ctx, recurse, toObjectValue(planAttrValues["directory"]), toObjectValue(configAttrValues["directory"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDirectory")
		tkh.SetDirectory(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["gid"]))+" using SetGid")
	tkh.SetGid(tfToInt64Pointer(planAttrValues["gid"]))
	{
		val, d := tfObjectToTKHDSProvisioningProvisionNumberSequence(ctx, recurse, toObjectValue(planAttrValues["gid_numbering"]), toObjectValue(configAttrValues["gid_numbering"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGidNumbering")
		tkh.SetGidNumbering(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["group_dn"]))+" using SetGroupDN")
	tkh.SetGroupDN(tfToStringPointer(planAttrValues["group_dn"]))
	{
		val, d := parseCastPointer(planAttrValues["hashing_scheme"].(basetypes.StringValue), keyhubmodel.ParseProvisioningLDAPPasswordHashingScheme, func(val any) keyhubmodel.ProvisioningLDAPPasswordHashingScheme {
			return *val.(*keyhubmodel.ProvisioningLDAPPasswordHashingScheme)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetHashingScheme")
		tkh.SetHashingScheme(val)
	}
	{
		val, d := tfObjectToTKHDSProvisioningProvisionNumberSequence(ctx, recurse, toObjectValue(planAttrValues["numbering"]), toObjectValue(configAttrValues["numbering"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetNumbering")
		tkh.SetNumbering(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["object_classes"]))+" using SetObjectClasses")
	tkh.SetObjectClasses(tfToStringPointer(planAttrValues["object_classes"]))
	{
		val, d := parseCastPointer(planAttrValues["sam_account_name_scheme"].(basetypes.StringValue), keyhubmodel.ParseProvisioningADSamAccountNameScheme, func(val any) keyhubmodel.ProvisioningADSamAccountNameScheme {
			return *val.(*keyhubmodel.ProvisioningADSamAccountNameScheme)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSamAccountNameScheme")
		tkh.SetSamAccountNameScheme(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["ssh_public_key_support"].(basetypes.StringValue), keyhubmodel.ParseProvisioningLDAPSshPublicKeySupport, func(val any) keyhubmodel.ProvisioningLDAPSshPublicKeySupport {
			return *val.(*keyhubmodel.ProvisioningLDAPSshPublicKeySupport)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSshPublicKeySupport")
		tkh.SetSshPublicKeySupport(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningProvisionedLDAPDirectoryRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedLDAPDirectoryable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedLDAPDirectoryable
	tkh = keyhubmodel.NewProvisioningProvisionedLDAPDirectory()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["accounts_writable"]))+" using SetAccountsWritable")
	tkh.SetAccountsWritable(tfToBooleanPointer(planAttrValues["accounts_writable"]))
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["attributes"]), toListValue(configAttrValues["attributes"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.MiscAttributeCustomizationable {
			tkh, d := tfObjectToTKHDSROMiscAttributeCustomizationRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAttributes")
		tkh.SetAttributes(val)
	}
	{
		val, d := tfObjectToTKHDSRODirectoryAccountDirectoryPrimerRO(ctx, recurse, toObjectValue(planAttrValues["directory"]), toObjectValue(configAttrValues["directory"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDirectory")
		tkh.SetDirectory(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["gid"]))+" using SetGid")
	tkh.SetGid(tfToInt64Pointer(planAttrValues["gid"]))
	{
		val, d := tfObjectToTKHDSROProvisioningProvisionNumberSequenceRO(ctx, recurse, toObjectValue(planAttrValues["gid_numbering"]), toObjectValue(configAttrValues["gid_numbering"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGidNumbering")
		tkh.SetGidNumbering(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["group_dn"]))+" using SetGroupDN")
	tkh.SetGroupDN(tfToStringPointer(planAttrValues["group_dn"]))
	{
		val, d := parseCastPointer(planAttrValues["hashing_scheme"].(basetypes.StringValue), keyhubmodel.ParseProvisioningLDAPPasswordHashingScheme, func(val any) keyhubmodel.ProvisioningLDAPPasswordHashingScheme {
			return *val.(*keyhubmodel.ProvisioningLDAPPasswordHashingScheme)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetHashingScheme")
		tkh.SetHashingScheme(val)
	}
	{
		val, d := tfObjectToTKHDSROProvisioningProvisionNumberSequenceRO(ctx, recurse, toObjectValue(planAttrValues["numbering"]), toObjectValue(configAttrValues["numbering"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetNumbering")
		tkh.SetNumbering(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["object_classes"]))+" using SetObjectClasses")
	tkh.SetObjectClasses(tfToStringPointer(planAttrValues["object_classes"]))
	{
		val, d := parseCastPointer(planAttrValues["sam_account_name_scheme"].(basetypes.StringValue), keyhubmodel.ParseProvisioningADSamAccountNameScheme, func(val any) keyhubmodel.ProvisioningADSamAccountNameScheme {
			return *val.(*keyhubmodel.ProvisioningADSamAccountNameScheme)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSamAccountNameScheme")
		tkh.SetSamAccountNameScheme(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["ssh_public_key_support"].(basetypes.StringValue), keyhubmodel.ParseProvisioningLDAPSshPublicKeySupport, func(val any) keyhubmodel.ProvisioningLDAPSshPublicKeySupport {
			return *val.(*keyhubmodel.ProvisioningLDAPSshPublicKeySupport)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSshPublicKeySupport")
		tkh.SetSshPublicKeySupport(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSProvisioningProvisionedNamespace(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedNamespaceable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedNamespaceable
	tkh = keyhubmodel.NewProvisioningProvisionedNamespace()
	{
		val, d := tfObjectToTKHDSProvisioningProvisionedSystemPrimer(ctx, recurse, toObjectValue(planAttrValues["base_system"]), toObjectValue(configAttrValues["base_system"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetBaseSystem")
		tkh.SetBaseSystem(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["group_dn"]))+" using SetGroupDN")
	tkh.SetGroupDN(tfToStringPointer(planAttrValues["group_dn"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["service_account_dn"]))+" using SetServiceAccountDN")
	tkh.SetServiceAccountDN(tfToStringPointer(planAttrValues["service_account_dn"]))
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningProvisionedNamespaceRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedNamespaceable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedNamespaceable
	tkh = keyhubmodel.NewProvisioningProvisionedNamespace()
	{
		val, d := tfObjectToTKHDSROProvisioningProvisionedSystemPrimerRO(ctx, recurse, toObjectValue(planAttrValues["base_system"]), toObjectValue(configAttrValues["base_system"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetBaseSystem")
		tkh.SetBaseSystem(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["group_dn"]))+" using SetGroupDN")
	tkh.SetGroupDN(tfToStringPointer(planAttrValues["group_dn"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["service_account_dn"]))+" using SetServiceAccountDN")
	tkh.SetServiceAccountDN(tfToStringPointer(planAttrValues["service_account_dn"]))
	return tkh, diags
}

func tfObjectToTKHDSProvisioningProvisionedSCIM(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedSCIMable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedSCIMable
	tkh = keyhubmodel.NewProvisioningProvisionedSCIM()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["attributes"]), toListValue(configAttrValues["attributes"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.MiscAttributeCustomizationable {
			tkh, d := tfObjectToTKHDSMiscAttributeCustomization(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAttributes")
		tkh.SetAttributes(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["authentication_scheme"].(basetypes.StringValue), keyhubmodel.ParseHttpAuthenticationScheme, func(val any) keyhubmodel.HttpAuthenticationScheme {
			return *val.(*keyhubmodel.HttpAuthenticationScheme)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAuthenticationScheme")
		tkh.SetAuthenticationScheme(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["basic_auth_password"]))+" using SetBasicAuthPassword")
	tkh.SetBasicAuthPassword(tfToStringPointer(planAttrValues["basic_auth_password"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["basic_auth_username"]))+" using SetBasicAuthUsername")
	tkh.SetBasicAuthUsername(tfToStringPointer(planAttrValues["basic_auth_username"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["bearer_token"]))+" using SetBearerToken")
	tkh.SetBearerToken(tfToStringPointer(planAttrValues["bearer_token"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["custom_header_name"]))+" using SetCustomHeaderName")
	tkh.SetCustomHeaderName(tfToStringPointer(planAttrValues["custom_header_name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["custom_header_value"]))+" using SetCustomHeaderValue")
	tkh.SetCustomHeaderValue(tfToStringPointer(planAttrValues["custom_header_value"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["url"]))+" using SetUrl")
	tkh.SetUrl(tfToStringPointer(planAttrValues["url"]))
	{
		val, d := parseCastPointer(planAttrValues["vendor_escaped"].(basetypes.StringValue), keyhubmodel.ParseProvisioningProvisionedSCIMVendor, func(val any) keyhubmodel.ProvisioningProvisionedSCIMVendor {
			return *val.(*keyhubmodel.ProvisioningProvisionedSCIMVendor)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetVendorEscaped")
		tkh.SetVendorEscaped(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningProvisionedSCIMRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedSCIMable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedSCIMable
	tkh = keyhubmodel.NewProvisioningProvisionedSCIM()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["attributes"]), toListValue(configAttrValues["attributes"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.MiscAttributeCustomizationable {
			tkh, d := tfObjectToTKHDSROMiscAttributeCustomizationRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAttributes")
		tkh.SetAttributes(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["authentication_scheme"].(basetypes.StringValue), keyhubmodel.ParseHttpAuthenticationScheme, func(val any) keyhubmodel.HttpAuthenticationScheme {
			return *val.(*keyhubmodel.HttpAuthenticationScheme)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAuthenticationScheme")
		tkh.SetAuthenticationScheme(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["basic_auth_password"]))+" using SetBasicAuthPassword")
	tkh.SetBasicAuthPassword(tfToStringPointer(planAttrValues["basic_auth_password"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["basic_auth_username"]))+" using SetBasicAuthUsername")
	tkh.SetBasicAuthUsername(tfToStringPointer(planAttrValues["basic_auth_username"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["bearer_token"]))+" using SetBearerToken")
	tkh.SetBearerToken(tfToStringPointer(planAttrValues["bearer_token"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["custom_header_name"]))+" using SetCustomHeaderName")
	tkh.SetCustomHeaderName(tfToStringPointer(planAttrValues["custom_header_name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["custom_header_value"]))+" using SetCustomHeaderValue")
	tkh.SetCustomHeaderValue(tfToStringPointer(planAttrValues["custom_header_value"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["url"]))+" using SetUrl")
	tkh.SetUrl(tfToStringPointer(planAttrValues["url"]))
	{
		val, d := parseCastPointer(planAttrValues["vendor_escaped"].(basetypes.StringValue), keyhubmodel.ParseProvisioningProvisionedSCIMVendor, func(val any) keyhubmodel.ProvisioningProvisionedSCIMVendor {
			return *val.(*keyhubmodel.ProvisioningProvisionedSCIMVendor)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetVendorEscaped")
		tkh.SetVendorEscaped(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSProvisioningProvisionedSystem(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedSystemable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedSystemable
	tkh = keyhubmodel.NewProvisioningProvisionedSystem()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["active"]))+" using SetActive")
	tkh.SetActive(tfToBooleanPointer(planAttrValues["active"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["admin_permissions"]))+" using SetAdminPermissions")
	tkh.SetAdminPermissions(tfToBooleanPointer(planAttrValues["admin_permissions"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["can_write_accounts"]))+" using SetCanWriteAccounts")
	tkh.SetCanWriteAccounts(tfToBooleanPointer(planAttrValues["can_write_accounts"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["content_admin_permissions"]))+" using SetContentAdminPermissions")
	tkh.SetContentAdminPermissions(tfToBooleanPointer(planAttrValues["content_admin_permissions"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfObjectToTKHDSOrganizationOrganizationalUnitPrimer(ctx, recurse, toObjectValue(planAttrValues["organizational_unit"]), toObjectValue(configAttrValues["organizational_unit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOrganizationalUnit")
		tkh.SetOrganizationalUnit(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["owner_permissions"]))+" using SetOwnerPermissions")
	tkh.SetOwnerPermissions(tfToBooleanPointer(planAttrValues["owner_permissions"]))
	{
		val, d := parseCastPointer(planAttrValues["type"].(basetypes.StringValue), keyhubmodel.ParseProvisioningProvisionedSystemType, func(val any) keyhubmodel.ProvisioningProvisionedSystemType {
			return *val.(*keyhubmodel.ProvisioningProvisionedSystemType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetProvisioningProvisionedSystemPrimerType")
		tkh.SetProvisioningProvisionedSystemPrimerType(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["account_count"])))+" using SetAccountCount")
	tkh.SetAccountCount(int64PToInt32P(tfToInt64Pointer(planAttrValues["account_count"])))
	{
		val, d := tfObjectToTKHDSProvisioningProvisionedSystem_cleanupPeriod(ctx, false, toObjectValue(planAttrValues["cleanup_period"]), toObjectValue(configAttrValues["cleanup_period"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetCleanupPeriod")
		tkh.SetCleanupPeriod(val)
	}
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["content_administrator"]), toObjectValue(configAttrValues["content_administrator"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetContentAdministrator")
		tkh.SetContentAdministrator(val)
	}
	{
		val, d := parsePointer(planAttrValues["external_uuid"].(basetypes.StringValue), uuid.Parse)
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetExternalUuid")
		tkh.SetExternalUuid(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["group_on_system_provisioning"].(basetypes.StringValue), keyhubmodel.ParseProvisioningGroupOnSystemProvisioning, func(val any) keyhubmodel.ProvisioningGroupOnSystemProvisioning {
			return *val.(*keyhubmodel.ProvisioningGroupOnSystemProvisioning)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroupOnSystemProvisioning")
		tkh.SetGroupOnSystemProvisioning(val)
	}
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["owner"]), toObjectValue(configAttrValues["owner"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwner")
		tkh.SetOwner(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["self_service_existing_groups"]))+" using SetSelfServiceExistingGroups")
	tkh.SetSelfServiceExistingGroups(tfToBooleanPointer(planAttrValues["self_service_existing_groups"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["self_service_new_groups"]))+" using SetSelfServiceNewGroups")
	tkh.SetSelfServiceNewGroups(tfToBooleanPointer(planAttrValues["self_service_new_groups"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["self_service_new_namespaces"]))+" using SetSelfServiceNewNamespaces")
	tkh.SetSelfServiceNewNamespaces(tfToBooleanPointer(planAttrValues["self_service_new_namespaces"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["self_service_service_accounts"]))+" using SetSelfServiceServiceAccounts")
	tkh.SetSelfServiceServiceAccounts(tfToBooleanPointer(planAttrValues["self_service_service_accounts"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["should_destroy_unknown_accounts"]))+" using SetShouldDestroyUnknownAccounts")
	tkh.SetShouldDestroyUnknownAccounts(tfToBooleanPointer(planAttrValues["should_destroy_unknown_accounts"]))
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["technical_administrator"]), toObjectValue(configAttrValues["technical_administrator"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTechnicalAdministrator")
		tkh.SetTechnicalAdministrator(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["username_prefix"]))+" using SetUsernamePrefix")
	tkh.SetUsernamePrefix(tfToStringPointer(planAttrValues["username_prefix"]))
	if !planAttrValues["abstract_provisioned_ldap"].IsNull() {
		val, d := tfObjectToTKHDSProvisioningAbstractProvisionedLDAP(ctx, false, planAttrValues["abstract_provisioned_ldap"].(basetypes.ObjectValue), configAttrValues["abstract_provisioned_ldap"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ProvisioningAbstractProvisionedLDAP)).ProvisioningProvisionedSystem = *tkh.(*keyhubmodel.ProvisioningProvisionedSystem)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["provisioned_a_d"].IsNull() {
		val, d := tfObjectToTKHDSProvisioningProvisionedAD(ctx, false, planAttrValues["provisioned_a_d"].(basetypes.ObjectValue), configAttrValues["provisioned_a_d"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ProvisioningProvisionedAD)).ProvisioningProvisionedSystem = *tkh.(*keyhubmodel.ProvisioningProvisionedSystem)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["provisioned_azure_oidc_directory"].IsNull() {
		val, d := tfObjectToTKHDSProvisioningProvisionedAzureOIDCDirectory(ctx, false, planAttrValues["provisioned_azure_oidc_directory"].(basetypes.ObjectValue), configAttrValues["provisioned_azure_oidc_directory"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ProvisioningProvisionedAzureOIDCDirectory)).ProvisioningProvisionedSystem = *tkh.(*keyhubmodel.ProvisioningProvisionedSystem)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["provisioned_azure_sync_ldap_directory"].IsNull() {
		val, d := tfObjectToTKHDSProvisioningProvisionedAzureSyncLDAPDirectory(ctx, false, planAttrValues["provisioned_azure_sync_ldap_directory"].(basetypes.ObjectValue), configAttrValues["provisioned_azure_sync_ldap_directory"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ProvisioningProvisionedAzureSyncLDAPDirectory)).ProvisioningProvisionedSystem = *tkh.(*keyhubmodel.ProvisioningProvisionedSystem)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["provisioned_azure_tenant"].IsNull() {
		val, d := tfObjectToTKHDSProvisioningProvisionedAzureTenant(ctx, false, planAttrValues["provisioned_azure_tenant"].(basetypes.ObjectValue), configAttrValues["provisioned_azure_tenant"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ProvisioningProvisionedAzureTenant)).ProvisioningProvisionedSystem = *tkh.(*keyhubmodel.ProvisioningProvisionedSystem)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["provisioned_internal_ldap"].IsNull() {
		val, d := tfObjectToTKHDSProvisioningProvisionedInternalLDAP(ctx, false, planAttrValues["provisioned_internal_ldap"].(basetypes.ObjectValue), configAttrValues["provisioned_internal_ldap"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ProvisioningProvisionedInternalLDAP)).ProvisioningProvisionedSystem = *tkh.(*keyhubmodel.ProvisioningProvisionedSystem)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["provisioned_ldap"].IsNull() {
		val, d := tfObjectToTKHDSProvisioningProvisionedLDAP(ctx, false, planAttrValues["provisioned_ldap"].(basetypes.ObjectValue), configAttrValues["provisioned_ldap"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ProvisioningProvisionedLDAP)).ProvisioningProvisionedSystem = *tkh.(*keyhubmodel.ProvisioningProvisionedSystem)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["provisioned_ldap_directory"].IsNull() {
		val, d := tfObjectToTKHDSProvisioningProvisionedLDAPDirectory(ctx, false, planAttrValues["provisioned_ldap_directory"].(basetypes.ObjectValue), configAttrValues["provisioned_ldap_directory"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ProvisioningProvisionedLDAPDirectory)).ProvisioningProvisionedSystem = *tkh.(*keyhubmodel.ProvisioningProvisionedSystem)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["provisioned_namespace"].IsNull() {
		val, d := tfObjectToTKHDSProvisioningProvisionedNamespace(ctx, false, planAttrValues["provisioned_namespace"].(basetypes.ObjectValue), configAttrValues["provisioned_namespace"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ProvisioningProvisionedNamespace)).ProvisioningProvisionedSystem = *tkh.(*keyhubmodel.ProvisioningProvisionedSystem)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["provisioned_scim"].IsNull() {
		val, d := tfObjectToTKHDSProvisioningProvisionedSCIM(ctx, false, planAttrValues["provisioned_scim"].(basetypes.ObjectValue), configAttrValues["provisioned_scim"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ProvisioningProvisionedSCIM)).ProvisioningProvisionedSystem = *tkh.(*keyhubmodel.ProvisioningProvisionedSystem)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSProvisioningProvisionedSystem_additionalObjects(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningProvisionedSystemRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedSystemable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedSystemable
	tkh = keyhubmodel.NewProvisioningProvisionedSystem()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["active"]))+" using SetActive")
	tkh.SetActive(tfToBooleanPointer(planAttrValues["active"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["admin_permissions"]))+" using SetAdminPermissions")
	tkh.SetAdminPermissions(tfToBooleanPointer(planAttrValues["admin_permissions"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["can_write_accounts"]))+" using SetCanWriteAccounts")
	tkh.SetCanWriteAccounts(tfToBooleanPointer(planAttrValues["can_write_accounts"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["content_admin_permissions"]))+" using SetContentAdminPermissions")
	tkh.SetContentAdminPermissions(tfToBooleanPointer(planAttrValues["content_admin_permissions"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfObjectToTKHDSROOrganizationOrganizationalUnitPrimerRO(ctx, recurse, toObjectValue(planAttrValues["organizational_unit"]), toObjectValue(configAttrValues["organizational_unit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOrganizationalUnit")
		tkh.SetOrganizationalUnit(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["owner_permissions"]))+" using SetOwnerPermissions")
	tkh.SetOwnerPermissions(tfToBooleanPointer(planAttrValues["owner_permissions"]))
	{
		val, d := parseCastPointer(planAttrValues["type"].(basetypes.StringValue), keyhubmodel.ParseProvisioningProvisionedSystemType, func(val any) keyhubmodel.ProvisioningProvisionedSystemType {
			return *val.(*keyhubmodel.ProvisioningProvisionedSystemType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetProvisioningProvisionedSystemPrimerType")
		tkh.SetProvisioningProvisionedSystemPrimerType(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["account_count"])))+" using SetAccountCount")
	tkh.SetAccountCount(int64PToInt32P(tfToInt64Pointer(planAttrValues["account_count"])))
	{
		val, d := tfObjectToTKHDSROProvisioningProvisionedSystem_cleanupPeriodRO(ctx, false, toObjectValue(planAttrValues["cleanup_period"]), toObjectValue(configAttrValues["cleanup_period"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetCleanupPeriod")
		tkh.SetCleanupPeriod(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["content_administrator"]), toObjectValue(configAttrValues["content_administrator"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetContentAdministrator")
		tkh.SetContentAdministrator(val)
	}
	{
		val, d := parsePointer(planAttrValues["external_uuid"].(basetypes.StringValue), uuid.Parse)
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetExternalUuid")
		tkh.SetExternalUuid(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["group_on_system_provisioning"].(basetypes.StringValue), keyhubmodel.ParseProvisioningGroupOnSystemProvisioning, func(val any) keyhubmodel.ProvisioningGroupOnSystemProvisioning {
			return *val.(*keyhubmodel.ProvisioningGroupOnSystemProvisioning)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroupOnSystemProvisioning")
		tkh.SetGroupOnSystemProvisioning(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["owner"]), toObjectValue(configAttrValues["owner"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOwner")
		tkh.SetOwner(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["self_service_existing_groups"]))+" using SetSelfServiceExistingGroups")
	tkh.SetSelfServiceExistingGroups(tfToBooleanPointer(planAttrValues["self_service_existing_groups"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["self_service_new_groups"]))+" using SetSelfServiceNewGroups")
	tkh.SetSelfServiceNewGroups(tfToBooleanPointer(planAttrValues["self_service_new_groups"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["self_service_new_namespaces"]))+" using SetSelfServiceNewNamespaces")
	tkh.SetSelfServiceNewNamespaces(tfToBooleanPointer(planAttrValues["self_service_new_namespaces"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["self_service_service_accounts"]))+" using SetSelfServiceServiceAccounts")
	tkh.SetSelfServiceServiceAccounts(tfToBooleanPointer(planAttrValues["self_service_service_accounts"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["should_destroy_unknown_accounts"]))+" using SetShouldDestroyUnknownAccounts")
	tkh.SetShouldDestroyUnknownAccounts(tfToBooleanPointer(planAttrValues["should_destroy_unknown_accounts"]))
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["technical_administrator"]), toObjectValue(configAttrValues["technical_administrator"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTechnicalAdministrator")
		tkh.SetTechnicalAdministrator(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["username_prefix"]))+" using SetUsernamePrefix")
	tkh.SetUsernamePrefix(tfToStringPointer(planAttrValues["username_prefix"]))
	if !planAttrValues["abstract_provisioned_ldap"].IsNull() {
		val, d := tfObjectToTKHDSROProvisioningAbstractProvisionedLDAPRO(ctx, false, planAttrValues["abstract_provisioned_ldap"].(basetypes.ObjectValue), configAttrValues["abstract_provisioned_ldap"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ProvisioningAbstractProvisionedLDAP)).ProvisioningProvisionedSystem = *tkh.(*keyhubmodel.ProvisioningProvisionedSystem)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["provisioned_a_d"].IsNull() {
		val, d := tfObjectToTKHDSROProvisioningProvisionedADRO(ctx, false, planAttrValues["provisioned_a_d"].(basetypes.ObjectValue), configAttrValues["provisioned_a_d"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ProvisioningProvisionedAD)).ProvisioningProvisionedSystem = *tkh.(*keyhubmodel.ProvisioningProvisionedSystem)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["provisioned_azure_oidc_directory"].IsNull() {
		val, d := tfObjectToTKHDSROProvisioningProvisionedAzureOIDCDirectoryRO(ctx, false, planAttrValues["provisioned_azure_oidc_directory"].(basetypes.ObjectValue), configAttrValues["provisioned_azure_oidc_directory"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ProvisioningProvisionedAzureOIDCDirectory)).ProvisioningProvisionedSystem = *tkh.(*keyhubmodel.ProvisioningProvisionedSystem)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["provisioned_azure_sync_ldap_directory"].IsNull() {
		val, d := tfObjectToTKHDSROProvisioningProvisionedAzureSyncLDAPDirectoryRO(ctx, false, planAttrValues["provisioned_azure_sync_ldap_directory"].(basetypes.ObjectValue), configAttrValues["provisioned_azure_sync_ldap_directory"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ProvisioningProvisionedAzureSyncLDAPDirectory)).ProvisioningProvisionedSystem = *tkh.(*keyhubmodel.ProvisioningProvisionedSystem)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["provisioned_azure_tenant"].IsNull() {
		val, d := tfObjectToTKHDSROProvisioningProvisionedAzureTenantRO(ctx, false, planAttrValues["provisioned_azure_tenant"].(basetypes.ObjectValue), configAttrValues["provisioned_azure_tenant"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ProvisioningProvisionedAzureTenant)).ProvisioningProvisionedSystem = *tkh.(*keyhubmodel.ProvisioningProvisionedSystem)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["provisioned_internal_ldap"].IsNull() {
		val, d := tfObjectToTKHDSROProvisioningProvisionedInternalLDAPRO(ctx, false, planAttrValues["provisioned_internal_ldap"].(basetypes.ObjectValue), configAttrValues["provisioned_internal_ldap"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ProvisioningProvisionedInternalLDAP)).ProvisioningProvisionedSystem = *tkh.(*keyhubmodel.ProvisioningProvisionedSystem)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["provisioned_ldap"].IsNull() {
		val, d := tfObjectToTKHDSROProvisioningProvisionedLDAPRO(ctx, false, planAttrValues["provisioned_ldap"].(basetypes.ObjectValue), configAttrValues["provisioned_ldap"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ProvisioningProvisionedLDAP)).ProvisioningProvisionedSystem = *tkh.(*keyhubmodel.ProvisioningProvisionedSystem)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["provisioned_ldap_directory"].IsNull() {
		val, d := tfObjectToTKHDSROProvisioningProvisionedLDAPDirectoryRO(ctx, false, planAttrValues["provisioned_ldap_directory"].(basetypes.ObjectValue), configAttrValues["provisioned_ldap_directory"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ProvisioningProvisionedLDAPDirectory)).ProvisioningProvisionedSystem = *tkh.(*keyhubmodel.ProvisioningProvisionedSystem)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["provisioned_namespace"].IsNull() {
		val, d := tfObjectToTKHDSROProvisioningProvisionedNamespaceRO(ctx, false, planAttrValues["provisioned_namespace"].(basetypes.ObjectValue), configAttrValues["provisioned_namespace"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ProvisioningProvisionedNamespace)).ProvisioningProvisionedSystem = *tkh.(*keyhubmodel.ProvisioningProvisionedSystem)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if !planAttrValues["provisioned_scim"].IsNull() {
		val, d := tfObjectToTKHDSROProvisioningProvisionedSCIMRO(ctx, false, planAttrValues["provisioned_scim"].(basetypes.ObjectValue), configAttrValues["provisioned_scim"].(basetypes.ObjectValue))
		diags.Append(d...)
		dtype := val.GetTypeEscaped()
		(*val.(*keyhubmodel.ProvisioningProvisionedSCIM)).ProvisioningProvisionedSystem = *tkh.(*keyhubmodel.ProvisioningProvisionedSystem)
		val.SetTypeEscaped(dtype)
		tkh = val
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSROProvisioningProvisionedSystem_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningProvisionedSystemLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedSystemLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedSystemLinkableWrapperable
	tkh = keyhubmodel.NewProvisioningProvisionedSystemLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.ProvisioningProvisionedSystemable {
			tkh, d := tfObjectToTKHDSROProvisioningProvisionedSystemRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSProvisioningProvisionedSystemPrimer(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedSystemPrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedSystemPrimerable
	tkh = keyhubmodel.NewProvisioningProvisionedSystemPrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["active"]))+" using SetActive")
	tkh.SetActive(tfToBooleanPointer(planAttrValues["active"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["admin_permissions"]))+" using SetAdminPermissions")
	tkh.SetAdminPermissions(tfToBooleanPointer(planAttrValues["admin_permissions"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["can_write_accounts"]))+" using SetCanWriteAccounts")
	tkh.SetCanWriteAccounts(tfToBooleanPointer(planAttrValues["can_write_accounts"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["content_admin_permissions"]))+" using SetContentAdminPermissions")
	tkh.SetContentAdminPermissions(tfToBooleanPointer(planAttrValues["content_admin_permissions"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfObjectToTKHDSOrganizationOrganizationalUnitPrimer(ctx, recurse, toObjectValue(planAttrValues["organizational_unit"]), toObjectValue(configAttrValues["organizational_unit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOrganizationalUnit")
		tkh.SetOrganizationalUnit(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["owner_permissions"]))+" using SetOwnerPermissions")
	tkh.SetOwnerPermissions(tfToBooleanPointer(planAttrValues["owner_permissions"]))
	{
		val, d := parseCastPointer(planAttrValues["type"].(basetypes.StringValue), keyhubmodel.ParseProvisioningProvisionedSystemType, func(val any) keyhubmodel.ProvisioningProvisionedSystemType {
			return *val.(*keyhubmodel.ProvisioningProvisionedSystemType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetProvisioningProvisionedSystemPrimerType")
		tkh.SetProvisioningProvisionedSystemPrimerType(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningProvisionedSystemPrimerRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedSystemPrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedSystemPrimerable
	tkh = keyhubmodel.NewProvisioningProvisionedSystemPrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["active"]))+" using SetActive")
	tkh.SetActive(tfToBooleanPointer(planAttrValues["active"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["admin_permissions"]))+" using SetAdminPermissions")
	tkh.SetAdminPermissions(tfToBooleanPointer(planAttrValues["admin_permissions"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["can_write_accounts"]))+" using SetCanWriteAccounts")
	tkh.SetCanWriteAccounts(tfToBooleanPointer(planAttrValues["can_write_accounts"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["content_admin_permissions"]))+" using SetContentAdminPermissions")
	tkh.SetContentAdminPermissions(tfToBooleanPointer(planAttrValues["content_admin_permissions"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfObjectToTKHDSROOrganizationOrganizationalUnitPrimerRO(ctx, recurse, toObjectValue(planAttrValues["organizational_unit"]), toObjectValue(configAttrValues["organizational_unit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetOrganizationalUnit")
		tkh.SetOrganizationalUnit(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["owner_permissions"]))+" using SetOwnerPermissions")
	tkh.SetOwnerPermissions(tfToBooleanPointer(planAttrValues["owner_permissions"]))
	{
		val, d := parseCastPointer(planAttrValues["type"].(basetypes.StringValue), keyhubmodel.ParseProvisioningProvisionedSystemType, func(val any) keyhubmodel.ProvisioningProvisionedSystemType {
			return *val.(*keyhubmodel.ProvisioningProvisionedSystemType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetProvisioningProvisionedSystemPrimerType")
		tkh.SetProvisioningProvisionedSystemPrimerType(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningProvisionedSystemPrimerLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedSystemPrimerLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedSystemPrimerLinkableWrapperable
	tkh = keyhubmodel.NewProvisioningProvisionedSystemPrimerLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.ProvisioningProvisionedSystemPrimerable {
			tkh, d := tfObjectToTKHDSROProvisioningProvisionedSystemPrimerRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSProvisioningProvisionedSystem_additionalObjects(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedSystem_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedSystem_additionalObjectsable
	tkh = keyhubmodel.NewProvisioningProvisionedSystem_additionalObjects()
	{
		val, d := tfObjectToTKHDSROProvisioningProvisionedAccountRO(ctx, recurse, toObjectValue(planAttrValues["account"]), toObjectValue(configAttrValues["account"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAccount")
		tkh.SetAccount(val)
	}
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	{
		val, d := tfObjectToTKHDSROClientOAuth2ClientPermissionWithClientLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["issued_permissions"]), toItemsList(ctx, configAttrValues["issued_permissions"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetIssuedPermissions")
		tkh.SetIssuedPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["login_name"]))+" using SetLoginName")
	tkh.SetLoginName(tfToStringPointer(planAttrValues["login_name"]))
	{
		val, d := tfObjectToTKHDSROProvisioningProvisioningManagementPermissionsRO(ctx, recurse, toObjectValue(planAttrValues["management_permissions"]), toObjectValue(configAttrValues["management_permissions"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetManagementPermissions")
		tkh.SetManagementPermissions(val)
	}
	{
		val, d := tfObjectToTKHDSROMarkItemMarkersRO(ctx, recurse, toObjectValue(planAttrValues["markers"]), toObjectValue(configAttrValues["markers"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetMarkers")
		tkh.SetMarkers(val)
	}
	{
		val, d := tfObjectToTKHDSROProvisioningCircuitBreakerStatisticsRO(ctx, recurse, toObjectValue(planAttrValues["statistics"]), toObjectValue(configAttrValues["statistics"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetStatistics")
		tkh.SetStatistics(val)
	}
	{
		val, d := tfObjectToTKHDSROProvisioningGroupOnSystemTypesRO(ctx, recurse, toObjectValue(planAttrValues["supported_group_types"]), toObjectValue(configAttrValues["supported_group_types"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSupportedGroupTypes")
		tkh.SetSupportedGroupTypes(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningProvisionedSystem_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedSystem_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedSystem_additionalObjectsable
	tkh = keyhubmodel.NewProvisioningProvisionedSystem_additionalObjects()
	{
		val, d := tfObjectToTKHDSROProvisioningProvisionedAccountRO(ctx, recurse, toObjectValue(planAttrValues["account"]), toObjectValue(configAttrValues["account"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAccount")
		tkh.SetAccount(val)
	}
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	{
		val, d := tfObjectToTKHDSROClientOAuth2ClientPermissionWithClientLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["issued_permissions"]), toItemsList(ctx, configAttrValues["issued_permissions"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetIssuedPermissions")
		tkh.SetIssuedPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["login_name"]))+" using SetLoginName")
	tkh.SetLoginName(tfToStringPointer(planAttrValues["login_name"]))
	{
		val, d := tfObjectToTKHDSROProvisioningProvisioningManagementPermissionsRO(ctx, recurse, toObjectValue(planAttrValues["management_permissions"]), toObjectValue(configAttrValues["management_permissions"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetManagementPermissions")
		tkh.SetManagementPermissions(val)
	}
	{
		val, d := tfObjectToTKHDSROMarkItemMarkersRO(ctx, recurse, toObjectValue(planAttrValues["markers"]), toObjectValue(configAttrValues["markers"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetMarkers")
		tkh.SetMarkers(val)
	}
	{
		val, d := tfObjectToTKHDSROProvisioningCircuitBreakerStatisticsRO(ctx, recurse, toObjectValue(planAttrValues["statistics"]), toObjectValue(configAttrValues["statistics"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetStatistics")
		tkh.SetStatistics(val)
	}
	{
		val, d := tfObjectToTKHDSROProvisioningGroupOnSystemTypesRO(ctx, recurse, toObjectValue(planAttrValues["supported_group_types"]), toObjectValue(configAttrValues["supported_group_types"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSupportedGroupTypes")
		tkh.SetSupportedGroupTypes(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSProvisioningProvisionedSystem_cleanupPeriod(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedSystem_cleanupPeriodable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedSystem_cleanupPeriodable
	tkh = keyhubmodel.NewProvisioningProvisionedSystem_cleanupPeriod()
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["days"])))+" using SetDays")
	tkh.SetDays(int64PToInt32P(tfToInt64Pointer(planAttrValues["days"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["months"])))+" using SetMonths")
	tkh.SetMonths(int64PToInt32P(tfToInt64Pointer(planAttrValues["months"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["years"])))+" using SetYears")
	tkh.SetYears(int64PToInt32P(tfToInt64Pointer(planAttrValues["years"])))
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningProvisionedSystem_cleanupPeriodRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisionedSystem_cleanupPeriodable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisionedSystem_cleanupPeriodable
	tkh = keyhubmodel.NewProvisioningProvisionedSystem_cleanupPeriod()
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["days"])))+" using SetDays")
	tkh.SetDays(int64PToInt32P(tfToInt64Pointer(planAttrValues["days"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["months"])))+" using SetMonths")
	tkh.SetMonths(int64PToInt32P(tfToInt64Pointer(planAttrValues["months"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["years"])))+" using SetYears")
	tkh.SetYears(int64PToInt32P(tfToInt64Pointer(planAttrValues["years"])))
	return tkh, diags
}

func tfObjectToTKHDSROProvisioningProvisioningManagementPermissionsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ProvisioningProvisioningManagementPermissionsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ProvisioningProvisioningManagementPermissionsable
	tkh = keyhubmodel.NewProvisioningProvisioningManagementPermissions()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["create_new_groups_allowed"]))+" using SetCreateNewGroupsAllowed")
	tkh.SetCreateNewGroupsAllowed(tfToBooleanPointer(planAttrValues["create_new_groups_allowed"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["create_service_accounts_allowed"]))+" using SetCreateServiceAccountsAllowed")
	tkh.SetCreateServiceAccountsAllowed(tfToBooleanPointer(planAttrValues["create_service_accounts_allowed"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["reuse_existing_groups_allowed"]))+" using SetReuseExistingGroupsAllowed")
	tkh.SetReuseExistingGroupsAllowed(tfToBooleanPointer(planAttrValues["reuse_existing_groups_allowed"]))
	return tkh, diags
}

func tfObjectToTKHDSServiceaccountServiceAccount(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ServiceaccountServiceAccountable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ServiceaccountServiceAccountable
	tkh = keyhubmodel.NewServiceaccountServiceAccount()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["active"]))+" using SetActive")
	tkh.SetActive(tfToBooleanPointer(planAttrValues["active"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfObjectToTKHDSProvisioningProvisionedSystemPrimer(ctx, recurse, toObjectValue(planAttrValues["system"]), toObjectValue(configAttrValues["system"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSystem")
		tkh.SetSystem(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["username"]))+" using SetUsername")
	tkh.SetUsername(tfToStringPointer(planAttrValues["username"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["description"]))+" using SetDescription")
	tkh.SetDescription(tfToStringPointer(planAttrValues["description"]))
	{
		val, d := tfObjectToTKHDSROVaultVaultRecordPrimerRO(ctx, false, toObjectValue(planAttrValues["password"]), toObjectValue(configAttrValues["password"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPassword")
		tkh.SetPassword(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["password_rotation"].(basetypes.StringValue), keyhubmodel.ParseServiceaccountPasswordRotationScheme, func(val any) keyhubmodel.ServiceaccountPasswordRotationScheme {
			return *val.(*keyhubmodel.ServiceaccountPasswordRotationScheme)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPasswordRotation")
		tkh.SetPasswordRotation(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["ssh_public_key"]))+" using SetSshPublicKey")
	tkh.SetSshPublicKey(tfToStringPointer(planAttrValues["ssh_public_key"]))
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["technical_administrator"]), toObjectValue(configAttrValues["technical_administrator"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTechnicalAdministrator")
		tkh.SetTechnicalAdministrator(val)
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSServiceaccountServiceAccount_additionalObjects(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROServiceaccountServiceAccountRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ServiceaccountServiceAccountable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ServiceaccountServiceAccountable
	tkh = keyhubmodel.NewServiceaccountServiceAccount()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["active"]))+" using SetActive")
	tkh.SetActive(tfToBooleanPointer(planAttrValues["active"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfObjectToTKHDSROProvisioningProvisionedSystemPrimerRO(ctx, recurse, toObjectValue(planAttrValues["system"]), toObjectValue(configAttrValues["system"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSystem")
		tkh.SetSystem(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["username"]))+" using SetUsername")
	tkh.SetUsername(tfToStringPointer(planAttrValues["username"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["description"]))+" using SetDescription")
	tkh.SetDescription(tfToStringPointer(planAttrValues["description"]))
	{
		val, d := tfObjectToTKHDSROVaultVaultRecordPrimerRO(ctx, false, toObjectValue(planAttrValues["password"]), toObjectValue(configAttrValues["password"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPassword")
		tkh.SetPassword(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["password_rotation"].(basetypes.StringValue), keyhubmodel.ParseServiceaccountPasswordRotationScheme, func(val any) keyhubmodel.ServiceaccountPasswordRotationScheme {
			return *val.(*keyhubmodel.ServiceaccountPasswordRotationScheme)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPasswordRotation")
		tkh.SetPasswordRotation(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["ssh_public_key"]))+" using SetSshPublicKey")
	tkh.SetSshPublicKey(tfToStringPointer(planAttrValues["ssh_public_key"]))
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["technical_administrator"]), toObjectValue(configAttrValues["technical_administrator"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTechnicalAdministrator")
		tkh.SetTechnicalAdministrator(val)
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSROServiceaccountServiceAccount_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROServiceaccountServiceAccountGroupRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ServiceaccountServiceAccountGroupable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ServiceaccountServiceAccountGroupable
	tkh = keyhubmodel.NewServiceaccountServiceAccountGroup()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["display_name"]))+" using SetDisplayName")
	tkh.SetDisplayName(tfToStringPointer(planAttrValues["display_name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name_in_system"]))+" using SetNameInSystem")
	tkh.SetNameInSystem(tfToStringPointer(planAttrValues["name_in_system"]))
	{
		val, d := parseCastPointer(planAttrValues["type"].(basetypes.StringValue), keyhubmodel.ParseProvisioningGroupOnSystemType, func(val any) keyhubmodel.ProvisioningGroupOnSystemType {
			return *val.(*keyhubmodel.ProvisioningGroupOnSystemType)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetProvisioningGroupOnSystemPrimerType")
		tkh.SetProvisioningGroupOnSystemPrimerType(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["short_name_in_system"]))+" using SetShortNameInSystem")
	tkh.SetShortNameInSystem(tfToStringPointer(planAttrValues["short_name_in_system"]))
	if recurse {
		{
			val, d := tfObjectToTKHDSROServiceaccountServiceAccountGroup_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROServiceaccountServiceAccountGroupLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ServiceaccountServiceAccountGroupLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ServiceaccountServiceAccountGroupLinkableWrapperable
	tkh = keyhubmodel.NewServiceaccountServiceAccountGroupLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.ServiceaccountServiceAccountGroupable {
			tkh, d := tfObjectToTKHDSROServiceaccountServiceAccountGroupRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROServiceaccountServiceAccountGroup_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ServiceaccountServiceAccountGroup_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ServiceaccountServiceAccountGroup_additionalObjectsable
	tkh = keyhubmodel.NewServiceaccountServiceAccountGroup_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROServiceaccountServiceAccountLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ServiceaccountServiceAccountLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ServiceaccountServiceAccountLinkableWrapperable
	tkh = keyhubmodel.NewServiceaccountServiceAccountLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.ServiceaccountServiceAccountable {
			tkh, d := tfObjectToTKHDSROServiceaccountServiceAccountRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSServiceaccountServiceAccountPrimer(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ServiceaccountServiceAccountPrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ServiceaccountServiceAccountPrimerable
	tkh = keyhubmodel.NewServiceaccountServiceAccountPrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["active"]))+" using SetActive")
	tkh.SetActive(tfToBooleanPointer(planAttrValues["active"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfObjectToTKHDSProvisioningProvisionedSystemPrimer(ctx, recurse, toObjectValue(planAttrValues["system"]), toObjectValue(configAttrValues["system"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSystem")
		tkh.SetSystem(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["username"]))+" using SetUsername")
	tkh.SetUsername(tfToStringPointer(planAttrValues["username"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	return tkh, diags
}

func tfObjectToTKHDSROServiceaccountServiceAccountPrimerRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ServiceaccountServiceAccountPrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ServiceaccountServiceAccountPrimerable
	tkh = keyhubmodel.NewServiceaccountServiceAccountPrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["active"]))+" using SetActive")
	tkh.SetActive(tfToBooleanPointer(planAttrValues["active"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfObjectToTKHDSROProvisioningProvisionedSystemPrimerRO(ctx, recurse, toObjectValue(planAttrValues["system"]), toObjectValue(configAttrValues["system"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSystem")
		tkh.SetSystem(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["username"]))+" using SetUsername")
	tkh.SetUsername(tfToStringPointer(planAttrValues["username"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	return tkh, diags
}

func tfObjectToTKHDSROServiceaccountServiceAccountPrimerLinkableWrapperWithCountRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ServiceaccountServiceAccountPrimerLinkableWrapperWithCountable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ServiceaccountServiceAccountPrimerLinkableWrapperWithCountable
	tkh = keyhubmodel.NewServiceaccountServiceAccountPrimerLinkableWrapperWithCount()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToInt64Pointer(planAttrValues["count"]))+" using SetCount")
	tkh.SetCount(tfToInt64Pointer(planAttrValues["count"]))
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.ServiceaccountServiceAccountPrimerable {
			tkh, d := tfObjectToTKHDSROServiceaccountServiceAccountPrimerRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROServiceaccountServiceAccountSupportedFeaturesRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ServiceaccountServiceAccountSupportedFeaturesable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ServiceaccountServiceAccountSupportedFeaturesable
	tkh = keyhubmodel.NewServiceaccountServiceAccountSupportedFeatures()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["ssh_public_key"]))+" using SetSshPublicKey")
	tkh.SetSshPublicKey(tfToBooleanPointer(planAttrValues["ssh_public_key"]))
	return tkh, diags
}

func tfObjectToTKHDSServiceaccountServiceAccount_additionalObjects(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ServiceaccountServiceAccount_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ServiceaccountServiceAccount_additionalObjectsable
	tkh = keyhubmodel.NewServiceaccountServiceAccount_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	{
		val, d := tfObjectToTKHDSROServiceaccountServiceAccountGroupLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["groups"]), toItemsList(ctx, configAttrValues["groups"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroups")
		tkh.SetGroups(val)
	}
	{
		val, d := tfObjectToTKHDSGeneratedSecret(ctx, recurse, toObjectValue(planAttrValues["secret"]), toObjectValue(configAttrValues["secret"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSecret")
		tkh.SetSecret(val)
	}
	{
		val, d := tfObjectToTKHDSROServiceaccountServiceAccountSupportedFeaturesRO(ctx, recurse, toObjectValue(planAttrValues["supported_features"]), toObjectValue(configAttrValues["supported_features"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSupportedFeatures")
		tkh.SetSupportedFeatures(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROServiceaccountServiceAccount_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.ServiceaccountServiceAccount_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.ServiceaccountServiceAccount_additionalObjectsable
	tkh = keyhubmodel.NewServiceaccountServiceAccount_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	{
		val, d := tfObjectToTKHDSROServiceaccountServiceAccountGroupLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["groups"]), toItemsList(ctx, configAttrValues["groups"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroups")
		tkh.SetGroups(val)
	}
	{
		val, d := tfObjectToTKHDSROGeneratedSecretRO(ctx, recurse, toObjectValue(planAttrValues["secret"]), toObjectValue(configAttrValues["secret"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSecret")
		tkh.SetSecret(val)
	}
	{
		val, d := tfObjectToTKHDSROServiceaccountServiceAccountSupportedFeaturesRO(ctx, recurse, toObjectValue(planAttrValues["supported_features"]), toObjectValue(configAttrValues["supported_features"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSupportedFeatures")
		tkh.SetSupportedFeatures(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROVaultPasswordMetadataRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.VaultPasswordMetadataable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.VaultPasswordMetadataable
	tkh = keyhubmodel.NewVaultPasswordMetadata()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["dictionary"]))+" using SetDictionary")
	tkh.SetDictionary(tfToBooleanPointer(planAttrValues["dictionary"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["duplicate"]))+" using SetDuplicate")
	tkh.SetDuplicate(tfToBooleanPointer(planAttrValues["duplicate"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["hash"]))+" using SetHash")
	tkh.SetHash(tfToStringPointer(planAttrValues["hash"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["length"])))+" using SetLength")
	tkh.SetLength(int64PToInt32P(tfToInt64Pointer(planAttrValues["length"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["lower_count"])))+" using SetLowerCount")
	tkh.SetLowerCount(int64PToInt32P(tfToInt64Pointer(planAttrValues["lower_count"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["number_count"])))+" using SetNumberCount")
	tkh.SetNumberCount(int64PToInt32P(tfToInt64Pointer(planAttrValues["number_count"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["special_count"])))+" using SetSpecialCount")
	tkh.SetSpecialCount(int64PToInt32P(tfToInt64Pointer(planAttrValues["special_count"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["strength"])))+" using SetStrength")
	tkh.SetStrength(int64PToInt32P(tfToInt64Pointer(planAttrValues["strength"])))
	tflog.Debug(ctx, "Setting "+litter.Sdump(int64PToInt32P(tfToInt64Pointer(planAttrValues["upper_count"])))+" using SetUpperCount")
	tkh.SetUpperCount(int64PToInt32P(tfToInt64Pointer(planAttrValues["upper_count"])))
	return tkh, diags
}

func tfObjectToTKHDSROVaultVaultRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.VaultVaultable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.VaultVaultable
	tkh = keyhubmodel.NewVaultVault()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["access_available"]))+" using SetAccessAvailable")
	tkh.SetAccessAvailable(tfToBooleanPointer(planAttrValues["access_available"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["records"]), toListValue(configAttrValues["records"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.VaultVaultRecordable {
			tkh, d := tfObjectToTKHDSROVaultVaultRecordRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetRecords")
		tkh.SetRecords(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROVaultVaultActivationStatusRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.VaultVaultActivationStatusable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.VaultVaultActivationStatusable
	tkh = keyhubmodel.NewVaultVaultActivationStatus()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["activated"]))+" using SetActivated")
	tkh.SetActivated(tfToBooleanPointer(planAttrValues["activated"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["activation_required"]))+" using SetActivationRequired")
	tkh.SetActivationRequired(tfToBooleanPointer(planAttrValues["activation_required"]))
	return tkh, diags
}

func tfObjectToTKHDSVaultVaultRecord(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.VaultVaultRecordable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.VaultVaultRecordable
	tkh = keyhubmodel.NewVaultVaultRecord()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["color"].(basetypes.StringValue), keyhubmodel.ParseVaultVaultRecordColor, func(val any) keyhubmodel.VaultVaultRecordColor { return *val.(*keyhubmodel.VaultVaultRecordColor) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetColor")
		tkh.SetColor(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfToTimePointer(planAttrValues["share_end_time"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetShareEndTime")
		tkh.SetShareEndTime(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["derived"]))+" using SetDerived")
	tkh.SetDerived(tfToBooleanPointer(planAttrValues["derived"]))
	{
		val, d := parsePointer2(planAttrValues["end_date"].(basetypes.StringValue), serialization.ParseDateOnly)
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetEndDate")
		tkh.SetEndDate(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["filename"]))+" using SetFilename")
	tkh.SetFilename(tfToStringPointer(planAttrValues["filename"]))
	{
		val, d := tfToSliceSet(toSetValue(planAttrValues["types"]), toSetValue(configAttrValues["types"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.VaultVaultSecretType {
			tkh, d := parseCast(planValue.(basetypes.StringValue), keyhubmodel.ParseVaultVaultSecretType, func(val any) keyhubmodel.VaultVaultSecretType { return *val.(*keyhubmodel.VaultVaultSecretType) })
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTypes")
		tkh.SetTypes(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["url"]))+" using SetUrl")
	tkh.SetUrl(tfToStringPointer(planAttrValues["url"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["username"]))+" using SetUsername")
	tkh.SetUsername(tfToStringPointer(planAttrValues["username"]))
	{
		val, d := parseCastPointer(planAttrValues["warning_period"].(basetypes.StringValue), keyhubmodel.ParseVaultVaultRecordWarningPeriod, func(val any) keyhubmodel.VaultVaultRecordWarningPeriod {
			return *val.(*keyhubmodel.VaultVaultRecordWarningPeriod)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetWarningPeriod")
		tkh.SetWarningPeriod(val)
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSVaultVaultRecord_additionalObjects(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROVaultVaultRecordRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.VaultVaultRecordable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.VaultVaultRecordable
	tkh = keyhubmodel.NewVaultVaultRecord()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["color"].(basetypes.StringValue), keyhubmodel.ParseVaultVaultRecordColor, func(val any) keyhubmodel.VaultVaultRecordColor { return *val.(*keyhubmodel.VaultVaultRecordColor) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetColor")
		tkh.SetColor(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfToTimePointer(planAttrValues["share_end_time"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetShareEndTime")
		tkh.SetShareEndTime(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["derived"]))+" using SetDerived")
	tkh.SetDerived(tfToBooleanPointer(planAttrValues["derived"]))
	{
		val, d := parsePointer2(planAttrValues["end_date"].(basetypes.StringValue), serialization.ParseDateOnly)
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetEndDate")
		tkh.SetEndDate(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["filename"]))+" using SetFilename")
	tkh.SetFilename(tfToStringPointer(planAttrValues["filename"]))
	{
		val, d := tfToSliceSet(toSetValue(planAttrValues["types"]), toSetValue(configAttrValues["types"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.VaultVaultSecretType {
			tkh, d := parseCast(planValue.(basetypes.StringValue), keyhubmodel.ParseVaultVaultSecretType, func(val any) keyhubmodel.VaultVaultSecretType { return *val.(*keyhubmodel.VaultVaultSecretType) })
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTypes")
		tkh.SetTypes(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["url"]))+" using SetUrl")
	tkh.SetUrl(tfToStringPointer(planAttrValues["url"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["username"]))+" using SetUsername")
	tkh.SetUsername(tfToStringPointer(planAttrValues["username"]))
	{
		val, d := parseCastPointer(planAttrValues["warning_period"].(basetypes.StringValue), keyhubmodel.ParseVaultVaultRecordWarningPeriod, func(val any) keyhubmodel.VaultVaultRecordWarningPeriod {
			return *val.(*keyhubmodel.VaultVaultRecordWarningPeriod)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetWarningPeriod")
		tkh.SetWarningPeriod(val)
	}
	if recurse {
		{
			val, d := tfObjectToTKHDSROVaultVaultRecord_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSVaultVaultRecordPrimer(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.VaultVaultRecordPrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.VaultVaultRecordPrimerable
	tkh = keyhubmodel.NewVaultVaultRecordPrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["color"].(basetypes.StringValue), keyhubmodel.ParseVaultVaultRecordColor, func(val any) keyhubmodel.VaultVaultRecordColor { return *val.(*keyhubmodel.VaultVaultRecordColor) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetColor")
		tkh.SetColor(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfToTimePointer(planAttrValues["share_end_time"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetShareEndTime")
		tkh.SetShareEndTime(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	return tkh, diags
}

func tfObjectToTKHDSROVaultVaultRecordPrimerRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.VaultVaultRecordPrimerable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.VaultVaultRecordPrimerable
	tkh = keyhubmodel.NewVaultVaultRecordPrimer()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["color"].(basetypes.StringValue), keyhubmodel.ParseVaultVaultRecordColor, func(val any) keyhubmodel.VaultVaultRecordColor { return *val.(*keyhubmodel.VaultVaultRecordColor) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetColor")
		tkh.SetColor(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfToTimePointer(planAttrValues["share_end_time"].(basetypes.StringValue))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetShareEndTime")
		tkh.SetShareEndTime(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	return tkh, diags
}

func tfObjectToTKHDSROVaultVaultRecordPrimerLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.VaultVaultRecordPrimerLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.VaultVaultRecordPrimerLinkableWrapperable
	tkh = keyhubmodel.NewVaultVaultRecordPrimerLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.VaultVaultRecordPrimerable {
			tkh, d := tfObjectToTKHDSROVaultVaultRecordPrimerRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSVaultVaultRecordSecrets(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.VaultVaultRecordSecretsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.VaultVaultRecordSecretsable
	tkh = keyhubmodel.NewVaultVaultRecordSecrets()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["comment"]))+" using SetComment")
	tkh.SetComment(tfToStringPointer(planAttrValues["comment"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["file"]))+" using SetFile")
	tkh.SetFile(tfToStringPointer(planAttrValues["file"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["password"]))+" using SetPassword")
	tkh.SetPassword(tfToStringPointer(planAttrValues["password"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["totp"]))+" using SetTotp")
	tkh.SetTotp(tfToStringPointer(planAttrValues["totp"]))
	return tkh, diags
}

func tfObjectToTKHDSROVaultVaultRecordSecretsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.VaultVaultRecordSecretsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.VaultVaultRecordSecretsable
	tkh = keyhubmodel.NewVaultVaultRecordSecrets()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["comment"]))+" using SetComment")
	tkh.SetComment(tfToStringPointer(planAttrValues["comment"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["file"]))+" using SetFile")
	tkh.SetFile(tfToStringPointer(planAttrValues["file"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["password"]))+" using SetPassword")
	tkh.SetPassword(tfToStringPointer(planAttrValues["password"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["totp"]))+" using SetTotp")
	tkh.SetTotp(tfToStringPointer(planAttrValues["totp"]))
	return tkh, diags
}

func tfObjectToTKHDSROVaultVaultRecordShareRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.VaultVaultRecordShareable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.VaultVaultRecordShareable
	tkh = keyhubmodel.NewVaultVaultRecordShare()
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := parseCastPointer(planAttrValues["type"].(basetypes.StringValue), keyhubmodel.ParseVaultVaultHolderType, func(val any) keyhubmodel.VaultVaultHolderType { return *val.(*keyhubmodel.VaultVaultHolderType) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetVaultVaultRecordShareType")
		tkh.SetVaultVaultRecordShareType(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROVaultVaultRecordShareSummaryRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.VaultVaultRecordShareSummaryable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.VaultVaultRecordShareSummaryable
	tkh = keyhubmodel.NewVaultVaultRecordShareSummary()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["children"]), toListValue(configAttrValues["children"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.VaultVaultRecordShareable {
			tkh, d := tfObjectToTKHDSROVaultVaultRecordShareRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetChildren")
		tkh.SetChildren(val)
	}
	{
		val, d := tfObjectToTKHDSROVaultVaultRecordShareRO(ctx, recurse, toObjectValue(planAttrValues["parent"]), toObjectValue(configAttrValues["parent"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetParent")
		tkh.SetParent(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSVaultVaultRecord_additionalObjects(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.VaultVaultRecord_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.VaultVaultRecord_additionalObjectsable
	tkh = keyhubmodel.NewVaultVaultRecord_additionalObjects()
	{
		val, d := tfObjectToTKHDSROVaultVaultActivationStatusRO(ctx, recurse, toObjectValue(planAttrValues["activation_status"]), toObjectValue(configAttrValues["activation_status"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetActivationStatus")
		tkh.SetActivationStatus(val)
	}
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	{
		val, d := tfObjectToTKHDSROVaultVaultRecordPrimerRO(ctx, recurse, toObjectValue(planAttrValues["parent"]), toObjectValue(configAttrValues["parent"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetParent")
		tkh.SetParent(val)
	}
	{
		val, d := tfObjectToTKHDSROVaultPasswordMetadataRO(ctx, recurse, toObjectValue(planAttrValues["password_metadata"]), toObjectValue(configAttrValues["password_metadata"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPasswordMetadata")
		tkh.SetPasswordMetadata(val)
	}
	{
		val, d := tfObjectToTKHDSVaultVaultRecordSecrets(ctx, recurse, toObjectValue(planAttrValues["secret"]), toObjectValue(configAttrValues["secret"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSecret")
		tkh.SetSecret(val)
	}
	{
		val, d := tfObjectToTKHDSROVaultVaultRecordShareSummaryRO(ctx, recurse, toObjectValue(planAttrValues["share_summary"]), toObjectValue(configAttrValues["share_summary"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetShareSummary")
		tkh.SetShareSummary(val)
	}
	{
		val, d := tfObjectToTKHDSROVaultVaultRecordPrimerLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["shares"]), toItemsList(ctx, configAttrValues["shares"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetShares")
		tkh.SetShares(val)
	}
	{
		val, d := tfObjectToTKHDSLaunchpadVaultRecordLaunchpadTile(ctx, recurse, toObjectValue(planAttrValues["tile"]), toObjectValue(configAttrValues["tile"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTile")
		tkh.SetTile(val)
	}
	{
		val, d := tfObjectToTKHDSROLinkableRO(ctx, recurse, toObjectValue(planAttrValues["vaultholder"]), toObjectValue(configAttrValues["vaultholder"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetVaultholder")
		tkh.SetVaultholder(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROVaultVaultRecord_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.VaultVaultRecord_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.VaultVaultRecord_additionalObjectsable
	tkh = keyhubmodel.NewVaultVaultRecord_additionalObjects()
	{
		val, d := tfObjectToTKHDSROVaultVaultActivationStatusRO(ctx, recurse, toObjectValue(planAttrValues["activation_status"]), toObjectValue(configAttrValues["activation_status"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetActivationStatus")
		tkh.SetActivationStatus(val)
	}
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	{
		val, d := tfObjectToTKHDSROVaultVaultRecordPrimerRO(ctx, recurse, toObjectValue(planAttrValues["parent"]), toObjectValue(configAttrValues["parent"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetParent")
		tkh.SetParent(val)
	}
	{
		val, d := tfObjectToTKHDSROVaultPasswordMetadataRO(ctx, recurse, toObjectValue(planAttrValues["password_metadata"]), toObjectValue(configAttrValues["password_metadata"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPasswordMetadata")
		tkh.SetPasswordMetadata(val)
	}
	{
		val, d := tfObjectToTKHDSROVaultVaultRecordSecretsRO(ctx, recurse, toObjectValue(planAttrValues["secret"]), toObjectValue(configAttrValues["secret"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSecret")
		tkh.SetSecret(val)
	}
	{
		val, d := tfObjectToTKHDSROVaultVaultRecordShareSummaryRO(ctx, recurse, toObjectValue(planAttrValues["share_summary"]), toObjectValue(configAttrValues["share_summary"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetShareSummary")
		tkh.SetShareSummary(val)
	}
	{
		val, d := tfObjectToTKHDSROVaultVaultRecordPrimerLinkableWrapperRO(ctx, recurse, toItemsList(ctx, planAttrValues["shares"]), toItemsList(ctx, configAttrValues["shares"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetShares")
		tkh.SetShares(val)
	}
	{
		val, d := tfObjectToTKHDSROLaunchpadVaultRecordLaunchpadTileRO(ctx, recurse, toObjectValue(planAttrValues["tile"]), toObjectValue(configAttrValues["tile"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTile")
		tkh.SetTile(val)
	}
	{
		val, d := tfObjectToTKHDSROLinkableRO(ctx, recurse, toObjectValue(planAttrValues["vaultholder"]), toObjectValue(configAttrValues["vaultholder"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetVaultholder")
		tkh.SetVaultholder(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSWebhookWebhook(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.WebhookWebhookable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.WebhookWebhookable
	tkh = keyhubmodel.NewWebhookWebhook()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRestLink(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSAuthPermission(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := tfObjectToTKHDSAuthAccountPrimer(ctx, false, toObjectValue(planAttrValues["account"]), toObjectValue(configAttrValues["account"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAccount")
		tkh.SetAccount(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["active"]))+" using SetActive")
	tkh.SetActive(tfToBooleanPointer(planAttrValues["active"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["all_types"]))+" using SetAllTypes")
	tkh.SetAllTypes(tfToBooleanPointer(planAttrValues["all_types"]))
	{
		val, d := parseCastPointer(planAttrValues["authentication_scheme"].(basetypes.StringValue), keyhubmodel.ParseHttpAuthenticationScheme, func(val any) keyhubmodel.HttpAuthenticationScheme {
			return *val.(*keyhubmodel.HttpAuthenticationScheme)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAuthenticationScheme")
		tkh.SetAuthenticationScheme(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["basic_auth_password"]))+" using SetBasicAuthPassword")
	tkh.SetBasicAuthPassword(tfToStringPointer(planAttrValues["basic_auth_password"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["basic_auth_username"]))+" using SetBasicAuthUsername")
	tkh.SetBasicAuthUsername(tfToStringPointer(planAttrValues["basic_auth_username"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["bearer_token"]))+" using SetBearerToken")
	tkh.SetBearerToken(tfToStringPointer(planAttrValues["bearer_token"]))
	{
		val, d := tfObjectToTKHDSClientClientApplicationPrimer(ctx, false, toObjectValue(planAttrValues["client"]), toObjectValue(configAttrValues["client"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClient")
		tkh.SetClient(val)
	}
	{
		val, d := tfObjectToTKHDSCertificateCertificatePrimer(ctx, false, toObjectValue(planAttrValues["client_certificate"]), toObjectValue(configAttrValues["client_certificate"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClientCertificate")
		tkh.SetClientCertificate(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["custom_header_name"]))+" using SetCustomHeaderName")
	tkh.SetCustomHeaderName(tfToStringPointer(planAttrValues["custom_header_name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["custom_header_value"]))+" using SetCustomHeaderValue")
	tkh.SetCustomHeaderValue(tfToStringPointer(planAttrValues["custom_header_value"]))
	{
		val, d := tfObjectToTKHDSDirectoryAccountDirectoryPrimer(ctx, false, toObjectValue(planAttrValues["directory"]), toObjectValue(configAttrValues["directory"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDirectory")
		tkh.SetDirectory(val)
	}
	{
		val, d := tfObjectToTKHDSGroupGroupPrimer(ctx, false, toObjectValue(planAttrValues["group"]), toObjectValue(configAttrValues["group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroup")
		tkh.SetGroup(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfObjectToTKHDSProvisioningProvisionedSystemPrimer(ctx, false, toObjectValue(planAttrValues["system"]), toObjectValue(configAttrValues["system"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSystem")
		tkh.SetSystem(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["tls"].(basetypes.StringValue), keyhubmodel.ParseTLSLevel, func(val any) keyhubmodel.TLSLevel { return *val.(*keyhubmodel.TLSLevel) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTls")
		tkh.SetTls(val)
	}
	{
		val, d := tfObjectToTKHDSCertificateCertificatePrimer(ctx, false, toObjectValue(planAttrValues["trusted_certificate"]), toObjectValue(configAttrValues["trusted_certificate"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTrustedCertificate")
		tkh.SetTrustedCertificate(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["types"]), toListValue(configAttrValues["types"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuditAuditRecordType {
			tkh, d := parseCast(planValue.(basetypes.StringValue), keyhubmodel.ParseAuditAuditRecordType, func(val any) keyhubmodel.AuditAuditRecordType { return *val.(*keyhubmodel.AuditAuditRecordType) })
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTypes")
		tkh.SetTypes(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["url"]))+" using SetUrl")
	tkh.SetUrl(tfToStringPointer(planAttrValues["url"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["verbose_payloads"]))+" using SetVerbosePayloads")
	tkh.SetVerbosePayloads(tfToBooleanPointer(planAttrValues["verbose_payloads"]))
	if recurse {
		{
			val, d := tfObjectToTKHDSWebhookWebhook_additionalObjects(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROWebhookWebhookRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.WebhookWebhookable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.WebhookWebhookable
	tkh = keyhubmodel.NewWebhookWebhook()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["links"]), toListValue(configAttrValues["links"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.RestLinkable {
			tkh, d := tfObjectToTKHDSRORestLinkRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetLinks")
		tkh.SetLinks(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["permissions"]), toListValue(configAttrValues["permissions"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuthPermissionable {
			tkh, d := tfObjectToTKHDSROAuthPermissionRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetPermissions")
		tkh.SetPermissions(val)
	}
	{
		val, d := tfObjectToTKHDSROAuthAccountPrimerRO(ctx, false, toObjectValue(planAttrValues["account"]), toObjectValue(configAttrValues["account"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAccount")
		tkh.SetAccount(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["active"]))+" using SetActive")
	tkh.SetActive(tfToBooleanPointer(planAttrValues["active"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["all_types"]))+" using SetAllTypes")
	tkh.SetAllTypes(tfToBooleanPointer(planAttrValues["all_types"]))
	{
		val, d := parseCastPointer(planAttrValues["authentication_scheme"].(basetypes.StringValue), keyhubmodel.ParseHttpAuthenticationScheme, func(val any) keyhubmodel.HttpAuthenticationScheme {
			return *val.(*keyhubmodel.HttpAuthenticationScheme)
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAuthenticationScheme")
		tkh.SetAuthenticationScheme(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["basic_auth_password"]))+" using SetBasicAuthPassword")
	tkh.SetBasicAuthPassword(tfToStringPointer(planAttrValues["basic_auth_password"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["basic_auth_username"]))+" using SetBasicAuthUsername")
	tkh.SetBasicAuthUsername(tfToStringPointer(planAttrValues["basic_auth_username"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["bearer_token"]))+" using SetBearerToken")
	tkh.SetBearerToken(tfToStringPointer(planAttrValues["bearer_token"]))
	{
		val, d := tfObjectToTKHDSROClientClientApplicationPrimerRO(ctx, false, toObjectValue(planAttrValues["client"]), toObjectValue(configAttrValues["client"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClient")
		tkh.SetClient(val)
	}
	{
		val, d := tfObjectToTKHDSROCertificateCertificatePrimerRO(ctx, false, toObjectValue(planAttrValues["client_certificate"]), toObjectValue(configAttrValues["client_certificate"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetClientCertificate")
		tkh.SetClientCertificate(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["custom_header_name"]))+" using SetCustomHeaderName")
	tkh.SetCustomHeaderName(tfToStringPointer(planAttrValues["custom_header_name"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["custom_header_value"]))+" using SetCustomHeaderValue")
	tkh.SetCustomHeaderValue(tfToStringPointer(planAttrValues["custom_header_value"]))
	{
		val, d := tfObjectToTKHDSRODirectoryAccountDirectoryPrimerRO(ctx, false, toObjectValue(planAttrValues["directory"]), toObjectValue(configAttrValues["directory"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetDirectory")
		tkh.SetDirectory(val)
	}
	{
		val, d := tfObjectToTKHDSROGroupGroupPrimerRO(ctx, false, toObjectValue(planAttrValues["group"]), toObjectValue(configAttrValues["group"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetGroup")
		tkh.SetGroup(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["name"]))+" using SetName")
	tkh.SetName(tfToStringPointer(planAttrValues["name"]))
	{
		val, d := tfObjectToTKHDSROProvisioningProvisionedSystemPrimerRO(ctx, false, toObjectValue(planAttrValues["system"]), toObjectValue(configAttrValues["system"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetSystem")
		tkh.SetSystem(val)
	}
	{
		val, d := parseCastPointer(planAttrValues["tls"].(basetypes.StringValue), keyhubmodel.ParseTLSLevel, func(val any) keyhubmodel.TLSLevel { return *val.(*keyhubmodel.TLSLevel) })
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTls")
		tkh.SetTls(val)
	}
	{
		val, d := tfObjectToTKHDSROCertificateCertificatePrimerRO(ctx, false, toObjectValue(planAttrValues["trusted_certificate"]), toObjectValue(configAttrValues["trusted_certificate"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTrustedCertificate")
		tkh.SetTrustedCertificate(val)
	}
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["types"]), toListValue(configAttrValues["types"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.AuditAuditRecordType {
			tkh, d := parseCast(planValue.(basetypes.StringValue), keyhubmodel.ParseAuditAuditRecordType, func(val any) keyhubmodel.AuditAuditRecordType { return *val.(*keyhubmodel.AuditAuditRecordType) })
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetTypes")
		tkh.SetTypes(val)
	}
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["url"]))+" using SetUrl")
	tkh.SetUrl(tfToStringPointer(planAttrValues["url"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToStringPointer(planAttrValues["uuid"]))+" using SetUuid")
	tkh.SetUuid(tfToStringPointer(planAttrValues["uuid"]))
	tflog.Debug(ctx, "Setting "+litter.Sdump(tfToBooleanPointer(planAttrValues["verbose_payloads"]))+" using SetVerbosePayloads")
	tkh.SetVerbosePayloads(tfToBooleanPointer(planAttrValues["verbose_payloads"]))
	if recurse {
		{
			val, d := tfObjectToTKHDSROWebhookWebhook_additionalObjectsRO(ctx, false, planValues, configValues)
			diags.Append(d...)
			tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAdditionalObjects")
			tkh.SetAdditionalObjects(val)
		}
	}
	return tkh, diags
}

func tfObjectToTKHDSROWebhookWebhookLinkableWrapperRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.WebhookWebhookLinkableWrapperable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.WebhookWebhookLinkableWrapperable
	tkh = keyhubmodel.NewWebhookWebhookLinkableWrapper()
	{
		val, d := tfToSliceListBinary(toListValue(planAttrValues["items"]), toListValue(configAttrValues["items"]), func(planValue attr.Value, configValue attr.Value, diags *diag.Diagnostics) keyhubmodel.WebhookWebhookable {
			tkh, d := tfObjectToTKHDSROWebhookWebhookRO(ctx, recurse, toObjectValue(planValue), toObjectValue(configValue))
			diags.Append(d...)
			return tkh
		})
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetItems")
		tkh.SetItems(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSWebhookWebhook_additionalObjects(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.WebhookWebhook_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.WebhookWebhook_additionalObjectsable
	tkh = keyhubmodel.NewWebhookWebhook_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	return tkh, diags
}

func tfObjectToTKHDSROWebhookWebhook_additionalObjectsRO(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) (keyhubmodel.WebhookWebhook_additionalObjectsable, diag.Diagnostics) {
	var diags diag.Diagnostics
	var missingPlanValues = planValues.IsNull() || planValues.IsUnknown()
	var missingConfigValues = configValues.IsNull() || configValues.IsUnknown()
	if missingPlanValues && missingConfigValues {
		return nil, diags
	}
	planAttrValues := make(map[string]attr.Value)
	if !missingPlanValues {
		planAttrValues = planValues.Attributes()
	}
	configAttrValues := make(map[string]attr.Value)
	if !missingConfigValues {
		configAttrValues = configValues.Attributes()
	}

	// avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
	_, _ = planAttrValues, configAttrValues
	litter.Config.HidePrivateFields = false
	tflog.Trace(ctx, "planAttrValues: "+litter.Sdump(planAttrValues))
	tflog.Trace(ctx, "configAttrValues: "+litter.Sdump(configAttrValues))
	var tkh keyhubmodel.WebhookWebhook_additionalObjectsable
	tkh = keyhubmodel.NewWebhookWebhook_additionalObjects()
	{
		val, d := tfObjectToTKHDSROAuditInfoRO(ctx, recurse, toObjectValue(planAttrValues["audit"]), toObjectValue(configAttrValues["audit"]))
		diags.Append(d...)
		tflog.Debug(ctx, "Setting "+litter.Sdump(val)+" using SetAudit")
		tkh.SetAudit(val)
	}
	return tkh, diags
}
