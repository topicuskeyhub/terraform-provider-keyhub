// Code generated by "terraform-provider-keyhub-generator"; DO NOT EDIT.
// Copyright (c) Topicus Security B.V.
// SPDX-License-Identifier: APSL-2.0

//lint:ignore U1000 Ignore unused functions in generated code
package provider

import (
	"golang.org/x/exp/maps"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

func reorderAuditInfo(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = auditInfoAttrTypesRSRecurse
	} else {
		attrs = auditInfoAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGeneratedSecret(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = generatedSecretAttrTypesRSRecurse
	} else {
		attrs = generatedSecretAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderLinkable(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = linkableAttrTypesRSRecurse
	} else {
		attrs = linkableAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderNonLinkable(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = nonLinkableAttrTypesRSRecurse
	} else {
		attrs = nonLinkableAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderRestLink(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = restLinkAttrTypesRSRecurse
	} else {
		attrs = restLinkAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderAuditGroupAudit(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = auditGroupAuditAttrTypesRSRecurse
	} else {
		attrs = auditGroupAuditAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderAuditGroupAudit_additionalObjects(state, priorState, false).Attributes())
	}
	// Reordering not supported for accounts with type List
	// Reordering not supported for nested_groups with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderAuditGroupAuditAccount(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = auditGroupAuditAccountAttrTypesRSRecurse
	} else {
		attrs = auditGroupAuditAccountAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderAuditGroupAuditLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = auditGroupAuditLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = auditGroupAuditLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderAuditGroupAudit_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = auditGroupAudit_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = auditGroupAudit_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderAuditNestedGroupAudit(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = auditNestedGroupAuditAttrTypesRSRecurse
	} else {
		attrs = auditNestedGroupAuditAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderAuthAccountPrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = authAccountPrimerAttrTypesRSRecurse
	} else {
		attrs = authAccountPrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderAuthPermission(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = authPermissionAttrTypesRSRecurse
	} else {
		attrs = authPermissionAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderCertificateCertificatePrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = certificateCertificatePrimerAttrTypesRSRecurse
	} else {
		attrs = certificateCertificatePrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientApplicationVaultVaultRecord(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientApplicationVaultVaultRecordAttrTypesRSRecurse
	} else {
		attrs = clientApplicationVaultVaultRecordAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderVaultVaultRecord_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientClientApplication(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientClientApplicationAttrTypesRSRecurse
	} else {
		attrs = clientClientApplicationAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderClientClientApplication_additionalObjects(state, priorState, false).Attributes())
	}
	obj["ldap_client"] = reorderClientLdapClient(state.Attributes()["ldap_client"].(types.Object), priorState.Attributes()["ldap_client"].(types.Object), recurse)
	obj["oauth2_client"] = reorderClientOAuth2Client(state.Attributes()["oauth2_client"].(types.Object), priorState.Attributes()["oauth2_client"].(types.Object), recurse)
	obj["saml2_client"] = reorderClientSaml2Client(state.Attributes()["saml2_client"].(types.Object), priorState.Attributes()["saml2_client"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientClientApplicationLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientClientApplicationLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = clientClientApplicationLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientClientApplicationPrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientClientApplicationPrimerAttrTypesRSRecurse
	} else {
		attrs = clientClientApplicationPrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientClientApplication_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientClientApplication_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = clientClientApplication_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	{
		attrState := state.Attributes()["accessprofileclients"]
		attrPriorState := priorState.Attributes()["accessprofileclients"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["accessprofileclients"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{
				"access_profile_uuid",
			}, reorderProfileAccessProfileClient)
			obj["accessprofileclients"] = types.ListValueMust(attrs["accessprofileclients"].(types.ListType).ElemType, newAttrState)
		}
	}
	{
		attrState := state.Attributes()["groupclients"]
		attrPriorState := priorState.Attributes()["groupclients"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["groupclients"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{
				"group_uuid",
				"activation_required",
				"owner_uuid",
				"technical_administrator_uuid",
			}, reorderGroupGroupClient)
			obj["groupclients"] = types.ListValueMust(attrs["groupclients"].(types.ListType).ElemType, newAttrState)
		}
	}
	obj["secret"] = reorderGeneratedSecret(state.Attributes()["secret"].(types.Object), priorState.Attributes()["secret"].(types.Object), recurse)
	obj["tile"] = reorderLaunchpadSsoApplicationLaunchpadTile(state.Attributes()["tile"].(types.Object), priorState.Attributes()["tile"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientLdapClient(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientLdapClientAttrTypesRSRecurse
	} else {
		attrs = clientLdapClientAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientOAuth2Client(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientOAuth2ClientAttrTypesRSRecurse
	} else {
		attrs = clientOAuth2ClientAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for attributes with type Map

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientOAuth2ClientPermission(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientOAuth2ClientPermissionAttrTypesRSRecurse
	} else {
		attrs = clientOAuth2ClientPermissionAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderClientOAuth2ClientPermission_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientOAuth2ClientPermissionWithClient(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientOAuth2ClientPermissionWithClientAttrTypesRSRecurse
	} else {
		attrs = clientOAuth2ClientPermissionWithClientAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderClientOAuth2ClientPermission_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientOAuth2ClientPermissionWithClientLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientOAuth2ClientPermissionWithClientLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = clientOAuth2ClientPermissionWithClientLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientOAuth2ClientPermission_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientOAuth2ClientPermission_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = clientOAuth2ClientPermission_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientSaml2Client(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientSaml2ClientAttrTypesRSRecurse
	} else {
		attrs = clientSaml2ClientAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for attributes with type Map

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryAccountDirectory(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryAccountDirectoryAttrTypesRSRecurse
	} else {
		attrs = directoryAccountDirectoryAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderDirectoryAccountDirectory_additionalObjects(state, priorState, false).Attributes())
	}
	obj["internal_directory"] = reorderDirectoryInternalDirectory(state.Attributes()["internal_directory"].(types.Object), priorState.Attributes()["internal_directory"].(types.Object), recurse)
	obj["ldap_directory"] = reorderDirectoryLDAPDirectory(state.Attributes()["ldap_directory"].(types.Object), priorState.Attributes()["ldap_directory"].(types.Object), recurse)
	obj["maintenance_directory"] = reorderDirectoryMaintenanceDirectory(state.Attributes()["maintenance_directory"].(types.Object), priorState.Attributes()["maintenance_directory"].(types.Object), recurse)
	obj["oidc_directory"] = reorderDirectoryOIDCDirectory(state.Attributes()["oidc_directory"].(types.Object), priorState.Attributes()["oidc_directory"].(types.Object), recurse)
	obj["pending_accounts_directory"] = reorderDirectoryPendingAccountsDirectory(state.Attributes()["pending_accounts_directory"].(types.Object), priorState.Attributes()["pending_accounts_directory"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryAccountDirectoryLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryAccountDirectoryLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = directoryAccountDirectoryLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryAccountDirectoryPrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryAccountDirectoryPrimerAttrTypesRSRecurse
	} else {
		attrs = directoryAccountDirectoryPrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryAccountDirectoryStatusReport(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryAccountDirectoryStatusReportAttrTypesRSRecurse
	} else {
		attrs = directoryAccountDirectoryStatusReportAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryAccountDirectorySummary(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryAccountDirectorySummaryAttrTypesRSRecurse
	} else {
		attrs = directoryAccountDirectorySummaryAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["status"] = reorderDirectoryAccountDirectoryStatusReport(state.Attributes()["status"].(types.Object), priorState.Attributes()["status"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryAccountDirectorySummaryLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryAccountDirectorySummaryLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = directoryAccountDirectorySummaryLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryAccountDirectory_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryAccountDirectory_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = directoryAccountDirectory_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryInternalDirectory(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryInternalDirectoryAttrTypesRSRecurse
	} else {
		attrs = directoryInternalDirectoryAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryLDAPDirectory(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryLDAPDirectoryAttrTypesRSRecurse
	} else {
		attrs = directoryLDAPDirectoryAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryMaintenanceDirectory(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryMaintenanceDirectoryAttrTypesRSRecurse
	} else {
		attrs = directoryMaintenanceDirectoryAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryOIDCDirectory(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryOIDCDirectoryAttrTypesRSRecurse
	} else {
		attrs = directoryOIDCDirectoryAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryPendingAccountsDirectory(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryPendingAccountsDirectoryAttrTypesRSRecurse
	} else {
		attrs = directoryPendingAccountsDirectoryAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroup(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupAttrTypesRSRecurse
	} else {
		attrs = groupGroupAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderGroupGroup_additionalObjects(state, priorState, false).Attributes())
	}
	obj["audit_config"] = reorderGroupGroupAuditConfig(state.Attributes()["audit_config"].(types.Object), priorState.Attributes()["audit_config"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupAccessInfo(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupAccessInfoAttrTypesRSRecurse
	} else {
		attrs = groupGroupAccessInfoAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupAccount(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupAccountAttrTypesRSRecurse
	} else {
		attrs = groupGroupAccountAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderGroupGroupAccount_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupAccountLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupAccountLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = groupGroupAccountLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupAccount_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupAccount_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = groupGroupAccount_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupAuditConfig(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupAuditConfigAttrTypesRSRecurse
	} else {
		attrs = groupGroupAuditConfigAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupAuditingInfo(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupAuditingInfoAttrTypesRSRecurse
	} else {
		attrs = groupGroupAuditingInfoAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupClassificationPrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupClassificationPrimerAttrTypesRSRecurse
	} else {
		attrs = groupGroupClassificationPrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupClient(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupClientAttrTypesRSRecurse
	} else {
		attrs = groupGroupClientAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderGroupGroupClient_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupClientLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupClientLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = groupGroupClientLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupClientLinkableWrapperWithCount(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupClientLinkableWrapperWithCountAttrTypesRSRecurse
	} else {
		attrs = groupGroupClientLinkableWrapperWithCountAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupClient_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupClient_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = groupGroupClient_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupGlobalRoleInfo(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupGlobalRoleInfoAttrTypesRSRecurse
	} else {
		attrs = groupGroupGlobalRoleInfoAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for auditor_group_for with type List
	// Reordering not supported for create_group_approve_group_for with type List
	// Reordering not supported for enable_tech_admin_approve_group_for with type List
	// Reordering not supported for recovery_fallback_group_for with type List
	// Reordering not supported for remove_group_approve_group_for with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupInfo(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupInfoAttrTypesRSRecurse
	} else {
		attrs = groupGroupInfoAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = groupGroupLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupLinkableWrapperWithCount(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupLinkableWrapperWithCountAttrTypesRSRecurse
	} else {
		attrs = groupGroupLinkableWrapperWithCountAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupPrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupPrimerAttrTypesRSRecurse
	} else {
		attrs = groupGroupPrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupPrimerLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupPrimerLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = groupGroupPrimerLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroup_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroup_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = groupGroup_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	{
		attrState := state.Attributes()["accounts"]
		attrPriorState := priorState.Attributes()["accounts"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["accounts"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{
				"uuid",
				"rights",
				"end_date",
			}, reorderGroupGroupAccount)
			obj["accounts"] = types.ListValueMust(attrs["accounts"].(types.ListType).ElemType, newAttrState)
		}
	}
	{
		attrState := state.Attributes()["admins"]
		attrPriorState := priorState.Attributes()["admins"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["admins"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{
				"uuid",
				"rights",
				"end_date",
			}, reorderGroupGroupAccount)
			obj["admins"] = types.ListValueMust(attrs["admins"].(types.ListType).ElemType, newAttrState)
		}
	}
	{
		attrState := state.Attributes()["client_permissions"]
		attrPriorState := priorState.Attributes()["client_permissions"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["client_permissions"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{
				"value",
				"for_group_uuid",
				"for_system_uuid",
				"client_uuid",
			}, reorderClientOAuth2ClientPermissionWithClient)
			obj["client_permissions"] = types.ListValueMust(attrs["client_permissions"].(types.ListType).ElemType, newAttrState)
		}
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupProvisioningGroup(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupProvisioningGroupAttrTypesRSRecurse
	} else {
		attrs = groupProvisioningGroupAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderGroupProvisioningGroup_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupProvisioningGroupLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupProvisioningGroupLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = groupProvisioningGroupLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupProvisioningGroupLinkableWrapperWithCount(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupProvisioningGroupLinkableWrapperWithCountAttrTypesRSRecurse
	} else {
		attrs = groupProvisioningGroupLinkableWrapperWithCountAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupProvisioningGroup_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupProvisioningGroup_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = groupProvisioningGroup_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupVaultVaultRecord(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupVaultVaultRecordAttrTypesRSRecurse
	} else {
		attrs = groupVaultVaultRecordAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderVaultVaultRecord_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderIdentityAccountAttributeDefinition(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = identityAccountAttributeDefinitionAttrTypesRSRecurse
	} else {
		attrs = identityAccountAttributeDefinitionAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderIdentityAccountAttributeDefinition_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderIdentityAccountAttributeDefinition_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = identityAccountAttributeDefinition_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = identityAccountAttributeDefinition_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderIdentityAccountAttributeRule(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = identityAccountAttributeRuleAttrTypesRSRecurse
	} else {
		attrs = identityAccountAttributeRuleAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderIdentityAccountAttributeRule_additionalObjects(state, priorState, false).Attributes())
	}
	obj["attribute"] = reorderIdentityAccountAttributeDefinition(state.Attributes()["attribute"].(types.Object), priorState.Attributes()["attribute"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderIdentityAccountAttributeRuleLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = identityAccountAttributeRuleLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = identityAccountAttributeRuleLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderIdentityAccountAttributeRule_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = identityAccountAttributeRule_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = identityAccountAttributeRule_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderIdentityAccountAttributeValueSummary(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = identityAccountAttributeValueSummaryAttrTypesRSRecurse
	} else {
		attrs = identityAccountAttributeValueSummaryAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["attribute"] = reorderIdentityAccountAttributeDefinition(state.Attributes()["attribute"].(types.Object), priorState.Attributes()["attribute"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderLaunchpadSsoApplicationLaunchpadTile(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = launchpadSsoApplicationLaunchpadTileAttrTypesRSRecurse
	} else {
		attrs = launchpadSsoApplicationLaunchpadTileAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderLaunchpadVaultRecordLaunchpadTile(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = launchpadVaultRecordLaunchpadTileAttrTypesRSRecurse
	} else {
		attrs = launchpadVaultRecordLaunchpadTileAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderMarkItemMarker(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = markItemMarkerAttrTypesRSRecurse
	} else {
		attrs = markItemMarkerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderMarkItemMarkers(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = markItemMarkersAttrTypesRSRecurse
	} else {
		attrs = markItemMarkersAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for markers with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderMiscAttributeCustomization(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = miscAttributeCustomizationAttrTypesRSRecurse
	} else {
		attrs = miscAttributeCustomizationAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["attribute_definition"] = reorderIdentityAccountAttributeDefinition(state.Attributes()["attribute_definition"].(types.Object), priorState.Attributes()["attribute_definition"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderNestedProvisioningGroupOnSystem(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = nestedProvisioningGroupOnSystemAttrTypesRSRecurse
	} else {
		attrs = nestedProvisioningGroupOnSystemAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProvisioningGroupOnSystem_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderOrganizationClientApplicationOrganizationalUnit(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = organizationClientApplicationOrganizationalUnitAttrTypesRSRecurse
	} else {
		attrs = organizationClientApplicationOrganizationalUnitAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderOrganizationClientApplicationOrganizationalUnitLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = organizationClientApplicationOrganizationalUnitLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = organizationClientApplicationOrganizationalUnitLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderOrganizationOrganizationalUnit(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = organizationOrganizationalUnitAttrTypesRSRecurse
	} else {
		attrs = organizationOrganizationalUnitAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderOrganizationOrganizationalUnit_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderOrganizationOrganizationalUnitLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = organizationOrganizationalUnitLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = organizationOrganizationalUnitLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderOrganizationOrganizationalUnitPrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = organizationOrganizationalUnitPrimerAttrTypesRSRecurse
	} else {
		attrs = organizationOrganizationalUnitPrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderOrganizationOrganizationalUnitPrimerLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = organizationOrganizationalUnitPrimerLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = organizationOrganizationalUnitPrimerLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderOrganizationOrganizationalUnitSettings(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = organizationOrganizationalUnitSettingsAttrTypesRSRecurse
	} else {
		attrs = organizationOrganizationalUnitSettingsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["create_group_approve_group"] = reorderGroupGroupPrimer(state.Attributes()["create_group_approve_group"].(types.Object), priorState.Attributes()["create_group_approve_group"].(types.Object), recurse)
	obj["enable_tech_admin_approve_group"] = reorderGroupGroupPrimer(state.Attributes()["enable_tech_admin_approve_group"].(types.Object), priorState.Attributes()["enable_tech_admin_approve_group"].(types.Object), recurse)
	obj["recovery_fallback_group"] = reorderGroupGroupPrimer(state.Attributes()["recovery_fallback_group"].(types.Object), priorState.Attributes()["recovery_fallback_group"].(types.Object), recurse)
	obj["remove_group_approve_group"] = reorderGroupGroupPrimer(state.Attributes()["remove_group_approve_group"].(types.Object), priorState.Attributes()["remove_group_approve_group"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderOrganizationOrganizationalUnit_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = organizationOrganizationalUnit_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = organizationOrganizationalUnit_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	{
		attrState := state.Attributes()["create_as_parent_of"]
		attrPriorState := priorState.Attributes()["create_as_parent_of"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["create_as_parent_of"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{
				"name",
			}, reorderOrganizationOrganizationalUnitPrimer)
			obj["create_as_parent_of"] = types.ListValueMust(attrs["create_as_parent_of"].(types.ListType).ElemType, newAttrState)
		}
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfile(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProfileAccessProfile_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileAccount(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileAccountAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileAccountAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProfileAccessProfileAccount_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileAccountWithAttributes(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileAccountWithAttributesAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileAccountWithAttributesAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProfileAccessProfileAccount_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileAccountWithAttributesLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileAccountWithAttributesLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileAccountWithAttributesLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileAccount_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileAccount_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileAccount_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileClient(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileClientAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileClientAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProfileAccessProfileClient_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileClientLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileClientLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileClientLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileClientLinkableWrapperWithCount(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileClientLinkableWrapperWithCountAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileClientLinkableWrapperWithCountAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileClient_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileClient_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileClient_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileGroup(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileGroupAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileGroupAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProfileAccessProfileGroup_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileGroupLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileGroupLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileGroupLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileGroup_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileGroup_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileGroup_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfilePrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfilePrimerAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfilePrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileProvisioning(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileProvisioningAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileProvisioningAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProfileAccessProfileProvisioning_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileProvisioningLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileProvisioningLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileProvisioningLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileProvisioningLinkableWrapperWithCount(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileProvisioningLinkableWrapperWithCountAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileProvisioningLinkableWrapperWithCountAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileProvisioning_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileProvisioning_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileProvisioning_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfile_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfile_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfile_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningAbstractProvisionedLDAP(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningAbstractProvisionedLDAPAttrTypesRSRecurse
	} else {
		attrs = provisioningAbstractProvisionedLDAPAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for attributes with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningCircuitBreakerStatistics(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningCircuitBreakerStatisticsAttrTypesRSRecurse
	} else {
		attrs = provisioningCircuitBreakerStatisticsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningGroupOnSystem(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningGroupOnSystemAttrTypesRSRecurse
	} else {
		attrs = provisioningGroupOnSystemAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProvisioningGroupOnSystem_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningGroupOnSystemLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningGroupOnSystemLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = provisioningGroupOnSystemLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningGroupOnSystemPrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningGroupOnSystemPrimerAttrTypesRSRecurse
	} else {
		attrs = provisioningGroupOnSystemPrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningGroupOnSystemTypes(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningGroupOnSystemTypesAttrTypesRSRecurse
	} else {
		attrs = provisioningGroupOnSystemTypesAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningGroupOnSystem_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningGroupOnSystem_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = provisioningGroupOnSystem_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	{
		attrState := state.Attributes()["access_profile_provisioning"]
		attrPriorState := priorState.Attributes()["access_profile_provisioning"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["access_profile_provisioning"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{}, reorderProfileAccessProfileProvisioning)
			obj["access_profile_provisioning"] = types.ListValueMust(attrs["access_profile_provisioning"].(types.ListType).ElemType, newAttrState)
		}
	}
	{
		attrState := state.Attributes()["provgroups"]
		attrPriorState := priorState.Attributes()["provgroups"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["provgroups"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{
				"group_uuid",
				"activation_required",
			}, reorderGroupProvisioningGroup)
			obj["provgroups"] = types.ListValueMust(attrs["provgroups"].(types.ListType).ElemType, newAttrState)
		}
	}
	{
		attrState := state.Attributes()["service_accounts"]
		attrPriorState := priorState.Attributes()["service_accounts"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["service_accounts"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{
				"name",
				"system_uuid",
				"username",
				"active",
			}, reorderServiceaccountServiceAccountPrimer)
			obj["service_accounts"] = types.ListValueMust(attrs["service_accounts"].(types.ListType).ElemType, newAttrState)
		}
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningOwnedGroupOnSystemsWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningOwnedGroupOnSystemsWrapperAttrTypesRSRecurse
	} else {
		attrs = provisioningOwnedGroupOnSystemsWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionNumberSequence(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionNumberSequenceAttrTypesRSRecurse
	} else {
		attrs = provisioningProvisionNumberSequenceAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProvisioningProvisionNumberSequence_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionNumberSequence_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionNumberSequence_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = provisioningProvisionNumberSequence_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedAD(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedADAttrTypesRSRecurse
	} else {
		attrs = provisioningProvisionedADAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedAccount(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedAccountAttrTypesRSRecurse
	} else {
		attrs = provisioningProvisionedAccountAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProvisioningProvisionedAccount_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedAccount_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedAccount_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = provisioningProvisionedAccount_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedAzureOIDCDirectory(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedAzureOIDCDirectoryAttrTypesRSRecurse
	} else {
		attrs = provisioningProvisionedAzureOIDCDirectoryAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedAzureSyncLDAPDirectory(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedAzureSyncLDAPDirectoryAttrTypesRSRecurse
	} else {
		attrs = provisioningProvisionedAzureSyncLDAPDirectoryAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedAzureTenant(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedAzureTenantAttrTypesRSRecurse
	} else {
		attrs = provisioningProvisionedAzureTenantAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedInternalLDAP(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedInternalLDAPAttrTypesRSRecurse
	} else {
		attrs = provisioningProvisionedInternalLDAPAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedLDAP(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedLDAPAttrTypesRSRecurse
	} else {
		attrs = provisioningProvisionedLDAPAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["gid_numbering"] = reorderProvisioningProvisionNumberSequence(state.Attributes()["gid_numbering"].(types.Object), priorState.Attributes()["gid_numbering"].(types.Object), recurse)
	obj["numbering"] = reorderProvisioningProvisionNumberSequence(state.Attributes()["numbering"].(types.Object), priorState.Attributes()["numbering"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedLDAPDirectory(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedLDAPDirectoryAttrTypesRSRecurse
	} else {
		attrs = provisioningProvisionedLDAPDirectoryAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for attributes with type List
	obj["gid_numbering"] = reorderProvisioningProvisionNumberSequence(state.Attributes()["gid_numbering"].(types.Object), priorState.Attributes()["gid_numbering"].(types.Object), recurse)
	obj["numbering"] = reorderProvisioningProvisionNumberSequence(state.Attributes()["numbering"].(types.Object), priorState.Attributes()["numbering"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedNamespace(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedNamespaceAttrTypesRSRecurse
	} else {
		attrs = provisioningProvisionedNamespaceAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedSCIM(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedSCIMAttrTypesRSRecurse
	} else {
		attrs = provisioningProvisionedSCIMAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for attributes with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedSystem(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedSystemAttrTypesRSRecurse
	} else {
		attrs = provisioningProvisionedSystemAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProvisioningProvisionedSystem_additionalObjects(state, priorState, false).Attributes())
	}
	obj["cleanup_period"] = reorderProvisioningProvisionedSystem_cleanupPeriod(state.Attributes()["cleanup_period"].(types.Object), priorState.Attributes()["cleanup_period"].(types.Object), recurse)
	obj["abstract_provisioned_ldap"] = reorderProvisioningAbstractProvisionedLDAP(state.Attributes()["abstract_provisioned_ldap"].(types.Object), priorState.Attributes()["abstract_provisioned_ldap"].(types.Object), recurse)
	obj["provisioned_a_d"] = reorderProvisioningProvisionedAD(state.Attributes()["provisioned_a_d"].(types.Object), priorState.Attributes()["provisioned_a_d"].(types.Object), recurse)
	obj["provisioned_azure_oidc_directory"] = reorderProvisioningProvisionedAzureOIDCDirectory(state.Attributes()["provisioned_azure_oidc_directory"].(types.Object), priorState.Attributes()["provisioned_azure_oidc_directory"].(types.Object), recurse)
	obj["provisioned_azure_sync_ldap_directory"] = reorderProvisioningProvisionedAzureSyncLDAPDirectory(state.Attributes()["provisioned_azure_sync_ldap_directory"].(types.Object), priorState.Attributes()["provisioned_azure_sync_ldap_directory"].(types.Object), recurse)
	obj["provisioned_azure_tenant"] = reorderProvisioningProvisionedAzureTenant(state.Attributes()["provisioned_azure_tenant"].(types.Object), priorState.Attributes()["provisioned_azure_tenant"].(types.Object), recurse)
	obj["provisioned_internal_ldap"] = reorderProvisioningProvisionedInternalLDAP(state.Attributes()["provisioned_internal_ldap"].(types.Object), priorState.Attributes()["provisioned_internal_ldap"].(types.Object), recurse)
	obj["provisioned_ldap"] = reorderProvisioningProvisionedLDAP(state.Attributes()["provisioned_ldap"].(types.Object), priorState.Attributes()["provisioned_ldap"].(types.Object), recurse)
	obj["provisioned_ldap_directory"] = reorderProvisioningProvisionedLDAPDirectory(state.Attributes()["provisioned_ldap_directory"].(types.Object), priorState.Attributes()["provisioned_ldap_directory"].(types.Object), recurse)
	obj["provisioned_namespace"] = reorderProvisioningProvisionedNamespace(state.Attributes()["provisioned_namespace"].(types.Object), priorState.Attributes()["provisioned_namespace"].(types.Object), recurse)
	obj["provisioned_scim"] = reorderProvisioningProvisionedSCIM(state.Attributes()["provisioned_scim"].(types.Object), priorState.Attributes()["provisioned_scim"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedSystemLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedSystemLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = provisioningProvisionedSystemLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedSystemPrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedSystemPrimerAttrTypesRSRecurse
	} else {
		attrs = provisioningProvisionedSystemPrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedSystemPrimerLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedSystemPrimerLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = provisioningProvisionedSystemPrimerLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedSystem_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedSystem_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = provisioningProvisionedSystem_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedSystem_cleanupPeriod(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedSystem_cleanupPeriodAttrTypesRSRecurse
	} else {
		attrs = provisioningProvisionedSystem_cleanupPeriodAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisioningManagementPermissions(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisioningManagementPermissionsAttrTypesRSRecurse
	} else {
		attrs = provisioningProvisioningManagementPermissionsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderServiceaccountServiceAccount(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = serviceaccountServiceAccountAttrTypesRSRecurse
	} else {
		attrs = serviceaccountServiceAccountAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderServiceaccountServiceAccount_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderServiceaccountServiceAccountGroup(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = serviceaccountServiceAccountGroupAttrTypesRSRecurse
	} else {
		attrs = serviceaccountServiceAccountGroupAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderServiceaccountServiceAccountGroup_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderServiceaccountServiceAccountGroupLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = serviceaccountServiceAccountGroupLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = serviceaccountServiceAccountGroupLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderServiceaccountServiceAccountGroup_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = serviceaccountServiceAccountGroup_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = serviceaccountServiceAccountGroup_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderServiceaccountServiceAccountLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = serviceaccountServiceAccountLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = serviceaccountServiceAccountLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderServiceaccountServiceAccountPrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = serviceaccountServiceAccountPrimerAttrTypesRSRecurse
	} else {
		attrs = serviceaccountServiceAccountPrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderServiceaccountServiceAccountPrimerLinkableWrapperWithCount(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = serviceaccountServiceAccountPrimerLinkableWrapperWithCountAttrTypesRSRecurse
	} else {
		attrs = serviceaccountServiceAccountPrimerLinkableWrapperWithCountAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderServiceaccountServiceAccountSupportedFeatures(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = serviceaccountServiceAccountSupportedFeaturesAttrTypesRSRecurse
	} else {
		attrs = serviceaccountServiceAccountSupportedFeaturesAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderServiceaccountServiceAccount_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = serviceaccountServiceAccount_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = serviceaccountServiceAccount_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["secret"] = reorderGeneratedSecret(state.Attributes()["secret"].(types.Object), priorState.Attributes()["secret"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultPasswordMetadata(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultPasswordMetadataAttrTypesRSRecurse
	} else {
		attrs = vaultPasswordMetadataAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultVault(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultVaultAttrTypesRSRecurse
	} else {
		attrs = vaultVaultAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultVaultActivationStatus(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultVaultActivationStatusAttrTypesRSRecurse
	} else {
		attrs = vaultVaultActivationStatusAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultVaultRecord(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultVaultRecordAttrTypesRSRecurse
	} else {
		attrs = vaultVaultRecordAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderVaultVaultRecord_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultVaultRecordPrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultVaultRecordPrimerAttrTypesRSRecurse
	} else {
		attrs = vaultVaultRecordPrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultVaultRecordPrimerLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultVaultRecordPrimerLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = vaultVaultRecordPrimerLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultVaultRecordSecrets(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultVaultRecordSecretsAttrTypesRSRecurse
	} else {
		attrs = vaultVaultRecordSecretsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultVaultRecordShare(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultVaultRecordShareAttrTypesRSRecurse
	} else {
		attrs = vaultVaultRecordShareAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultVaultRecordShareSummary(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultVaultRecordShareSummaryAttrTypesRSRecurse
	} else {
		attrs = vaultVaultRecordShareSummaryAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for children with type List
	obj["parent"] = reorderVaultVaultRecordShare(state.Attributes()["parent"].(types.Object), priorState.Attributes()["parent"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultVaultRecord_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultVaultRecord_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = vaultVaultRecord_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["secret"] = reorderVaultVaultRecordSecrets(state.Attributes()["secret"].(types.Object), priorState.Attributes()["secret"].(types.Object), recurse)
	obj["tile"] = reorderLaunchpadVaultRecordLaunchpadTile(state.Attributes()["tile"].(types.Object), priorState.Attributes()["tile"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderWebhookWebhook(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = webhookWebhookAttrTypesRSRecurse
	} else {
		attrs = webhookWebhookAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderWebhookWebhook_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderWebhookWebhookLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = webhookWebhookLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = webhookWebhookLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderWebhookWebhook_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = webhookWebhook_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = webhookWebhook_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}
