// Code generated by "terraform-provider-keyhub-generator"; DO NOT EDIT.
// Copyright (c) Topicus Security B.V.
// SPDX-License-Identifier: APSL-2.0

//lint:ignore U1000 Ignore unused functions in generated code
package provider

import (
	"golang.org/x/exp/maps"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

func reorderAuditInfoRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = auditInfoAttrTypesRSRORecurse
	} else {
		attrs = auditInfoAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGeneratedSecret(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = generatedSecretAttrTypesRSRecurse
	} else {
		attrs = generatedSecretAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGeneratedSecretRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = generatedSecretAttrTypesRSRORecurse
	} else {
		attrs = generatedSecretAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderLinkable(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = linkableAttrTypesRSRecurse
	} else {
		attrs = linkableAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderLinkableRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = linkableAttrTypesRSRORecurse
	} else {
		attrs = linkableAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderNonLinkable(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = nonLinkableAttrTypesRSRecurse
	} else {
		attrs = nonLinkableAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderNonLinkableRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = nonLinkableAttrTypesRSRORecurse
	} else {
		attrs = nonLinkableAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderRestLink(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = restLinkAttrTypesRSRecurse
	} else {
		attrs = restLinkAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderRestLinkRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = restLinkAttrTypesRSRORecurse
	} else {
		attrs = restLinkAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderAuditGroupAuditRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = auditGroupAuditAttrTypesRSRORecurse
	} else {
		attrs = auditGroupAuditAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderAuditGroupAudit_additionalObjectsRO(state, priorState, false).Attributes())
	}
	// Reordering not supported for accounts with type List
	// Reordering not supported for nested_groups with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderAuditGroupAuditAccountRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = auditGroupAuditAccountAttrTypesRSRORecurse
	} else {
		attrs = auditGroupAuditAccountAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderAuditGroupAuditLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = auditGroupAuditLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = auditGroupAuditLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderAuditGroupAudit_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = auditGroupAudit_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = auditGroupAudit_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderAuditNestedGroupAuditRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = auditNestedGroupAuditAttrTypesRSRORecurse
	} else {
		attrs = auditNestedGroupAuditAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderAuthAccountPrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = authAccountPrimerAttrTypesRSRecurse
	} else {
		attrs = authAccountPrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderAuthAccountPrimerRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = authAccountPrimerAttrTypesRSRORecurse
	} else {
		attrs = authAccountPrimerAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderAuthPermission(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = authPermissionAttrTypesRSRecurse
	} else {
		attrs = authPermissionAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderAuthPermissionRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = authPermissionAttrTypesRSRORecurse
	} else {
		attrs = authPermissionAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderCertificateCertificatePrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = certificateCertificatePrimerAttrTypesRSRecurse
	} else {
		attrs = certificateCertificatePrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderCertificateCertificatePrimerRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = certificateCertificatePrimerAttrTypesRSRORecurse
	} else {
		attrs = certificateCertificatePrimerAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientApplicationVaultVaultRecord(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientApplicationVaultVaultRecordAttrTypesRSRecurse
	} else {
		attrs = clientApplicationVaultVaultRecordAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderVaultVaultRecord_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientClientApplication(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientClientApplicationAttrTypesRSRecurse
	} else {
		attrs = clientClientApplicationAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderClientClientApplication_additionalObjects(state, priorState, false).Attributes())
	}
	obj["ldap_client"] = reorderClientLdapClient(state.Attributes()["ldap_client"].(types.Object), priorState.Attributes()["ldap_client"].(types.Object), recurse)
	obj["oauth2_client"] = reorderClientOAuth2Client(state.Attributes()["oauth2_client"].(types.Object), priorState.Attributes()["oauth2_client"].(types.Object), recurse)
	obj["saml2_client"] = reorderClientSaml2Client(state.Attributes()["saml2_client"].(types.Object), priorState.Attributes()["saml2_client"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientClientApplicationRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientClientApplicationAttrTypesRSRORecurse
	} else {
		attrs = clientClientApplicationAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderClientClientApplication_additionalObjectsRO(state, priorState, false).Attributes())
	}
	obj["owner"] = reorderGroupGroupPrimerRO(state.Attributes()["owner"].(types.Object), priorState.Attributes()["owner"].(types.Object), recurse)
	obj["technical_administrator"] = reorderGroupGroupPrimerRO(state.Attributes()["technical_administrator"].(types.Object), priorState.Attributes()["technical_administrator"].(types.Object), recurse)
	obj["ldap_client"] = reorderClientLdapClientRO(state.Attributes()["ldap_client"].(types.Object), priorState.Attributes()["ldap_client"].(types.Object), recurse)
	obj["oauth2_client"] = reorderClientOAuth2ClientRO(state.Attributes()["oauth2_client"].(types.Object), priorState.Attributes()["oauth2_client"].(types.Object), recurse)
	obj["saml2_client"] = reorderClientSaml2ClientRO(state.Attributes()["saml2_client"].(types.Object), priorState.Attributes()["saml2_client"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientClientApplicationLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientClientApplicationLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = clientClientApplicationLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientClientApplicationPrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientClientApplicationPrimerAttrTypesRSRecurse
	} else {
		attrs = clientClientApplicationPrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientClientApplicationPrimerRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientClientApplicationPrimerAttrTypesRSRORecurse
	} else {
		attrs = clientClientApplicationPrimerAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientClientApplication_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientClientApplication_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = clientClientApplication_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	{
		attrState := state.Attributes()["accessprofileclients"]
		attrPriorState := priorState.Attributes()["accessprofileclients"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["accessprofileclients"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{
				"access_profile_uuid",
			}, reorderProfileAccessProfileClient)
			obj["accessprofileclients"] = types.ListValueMust(attrs["accessprofileclients"].(types.ListType).ElemType, newAttrState)
		}
	}
	{
		attrState := state.Attributes()["groupclients"]
		attrPriorState := priorState.Attributes()["groupclients"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["groupclients"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{
				"group_uuid",
				"activation_required",
				"owner_uuid",
				"technical_administrator_uuid",
			}, reorderGroupGroupClient)
			obj["groupclients"] = types.ListValueMust(attrs["groupclients"].(types.ListType).ElemType, newAttrState)
		}
	}
	obj["secret"] = reorderGeneratedSecret(state.Attributes()["secret"].(types.Object), priorState.Attributes()["secret"].(types.Object), recurse)
	obj["tile"] = reorderLaunchpadSsoApplicationLaunchpadTile(state.Attributes()["tile"].(types.Object), priorState.Attributes()["tile"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientClientApplication_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientClientApplication_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = clientClientApplication_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	{
		attrState := state.Attributes()["accessprofileclients"]
		attrPriorState := priorState.Attributes()["accessprofileclients"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["accessprofileclients"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{}, reorderProfileAccessProfileClientRO)
			obj["accessprofileclients"] = types.ListValueMust(attrs["accessprofileclients"].(types.ListType).ElemType, newAttrState)
		}
	}
	{
		attrState := state.Attributes()["groupclients"]
		attrPriorState := priorState.Attributes()["groupclients"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["groupclients"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{
				"activation_required",
			}, reorderGroupGroupClientRO)
			obj["groupclients"] = types.ListValueMust(attrs["groupclients"].(types.ListType).ElemType, newAttrState)
		}
	}
	obj["secret"] = reorderGeneratedSecretRO(state.Attributes()["secret"].(types.Object), priorState.Attributes()["secret"].(types.Object), recurse)
	obj["tile"] = reorderLaunchpadSsoApplicationLaunchpadTileRO(state.Attributes()["tile"].(types.Object), priorState.Attributes()["tile"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientLdapClient(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientLdapClientAttrTypesRSRecurse
	} else {
		attrs = clientLdapClientAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientLdapClientRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientLdapClientAttrTypesRSRORecurse
	} else {
		attrs = clientLdapClientAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["client_certificate"] = reorderCertificateCertificatePrimerRO(state.Attributes()["client_certificate"].(types.Object), priorState.Attributes()["client_certificate"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientOAuth2Client(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientOAuth2ClientAttrTypesRSRecurse
	} else {
		attrs = clientOAuth2ClientAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for attributes with type Map

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientOAuth2ClientRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientOAuth2ClientAttrTypesRSRORecurse
	} else {
		attrs = clientOAuth2ClientAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for attributes with type Map

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientOAuth2ClientPermission(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientOAuth2ClientPermissionAttrTypesRSRecurse
	} else {
		attrs = clientOAuth2ClientPermissionAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderClientOAuth2ClientPermission_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientOAuth2ClientPermissionRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientOAuth2ClientPermissionAttrTypesRSRORecurse
	} else {
		attrs = clientOAuth2ClientPermissionAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderClientOAuth2ClientPermission_additionalObjectsRO(state, priorState, false).Attributes())
	}
	obj["for_group"] = reorderGroupGroupPrimerRO(state.Attributes()["for_group"].(types.Object), priorState.Attributes()["for_group"].(types.Object), recurse)
	obj["for_system"] = reorderProvisioningProvisionedSystemPrimerRO(state.Attributes()["for_system"].(types.Object), priorState.Attributes()["for_system"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientOAuth2ClientPermissionWithClient(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientOAuth2ClientPermissionWithClientAttrTypesRSRecurse
	} else {
		attrs = clientOAuth2ClientPermissionWithClientAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderClientOAuth2ClientPermission_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientOAuth2ClientPermissionWithClientRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientOAuth2ClientPermissionWithClientAttrTypesRSRORecurse
	} else {
		attrs = clientOAuth2ClientPermissionWithClientAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderClientOAuth2ClientPermission_additionalObjectsRO(state, priorState, false).Attributes())
	}
	obj["for_group"] = reorderGroupGroupPrimerRO(state.Attributes()["for_group"].(types.Object), priorState.Attributes()["for_group"].(types.Object), recurse)
	obj["for_system"] = reorderProvisioningProvisionedSystemPrimerRO(state.Attributes()["for_system"].(types.Object), priorState.Attributes()["for_system"].(types.Object), recurse)
	obj["client"] = reorderClientOAuth2ClientRO(state.Attributes()["client"].(types.Object), priorState.Attributes()["client"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientOAuth2ClientPermissionWithClientLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientOAuth2ClientPermissionWithClientLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = clientOAuth2ClientPermissionWithClientLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientOAuth2ClientPermissionWithClientLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientOAuth2ClientPermissionWithClientLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = clientOAuth2ClientPermissionWithClientLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientOAuth2ClientPermission_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientOAuth2ClientPermission_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = clientOAuth2ClientPermission_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientOAuth2ClientPermission_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientOAuth2ClientPermission_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = clientOAuth2ClientPermission_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientSaml2Client(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientSaml2ClientAttrTypesRSRecurse
	} else {
		attrs = clientSaml2ClientAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for attributes with type Map

	return types.ObjectValueMust(attrs, obj)
}

func reorderClientSaml2ClientRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = clientSaml2ClientAttrTypesRSRORecurse
	} else {
		attrs = clientSaml2ClientAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for attributes with type Map

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryAccountDirectoryRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryAccountDirectoryAttrTypesRSRORecurse
	} else {
		attrs = directoryAccountDirectoryAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderDirectoryAccountDirectory_additionalObjectsRO(state, priorState, false).Attributes())
	}
	obj["base_organizational_unit"] = reorderOrganizationOrganizationalUnitPrimerRO(state.Attributes()["base_organizational_unit"].(types.Object), priorState.Attributes()["base_organizational_unit"].(types.Object), recurse)
	obj["helpdesk_group"] = reorderGroupGroupPrimerRO(state.Attributes()["helpdesk_group"].(types.Object), priorState.Attributes()["helpdesk_group"].(types.Object), recurse)
	obj["internal_directory"] = reorderDirectoryInternalDirectoryRO(state.Attributes()["internal_directory"].(types.Object), priorState.Attributes()["internal_directory"].(types.Object), recurse)
	obj["ldap_directory"] = reorderDirectoryLDAPDirectoryRO(state.Attributes()["ldap_directory"].(types.Object), priorState.Attributes()["ldap_directory"].(types.Object), recurse)
	obj["maintenance_directory"] = reorderDirectoryMaintenanceDirectoryRO(state.Attributes()["maintenance_directory"].(types.Object), priorState.Attributes()["maintenance_directory"].(types.Object), recurse)
	obj["oidc_directory"] = reorderDirectoryOIDCDirectoryRO(state.Attributes()["oidc_directory"].(types.Object), priorState.Attributes()["oidc_directory"].(types.Object), recurse)
	obj["pending_accounts_directory"] = reorderDirectoryPendingAccountsDirectoryRO(state.Attributes()["pending_accounts_directory"].(types.Object), priorState.Attributes()["pending_accounts_directory"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryAccountDirectoryLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryAccountDirectoryLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = directoryAccountDirectoryLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryAccountDirectoryPrimerRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryAccountDirectoryPrimerAttrTypesRSRORecurse
	} else {
		attrs = directoryAccountDirectoryPrimerAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryAccountDirectoryStatusReportRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryAccountDirectoryStatusReportAttrTypesRSRORecurse
	} else {
		attrs = directoryAccountDirectoryStatusReportAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryAccountDirectorySummaryRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryAccountDirectorySummaryAttrTypesRSRORecurse
	} else {
		attrs = directoryAccountDirectorySummaryAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["status"] = reorderDirectoryAccountDirectoryStatusReportRO(state.Attributes()["status"].(types.Object), priorState.Attributes()["status"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryAccountDirectorySummaryLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryAccountDirectorySummaryLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = directoryAccountDirectorySummaryLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryAccountDirectory_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryAccountDirectory_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = directoryAccountDirectory_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryInternalDirectoryRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryInternalDirectoryAttrTypesRSRORecurse
	} else {
		attrs = directoryInternalDirectoryAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["owner"] = reorderGroupGroupPrimerRO(state.Attributes()["owner"].(types.Object), priorState.Attributes()["owner"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryLDAPDirectoryRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryLDAPDirectoryAttrTypesRSRORecurse
	} else {
		attrs = directoryLDAPDirectoryAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["client_certificate"] = reorderCertificateCertificatePrimerRO(state.Attributes()["client_certificate"].(types.Object), priorState.Attributes()["client_certificate"].(types.Object), recurse)
	obj["failover_trusted_certificate"] = reorderCertificateCertificatePrimerRO(state.Attributes()["failover_trusted_certificate"].(types.Object), priorState.Attributes()["failover_trusted_certificate"].(types.Object), recurse)
	obj["trusted_certificate"] = reorderCertificateCertificatePrimerRO(state.Attributes()["trusted_certificate"].(types.Object), priorState.Attributes()["trusted_certificate"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryMaintenanceDirectoryRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryMaintenanceDirectoryAttrTypesRSRORecurse
	} else {
		attrs = directoryMaintenanceDirectoryAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryOIDCDirectoryRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryOIDCDirectoryAttrTypesRSRORecurse
	} else {
		attrs = directoryOIDCDirectoryAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderDirectoryPendingAccountsDirectoryRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = directoryPendingAccountsDirectoryAttrTypesRSRORecurse
	} else {
		attrs = directoryPendingAccountsDirectoryAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroup(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupAttrTypesRSRecurse
	} else {
		attrs = groupGroupAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderGroupGroup_additionalObjects(state, priorState, false).Attributes())
	}
	obj["audit_config"] = reorderGroupGroupAuditConfig(state.Attributes()["audit_config"].(types.Object), priorState.Attributes()["audit_config"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupAttrTypesRSRORecurse
	} else {
		attrs = groupGroupAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderGroupGroup_additionalObjectsRO(state, priorState, false).Attributes())
	}
	obj["organizational_unit"] = reorderOrganizationOrganizationalUnitPrimerRO(state.Attributes()["organizational_unit"].(types.Object), priorState.Attributes()["organizational_unit"].(types.Object), recurse)
	obj["audit_config"] = reorderGroupGroupAuditConfigRO(state.Attributes()["audit_config"].(types.Object), priorState.Attributes()["audit_config"].(types.Object), recurse)
	obj["authorizing_group_auditing"] = reorderGroupGroupPrimerRO(state.Attributes()["authorizing_group_auditing"].(types.Object), priorState.Attributes()["authorizing_group_auditing"].(types.Object), recurse)
	obj["authorizing_group_delegation"] = reorderGroupGroupPrimerRO(state.Attributes()["authorizing_group_delegation"].(types.Object), priorState.Attributes()["authorizing_group_delegation"].(types.Object), recurse)
	obj["authorizing_group_membership"] = reorderGroupGroupPrimerRO(state.Attributes()["authorizing_group_membership"].(types.Object), priorState.Attributes()["authorizing_group_membership"].(types.Object), recurse)
	obj["authorizing_group_provisioning"] = reorderGroupGroupPrimerRO(state.Attributes()["authorizing_group_provisioning"].(types.Object), priorState.Attributes()["authorizing_group_provisioning"].(types.Object), recurse)
	obj["classification"] = reorderGroupGroupClassificationPrimerRO(state.Attributes()["classification"].(types.Object), priorState.Attributes()["classification"].(types.Object), recurse)
	obj["nested_under"] = reorderGroupGroupPrimerRO(state.Attributes()["nested_under"].(types.Object), priorState.Attributes()["nested_under"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupAccessInfoRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupAccessInfoAttrTypesRSRORecurse
	} else {
		attrs = groupGroupAccessInfoAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupAccount(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupAccountAttrTypesRSRecurse
	} else {
		attrs = groupGroupAccountAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderGroupGroupAccount_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupAccountRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupAccountAttrTypesRSRORecurse
	} else {
		attrs = groupGroupAccountAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderGroupGroupAccount_additionalObjectsRO(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupAccountLinkableWrapper(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupAccountLinkableWrapperAttrTypesRSRecurse
	} else {
		attrs = groupGroupAccountLinkableWrapperAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupAccountLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupAccountLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = groupGroupAccountLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupAccount_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupAccount_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = groupGroupAccount_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupAccount_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupAccount_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = groupGroupAccount_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupAuditConfig(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupAuditConfigAttrTypesRSRecurse
	} else {
		attrs = groupGroupAuditConfigAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupAuditConfigRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupAuditConfigAttrTypesRSRORecurse
	} else {
		attrs = groupGroupAuditConfigAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupAuditingInfoRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupAuditingInfoAttrTypesRSRORecurse
	} else {
		attrs = groupGroupAuditingInfoAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupClassificationPrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupClassificationPrimerAttrTypesRSRecurse
	} else {
		attrs = groupGroupClassificationPrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupClassificationPrimerRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupClassificationPrimerAttrTypesRSRORecurse
	} else {
		attrs = groupGroupClassificationPrimerAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupClient(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupClientAttrTypesRSRecurse
	} else {
		attrs = groupGroupClientAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderGroupGroupClient_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupClientRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupClientAttrTypesRSRORecurse
	} else {
		attrs = groupGroupClientAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderGroupGroupClient_additionalObjectsRO(state, priorState, false).Attributes())
	}
	obj["group"] = reorderGroupGroupPrimerRO(state.Attributes()["group"].(types.Object), priorState.Attributes()["group"].(types.Object), recurse)
	obj["owner"] = reorderGroupGroupPrimerRO(state.Attributes()["owner"].(types.Object), priorState.Attributes()["owner"].(types.Object), recurse)
	obj["technical_administrator"] = reorderGroupGroupPrimerRO(state.Attributes()["technical_administrator"].(types.Object), priorState.Attributes()["technical_administrator"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupClientLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupClientLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = groupGroupClientLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupClientLinkableWrapperWithCount(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupClientLinkableWrapperWithCountAttrTypesRSRecurse
	} else {
		attrs = groupGroupClientLinkableWrapperWithCountAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupClientLinkableWrapperWithCountRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupClientLinkableWrapperWithCountAttrTypesRSRORecurse
	} else {
		attrs = groupGroupClientLinkableWrapperWithCountAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupClient_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupClient_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = groupGroupClient_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupClient_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupClient_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = groupGroupClient_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupGlobalRoleInfoRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupGlobalRoleInfoAttrTypesRSRORecurse
	} else {
		attrs = groupGroupGlobalRoleInfoAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for auditor_group_for with type List
	// Reordering not supported for create_group_approve_group_for with type List
	// Reordering not supported for enable_tech_admin_approve_group_for with type List
	// Reordering not supported for recovery_fallback_group_for with type List
	// Reordering not supported for remove_group_approve_group_for with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupInfoRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupInfoAttrTypesRSRORecurse
	} else {
		attrs = groupGroupInfoAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = groupGroupLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupLinkableWrapperWithCountRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupLinkableWrapperWithCountAttrTypesRSRORecurse
	} else {
		attrs = groupGroupLinkableWrapperWithCountAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupPrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupPrimerAttrTypesRSRecurse
	} else {
		attrs = groupGroupPrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupPrimerRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupPrimerAttrTypesRSRORecurse
	} else {
		attrs = groupGroupPrimerAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["organizational_unit"] = reorderOrganizationOrganizationalUnitPrimerRO(state.Attributes()["organizational_unit"].(types.Object), priorState.Attributes()["organizational_unit"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroupPrimerLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroupPrimerLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = groupGroupPrimerLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroup_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroup_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = groupGroup_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	{
		attrState := state.Attributes()["accounts"]
		attrPriorState := priorState.Attributes()["accounts"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["accounts"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{
				"uuid",
				"rights",
				"end_date",
			}, reorderGroupGroupAccount)
			obj["accounts"] = types.ListValueMust(attrs["accounts"].(types.ListType).ElemType, newAttrState)
		}
	}
	{
		attrState := state.Attributes()["admins"]
		attrPriorState := priorState.Attributes()["admins"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["admins"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{
				"uuid",
				"rights",
				"end_date",
			}, reorderGroupGroupAccount)
			obj["admins"] = types.ListValueMust(attrs["admins"].(types.ListType).ElemType, newAttrState)
		}
	}
	{
		attrState := state.Attributes()["client_permissions"]
		attrPriorState := priorState.Attributes()["client_permissions"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["client_permissions"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{
				"value",
				"for_group_uuid",
				"for_system_uuid",
				"client_uuid",
			}, reorderClientOAuth2ClientPermissionWithClient)
			obj["client_permissions"] = types.ListValueMust(attrs["client_permissions"].(types.ListType).ElemType, newAttrState)
		}
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupGroup_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupGroup_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = groupGroup_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	{
		attrState := state.Attributes()["accounts"]
		attrPriorState := priorState.Attributes()["accounts"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["accounts"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{
				"uuid",
				"rights",
				"end_date",
			}, reorderGroupGroupAccountRO)
			obj["accounts"] = types.ListValueMust(attrs["accounts"].(types.ListType).ElemType, newAttrState)
		}
	}
	{
		attrState := state.Attributes()["admins"]
		attrPriorState := priorState.Attributes()["admins"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["admins"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{
				"uuid",
				"rights",
				"end_date",
			}, reorderGroupGroupAccountRO)
			obj["admins"] = types.ListValueMust(attrs["admins"].(types.ListType).ElemType, newAttrState)
		}
	}
	{
		attrState := state.Attributes()["client_permissions"]
		attrPriorState := priorState.Attributes()["client_permissions"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["client_permissions"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{
				"value",
			}, reorderClientOAuth2ClientPermissionWithClientRO)
			obj["client_permissions"] = types.ListValueMust(attrs["client_permissions"].(types.ListType).ElemType, newAttrState)
		}
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupProvisioningGroup(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupProvisioningGroupAttrTypesRSRecurse
	} else {
		attrs = groupProvisioningGroupAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderGroupProvisioningGroup_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupProvisioningGroupRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupProvisioningGroupAttrTypesRSRORecurse
	} else {
		attrs = groupProvisioningGroupAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderGroupProvisioningGroup_additionalObjectsRO(state, priorState, false).Attributes())
	}
	obj["group"] = reorderGroupGroupPrimerRO(state.Attributes()["group"].(types.Object), priorState.Attributes()["group"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupProvisioningGroupLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupProvisioningGroupLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = groupProvisioningGroupLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupProvisioningGroupLinkableWrapperWithCount(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupProvisioningGroupLinkableWrapperWithCountAttrTypesRSRecurse
	} else {
		attrs = groupProvisioningGroupLinkableWrapperWithCountAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupProvisioningGroupLinkableWrapperWithCountRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupProvisioningGroupLinkableWrapperWithCountAttrTypesRSRORecurse
	} else {
		attrs = groupProvisioningGroupLinkableWrapperWithCountAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupProvisioningGroup_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupProvisioningGroup_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = groupProvisioningGroup_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupProvisioningGroup_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupProvisioningGroup_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = groupProvisioningGroup_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderGroupVaultVaultRecord(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = groupVaultVaultRecordAttrTypesRSRecurse
	} else {
		attrs = groupVaultVaultRecordAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderVaultVaultRecord_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderIdentityAccountAttributeDefinitionRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = identityAccountAttributeDefinitionAttrTypesRSRORecurse
	} else {
		attrs = identityAccountAttributeDefinitionAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderIdentityAccountAttributeDefinition_additionalObjectsRO(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderIdentityAccountAttributeDefinition_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = identityAccountAttributeDefinition_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = identityAccountAttributeDefinition_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderIdentityAccountAttributeRuleRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = identityAccountAttributeRuleAttrTypesRSRORecurse
	} else {
		attrs = identityAccountAttributeRuleAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderIdentityAccountAttributeRule_additionalObjectsRO(state, priorState, false).Attributes())
	}
	obj["attribute"] = reorderIdentityAccountAttributeDefinitionRO(state.Attributes()["attribute"].(types.Object), priorState.Attributes()["attribute"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderIdentityAccountAttributeRuleLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = identityAccountAttributeRuleLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = identityAccountAttributeRuleLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderIdentityAccountAttributeRule_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = identityAccountAttributeRule_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = identityAccountAttributeRule_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderIdentityAccountAttributeValueSummaryRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = identityAccountAttributeValueSummaryAttrTypesRSRORecurse
	} else {
		attrs = identityAccountAttributeValueSummaryAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["attribute"] = reorderIdentityAccountAttributeDefinitionRO(state.Attributes()["attribute"].(types.Object), priorState.Attributes()["attribute"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderLaunchpadSsoApplicationLaunchpadTile(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = launchpadSsoApplicationLaunchpadTileAttrTypesRSRecurse
	} else {
		attrs = launchpadSsoApplicationLaunchpadTileAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderLaunchpadSsoApplicationLaunchpadTileRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = launchpadSsoApplicationLaunchpadTileAttrTypesRSRORecurse
	} else {
		attrs = launchpadSsoApplicationLaunchpadTileAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderLaunchpadVaultRecordLaunchpadTile(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = launchpadVaultRecordLaunchpadTileAttrTypesRSRecurse
	} else {
		attrs = launchpadVaultRecordLaunchpadTileAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderLaunchpadVaultRecordLaunchpadTileRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = launchpadVaultRecordLaunchpadTileAttrTypesRSRORecurse
	} else {
		attrs = launchpadVaultRecordLaunchpadTileAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderMarkItemMarkerRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = markItemMarkerAttrTypesRSRORecurse
	} else {
		attrs = markItemMarkerAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderMarkItemMarkersRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = markItemMarkersAttrTypesRSRORecurse
	} else {
		attrs = markItemMarkersAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for markers with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderMiscAttributeCustomizationRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = miscAttributeCustomizationAttrTypesRSRORecurse
	} else {
		attrs = miscAttributeCustomizationAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["attribute_definition"] = reorderIdentityAccountAttributeDefinitionRO(state.Attributes()["attribute_definition"].(types.Object), priorState.Attributes()["attribute_definition"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderNestedProvisioningGroupOnSystem(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = nestedProvisioningGroupOnSystemAttrTypesRSRecurse
	} else {
		attrs = nestedProvisioningGroupOnSystemAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProvisioningGroupOnSystem_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderOrganizationClientApplicationOrganizationalUnitRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = organizationClientApplicationOrganizationalUnitAttrTypesRSRORecurse
	} else {
		attrs = organizationClientApplicationOrganizationalUnitAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderOrganizationClientApplicationOrganizationalUnitLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = organizationClientApplicationOrganizationalUnitLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = organizationClientApplicationOrganizationalUnitLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderOrganizationOrganizationalUnitRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = organizationOrganizationalUnitAttrTypesRSRORecurse
	} else {
		attrs = organizationOrganizationalUnitAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderOrganizationOrganizationalUnit_additionalObjectsRO(state, priorState, false).Attributes())
	}
	obj["auditor_group"] = reorderGroupGroupPrimerRO(state.Attributes()["auditor_group"].(types.Object), priorState.Attributes()["auditor_group"].(types.Object), recurse)
	obj["create_group_approve_group"] = reorderGroupGroupPrimerRO(state.Attributes()["create_group_approve_group"].(types.Object), priorState.Attributes()["create_group_approve_group"].(types.Object), recurse)
	obj["enable_tech_admin_approve_group"] = reorderGroupGroupPrimerRO(state.Attributes()["enable_tech_admin_approve_group"].(types.Object), priorState.Attributes()["enable_tech_admin_approve_group"].(types.Object), recurse)
	obj["owner"] = reorderGroupGroupPrimerRO(state.Attributes()["owner"].(types.Object), priorState.Attributes()["owner"].(types.Object), recurse)
	obj["recovery_fallback_group"] = reorderGroupGroupPrimerRO(state.Attributes()["recovery_fallback_group"].(types.Object), priorState.Attributes()["recovery_fallback_group"].(types.Object), recurse)
	obj["remove_group_approve_group"] = reorderGroupGroupPrimerRO(state.Attributes()["remove_group_approve_group"].(types.Object), priorState.Attributes()["remove_group_approve_group"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderOrganizationOrganizationalUnitLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = organizationOrganizationalUnitLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = organizationOrganizationalUnitLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderOrganizationOrganizationalUnitPrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = organizationOrganizationalUnitPrimerAttrTypesRSRecurse
	} else {
		attrs = organizationOrganizationalUnitPrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderOrganizationOrganizationalUnitPrimerRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = organizationOrganizationalUnitPrimerAttrTypesRSRORecurse
	} else {
		attrs = organizationOrganizationalUnitPrimerAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderOrganizationOrganizationalUnitPrimerLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = organizationOrganizationalUnitPrimerLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = organizationOrganizationalUnitPrimerLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderOrganizationOrganizationalUnitSettingsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = organizationOrganizationalUnitSettingsAttrTypesRSRORecurse
	} else {
		attrs = organizationOrganizationalUnitSettingsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["create_group_approve_group"] = reorderGroupGroupPrimerRO(state.Attributes()["create_group_approve_group"].(types.Object), priorState.Attributes()["create_group_approve_group"].(types.Object), recurse)
	obj["enable_tech_admin_approve_group"] = reorderGroupGroupPrimerRO(state.Attributes()["enable_tech_admin_approve_group"].(types.Object), priorState.Attributes()["enable_tech_admin_approve_group"].(types.Object), recurse)
	obj["recovery_fallback_group"] = reorderGroupGroupPrimerRO(state.Attributes()["recovery_fallback_group"].(types.Object), priorState.Attributes()["recovery_fallback_group"].(types.Object), recurse)
	obj["remove_group_approve_group"] = reorderGroupGroupPrimerRO(state.Attributes()["remove_group_approve_group"].(types.Object), priorState.Attributes()["remove_group_approve_group"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderOrganizationOrganizationalUnit_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = organizationOrganizationalUnit_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = organizationOrganizationalUnit_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	{
		attrState := state.Attributes()["create_as_parent_of"]
		attrPriorState := priorState.Attributes()["create_as_parent_of"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["create_as_parent_of"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{
				"name",
			}, reorderOrganizationOrganizationalUnitPrimerRO)
			obj["create_as_parent_of"] = types.ListValueMust(attrs["create_as_parent_of"].(types.ListType).ElemType, newAttrState)
		}
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileAttrTypesRSRORecurse
	} else {
		attrs = profileAccessProfileAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProfileAccessProfile_additionalObjectsRO(state, priorState, false).Attributes())
	}
	obj["directory"] = reorderDirectoryAccountDirectoryPrimerRO(state.Attributes()["directory"].(types.Object), priorState.Attributes()["directory"].(types.Object), recurse)
	obj["owner"] = reorderGroupGroupPrimerRO(state.Attributes()["owner"].(types.Object), priorState.Attributes()["owner"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileAccountRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileAccountAttrTypesRSRORecurse
	} else {
		attrs = profileAccessProfileAccountAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProfileAccessProfileAccount_additionalObjectsRO(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileAccountWithAttributesRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileAccountWithAttributesAttrTypesRSRORecurse
	} else {
		attrs = profileAccessProfileAccountWithAttributesAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProfileAccessProfileAccount_additionalObjectsRO(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileAccountWithAttributesLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileAccountWithAttributesLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = profileAccessProfileAccountWithAttributesLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileAccount_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileAccount_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = profileAccessProfileAccount_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileClient(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileClientAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileClientAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProfileAccessProfileClient_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileClientRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileClientAttrTypesRSRORecurse
	} else {
		attrs = profileAccessProfileClientAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProfileAccessProfileClient_additionalObjectsRO(state, priorState, false).Attributes())
	}
	obj["access_profile"] = reorderProfileAccessProfilePrimerRO(state.Attributes()["access_profile"].(types.Object), priorState.Attributes()["access_profile"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileClientLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileClientLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = profileAccessProfileClientLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileClientLinkableWrapperWithCount(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileClientLinkableWrapperWithCountAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileClientLinkableWrapperWithCountAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileClientLinkableWrapperWithCountRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileClientLinkableWrapperWithCountAttrTypesRSRORecurse
	} else {
		attrs = profileAccessProfileClientLinkableWrapperWithCountAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileClient_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileClient_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileClient_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileClient_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileClient_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = profileAccessProfileClient_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileGroupRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileGroupAttrTypesRSRORecurse
	} else {
		attrs = profileAccessProfileGroupAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProfileAccessProfileGroup_additionalObjectsRO(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileGroupLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileGroupLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = profileAccessProfileGroupLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileGroup_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileGroup_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = profileAccessProfileGroup_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = profileAccessProfileLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfilePrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfilePrimerAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfilePrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfilePrimerRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfilePrimerAttrTypesRSRORecurse
	} else {
		attrs = profileAccessProfilePrimerAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileProvisioning(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileProvisioningAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileProvisioningAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProfileAccessProfileProvisioning_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileProvisioningRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileProvisioningAttrTypesRSRORecurse
	} else {
		attrs = profileAccessProfileProvisioningAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProfileAccessProfileProvisioning_additionalObjectsRO(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileProvisioningLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileProvisioningLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = profileAccessProfileProvisioningLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileProvisioningLinkableWrapperWithCount(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileProvisioningLinkableWrapperWithCountAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileProvisioningLinkableWrapperWithCountAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileProvisioningLinkableWrapperWithCountRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileProvisioningLinkableWrapperWithCountAttrTypesRSRORecurse
	} else {
		attrs = profileAccessProfileProvisioningLinkableWrapperWithCountAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileProvisioning_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileProvisioning_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = profileAccessProfileProvisioning_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfileProvisioning_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfileProvisioning_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = profileAccessProfileProvisioning_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProfileAccessProfile_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = profileAccessProfile_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = profileAccessProfile_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningAbstractProvisionedLDAPRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningAbstractProvisionedLDAPAttrTypesRSRORecurse
	} else {
		attrs = provisioningAbstractProvisionedLDAPAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for attributes with type List
	obj["client_certificate"] = reorderCertificateCertificatePrimerRO(state.Attributes()["client_certificate"].(types.Object), priorState.Attributes()["client_certificate"].(types.Object), recurse)
	obj["failover_trusted_certificate"] = reorderCertificateCertificatePrimerRO(state.Attributes()["failover_trusted_certificate"].(types.Object), priorState.Attributes()["failover_trusted_certificate"].(types.Object), recurse)
	obj["trusted_certificate"] = reorderCertificateCertificatePrimerRO(state.Attributes()["trusted_certificate"].(types.Object), priorState.Attributes()["trusted_certificate"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningCircuitBreakerStatisticsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningCircuitBreakerStatisticsAttrTypesRSRORecurse
	} else {
		attrs = provisioningCircuitBreakerStatisticsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningGroupOnSystemRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningGroupOnSystemAttrTypesRSRORecurse
	} else {
		attrs = provisioningGroupOnSystemAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProvisioningGroupOnSystem_additionalObjectsRO(state, priorState, false).Attributes())
	}
	obj["owner"] = reorderGroupGroupPrimerRO(state.Attributes()["owner"].(types.Object), priorState.Attributes()["owner"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningGroupOnSystemLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningGroupOnSystemLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = provisioningGroupOnSystemLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningGroupOnSystemPrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningGroupOnSystemPrimerAttrTypesRSRecurse
	} else {
		attrs = provisioningGroupOnSystemPrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningGroupOnSystemPrimerRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningGroupOnSystemPrimerAttrTypesRSRORecurse
	} else {
		attrs = provisioningGroupOnSystemPrimerAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningGroupOnSystemTypesRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningGroupOnSystemTypesAttrTypesRSRORecurse
	} else {
		attrs = provisioningGroupOnSystemTypesAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningGroupOnSystem_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningGroupOnSystem_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = provisioningGroupOnSystem_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	{
		attrState := state.Attributes()["access_profile_provisioning"]
		attrPriorState := priorState.Attributes()["access_profile_provisioning"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["access_profile_provisioning"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{}, reorderProfileAccessProfileProvisioning)
			obj["access_profile_provisioning"] = types.ListValueMust(attrs["access_profile_provisioning"].(types.ListType).ElemType, newAttrState)
		}
	}
	{
		attrState := state.Attributes()["provgroups"]
		attrPriorState := priorState.Attributes()["provgroups"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["provgroups"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{
				"group_uuid",
				"activation_required",
			}, reorderGroupProvisioningGroup)
			obj["provgroups"] = types.ListValueMust(attrs["provgroups"].(types.ListType).ElemType, newAttrState)
		}
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningGroupOnSystem_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningGroupOnSystem_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = provisioningGroupOnSystem_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	{
		attrState := state.Attributes()["access_profile_provisioning"]
		attrPriorState := priorState.Attributes()["access_profile_provisioning"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["access_profile_provisioning"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{}, reorderProfileAccessProfileProvisioningRO)
			obj["access_profile_provisioning"] = types.ListValueMust(attrs["access_profile_provisioning"].(types.ListType).ElemType, newAttrState)
		}
	}
	{
		attrState := state.Attributes()["provgroups"]
		attrPriorState := priorState.Attributes()["provgroups"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["provgroups"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{
				"activation_required",
			}, reorderGroupProvisioningGroupRO)
			obj["provgroups"] = types.ListValueMust(attrs["provgroups"].(types.ListType).ElemType, newAttrState)
		}
	}
	{
		attrState := state.Attributes()["service_accounts"]
		attrPriorState := priorState.Attributes()["service_accounts"]
		if attrState.IsNull() || attrState.IsUnknown() || attrPriorState.IsNull() || attrPriorState.IsUnknown() {
			obj["service_accounts"] = attrState
		} else {
			attrStateEl := (attrState.(types.List)).Elements()
			attrPriorStateEl := (attrPriorState.(types.List)).Elements()
			newAttrState := reorderList(attrStateEl, attrPriorStateEl, recurse, []string{
				"name",
				"username",
				"active",
			}, reorderServiceaccountServiceAccountPrimerRO)
			obj["service_accounts"] = types.ListValueMust(attrs["service_accounts"].(types.ListType).ElemType, newAttrState)
		}
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningOwnedGroupOnSystemsWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningOwnedGroupOnSystemsWrapperAttrTypesRSRORecurse
	} else {
		attrs = provisioningOwnedGroupOnSystemsWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionNumberSequenceRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionNumberSequenceAttrTypesRSRORecurse
	} else {
		attrs = provisioningProvisionNumberSequenceAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProvisioningProvisionNumberSequence_additionalObjectsRO(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionNumberSequence_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionNumberSequence_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = provisioningProvisionNumberSequence_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedADRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedADAttrTypesRSRORecurse
	} else {
		attrs = provisioningProvisionedADAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedAccountRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedAccountAttrTypesRSRORecurse
	} else {
		attrs = provisioningProvisionedAccountAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProvisioningProvisionedAccount_additionalObjectsRO(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedAccount_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedAccount_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = provisioningProvisionedAccount_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedAzureOIDCDirectoryRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedAzureOIDCDirectoryAttrTypesRSRORecurse
	} else {
		attrs = provisioningProvisionedAzureOIDCDirectoryAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["directory"] = reorderDirectoryAccountDirectoryPrimerRO(state.Attributes()["directory"].(types.Object), priorState.Attributes()["directory"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedAzureSyncLDAPDirectoryRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedAzureSyncLDAPDirectoryAttrTypesRSRORecurse
	} else {
		attrs = provisioningProvisionedAzureSyncLDAPDirectoryAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["directory"] = reorderDirectoryAccountDirectoryPrimerRO(state.Attributes()["directory"].(types.Object), priorState.Attributes()["directory"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedAzureTenantRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedAzureTenantAttrTypesRSRORecurse
	} else {
		attrs = provisioningProvisionedAzureTenantAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedInternalLDAPRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedInternalLDAPAttrTypesRSRORecurse
	} else {
		attrs = provisioningProvisionedInternalLDAPAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["client"] = reorderClientLdapClientRO(state.Attributes()["client"].(types.Object), priorState.Attributes()["client"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedLDAPRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedLDAPAttrTypesRSRORecurse
	} else {
		attrs = provisioningProvisionedLDAPAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["gid_numbering"] = reorderProvisioningProvisionNumberSequenceRO(state.Attributes()["gid_numbering"].(types.Object), priorState.Attributes()["gid_numbering"].(types.Object), recurse)
	obj["numbering"] = reorderProvisioningProvisionNumberSequenceRO(state.Attributes()["numbering"].(types.Object), priorState.Attributes()["numbering"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedLDAPDirectoryRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedLDAPDirectoryAttrTypesRSRORecurse
	} else {
		attrs = provisioningProvisionedLDAPDirectoryAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for attributes with type List
	obj["directory"] = reorderDirectoryAccountDirectoryPrimerRO(state.Attributes()["directory"].(types.Object), priorState.Attributes()["directory"].(types.Object), recurse)
	obj["gid_numbering"] = reorderProvisioningProvisionNumberSequenceRO(state.Attributes()["gid_numbering"].(types.Object), priorState.Attributes()["gid_numbering"].(types.Object), recurse)
	obj["numbering"] = reorderProvisioningProvisionNumberSequenceRO(state.Attributes()["numbering"].(types.Object), priorState.Attributes()["numbering"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedNamespaceRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedNamespaceAttrTypesRSRORecurse
	} else {
		attrs = provisioningProvisionedNamespaceAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["base_system"] = reorderProvisioningProvisionedSystemPrimerRO(state.Attributes()["base_system"].(types.Object), priorState.Attributes()["base_system"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedSCIMRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedSCIMAttrTypesRSRORecurse
	} else {
		attrs = provisioningProvisionedSCIMAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for attributes with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedSystemRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedSystemAttrTypesRSRORecurse
	} else {
		attrs = provisioningProvisionedSystemAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderProvisioningProvisionedSystem_additionalObjectsRO(state, priorState, false).Attributes())
	}
	obj["organizational_unit"] = reorderOrganizationOrganizationalUnitPrimerRO(state.Attributes()["organizational_unit"].(types.Object), priorState.Attributes()["organizational_unit"].(types.Object), recurse)
	obj["cleanup_period"] = reorderProvisioningProvisionedSystem_cleanupPeriodRO(state.Attributes()["cleanup_period"].(types.Object), priorState.Attributes()["cleanup_period"].(types.Object), recurse)
	obj["content_administrator"] = reorderGroupGroupPrimerRO(state.Attributes()["content_administrator"].(types.Object), priorState.Attributes()["content_administrator"].(types.Object), recurse)
	obj["owner"] = reorderGroupGroupPrimerRO(state.Attributes()["owner"].(types.Object), priorState.Attributes()["owner"].(types.Object), recurse)
	obj["technical_administrator"] = reorderGroupGroupPrimerRO(state.Attributes()["technical_administrator"].(types.Object), priorState.Attributes()["technical_administrator"].(types.Object), recurse)
	obj["abstract_provisioned_ldap"] = reorderProvisioningAbstractProvisionedLDAPRO(state.Attributes()["abstract_provisioned_ldap"].(types.Object), priorState.Attributes()["abstract_provisioned_ldap"].(types.Object), recurse)
	obj["provisioned_a_d"] = reorderProvisioningProvisionedADRO(state.Attributes()["provisioned_a_d"].(types.Object), priorState.Attributes()["provisioned_a_d"].(types.Object), recurse)
	obj["provisioned_azure_oidc_directory"] = reorderProvisioningProvisionedAzureOIDCDirectoryRO(state.Attributes()["provisioned_azure_oidc_directory"].(types.Object), priorState.Attributes()["provisioned_azure_oidc_directory"].(types.Object), recurse)
	obj["provisioned_azure_sync_ldap_directory"] = reorderProvisioningProvisionedAzureSyncLDAPDirectoryRO(state.Attributes()["provisioned_azure_sync_ldap_directory"].(types.Object), priorState.Attributes()["provisioned_azure_sync_ldap_directory"].(types.Object), recurse)
	obj["provisioned_azure_tenant"] = reorderProvisioningProvisionedAzureTenantRO(state.Attributes()["provisioned_azure_tenant"].(types.Object), priorState.Attributes()["provisioned_azure_tenant"].(types.Object), recurse)
	obj["provisioned_internal_ldap"] = reorderProvisioningProvisionedInternalLDAPRO(state.Attributes()["provisioned_internal_ldap"].(types.Object), priorState.Attributes()["provisioned_internal_ldap"].(types.Object), recurse)
	obj["provisioned_ldap"] = reorderProvisioningProvisionedLDAPRO(state.Attributes()["provisioned_ldap"].(types.Object), priorState.Attributes()["provisioned_ldap"].(types.Object), recurse)
	obj["provisioned_ldap_directory"] = reorderProvisioningProvisionedLDAPDirectoryRO(state.Attributes()["provisioned_ldap_directory"].(types.Object), priorState.Attributes()["provisioned_ldap_directory"].(types.Object), recurse)
	obj["provisioned_namespace"] = reorderProvisioningProvisionedNamespaceRO(state.Attributes()["provisioned_namespace"].(types.Object), priorState.Attributes()["provisioned_namespace"].(types.Object), recurse)
	obj["provisioned_scim"] = reorderProvisioningProvisionedSCIMRO(state.Attributes()["provisioned_scim"].(types.Object), priorState.Attributes()["provisioned_scim"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedSystemLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedSystemLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = provisioningProvisionedSystemLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedSystemPrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedSystemPrimerAttrTypesRSRecurse
	} else {
		attrs = provisioningProvisionedSystemPrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedSystemPrimerRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedSystemPrimerAttrTypesRSRORecurse
	} else {
		attrs = provisioningProvisionedSystemPrimerAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["organizational_unit"] = reorderOrganizationOrganizationalUnitPrimerRO(state.Attributes()["organizational_unit"].(types.Object), priorState.Attributes()["organizational_unit"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedSystemPrimerLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedSystemPrimerLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = provisioningProvisionedSystemPrimerLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedSystem_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedSystem_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = provisioningProvisionedSystem_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisionedSystem_cleanupPeriodRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisionedSystem_cleanupPeriodAttrTypesRSRORecurse
	} else {
		attrs = provisioningProvisionedSystem_cleanupPeriodAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderProvisioningProvisioningManagementPermissionsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = provisioningProvisioningManagementPermissionsAttrTypesRSRORecurse
	} else {
		attrs = provisioningProvisioningManagementPermissionsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderServiceaccountServiceAccount(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = serviceaccountServiceAccountAttrTypesRSRecurse
	} else {
		attrs = serviceaccountServiceAccountAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderServiceaccountServiceAccount_additionalObjects(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderServiceaccountServiceAccountRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = serviceaccountServiceAccountAttrTypesRSRORecurse
	} else {
		attrs = serviceaccountServiceAccountAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderServiceaccountServiceAccount_additionalObjectsRO(state, priorState, false).Attributes())
	}
	obj["system"] = reorderProvisioningProvisionedSystemPrimerRO(state.Attributes()["system"].(types.Object), priorState.Attributes()["system"].(types.Object), recurse)
	obj["technical_administrator"] = reorderGroupGroupPrimerRO(state.Attributes()["technical_administrator"].(types.Object), priorState.Attributes()["technical_administrator"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderServiceaccountServiceAccountGroupRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = serviceaccountServiceAccountGroupAttrTypesRSRORecurse
	} else {
		attrs = serviceaccountServiceAccountGroupAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderServiceaccountServiceAccountGroup_additionalObjectsRO(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderServiceaccountServiceAccountGroupLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = serviceaccountServiceAccountGroupLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = serviceaccountServiceAccountGroupLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderServiceaccountServiceAccountGroup_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = serviceaccountServiceAccountGroup_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = serviceaccountServiceAccountGroup_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderServiceaccountServiceAccountLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = serviceaccountServiceAccountLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = serviceaccountServiceAccountLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderServiceaccountServiceAccountPrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = serviceaccountServiceAccountPrimerAttrTypesRSRecurse
	} else {
		attrs = serviceaccountServiceAccountPrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderServiceaccountServiceAccountPrimerRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = serviceaccountServiceAccountPrimerAttrTypesRSRORecurse
	} else {
		attrs = serviceaccountServiceAccountPrimerAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["system"] = reorderProvisioningProvisionedSystemPrimerRO(state.Attributes()["system"].(types.Object), priorState.Attributes()["system"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderServiceaccountServiceAccountPrimerLinkableWrapperWithCount(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = serviceaccountServiceAccountPrimerLinkableWrapperWithCountAttrTypesRSRecurse
	} else {
		attrs = serviceaccountServiceAccountPrimerLinkableWrapperWithCountAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderServiceaccountServiceAccountPrimerLinkableWrapperWithCountRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = serviceaccountServiceAccountPrimerLinkableWrapperWithCountAttrTypesRSRORecurse
	} else {
		attrs = serviceaccountServiceAccountPrimerLinkableWrapperWithCountAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderServiceaccountServiceAccountSupportedFeaturesRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = serviceaccountServiceAccountSupportedFeaturesAttrTypesRSRORecurse
	} else {
		attrs = serviceaccountServiceAccountSupportedFeaturesAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderServiceaccountServiceAccount_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = serviceaccountServiceAccount_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = serviceaccountServiceAccount_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["secret"] = reorderGeneratedSecret(state.Attributes()["secret"].(types.Object), priorState.Attributes()["secret"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderServiceaccountServiceAccount_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = serviceaccountServiceAccount_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = serviceaccountServiceAccount_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["secret"] = reorderGeneratedSecretRO(state.Attributes()["secret"].(types.Object), priorState.Attributes()["secret"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultPasswordMetadataRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultPasswordMetadataAttrTypesRSRORecurse
	} else {
		attrs = vaultPasswordMetadataAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultVaultRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultVaultAttrTypesRSRORecurse
	} else {
		attrs = vaultVaultAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for records with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultVaultActivationStatusRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultVaultActivationStatusAttrTypesRSRORecurse
	} else {
		attrs = vaultVaultActivationStatusAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultVaultRecordRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultVaultRecordAttrTypesRSRORecurse
	} else {
		attrs = vaultVaultRecordAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderVaultVaultRecord_additionalObjectsRO(state, priorState, false).Attributes())
	}

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultVaultRecordPrimer(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultVaultRecordPrimerAttrTypesRSRecurse
	} else {
		attrs = vaultVaultRecordPrimerAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultVaultRecordPrimerRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultVaultRecordPrimerAttrTypesRSRORecurse
	} else {
		attrs = vaultVaultRecordPrimerAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultVaultRecordPrimerLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultVaultRecordPrimerLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = vaultVaultRecordPrimerLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultVaultRecordSecrets(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultVaultRecordSecretsAttrTypesRSRecurse
	} else {
		attrs = vaultVaultRecordSecretsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultVaultRecordSecretsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultVaultRecordSecretsAttrTypesRSRORecurse
	} else {
		attrs = vaultVaultRecordSecretsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultVaultRecordShareRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultVaultRecordShareAttrTypesRSRORecurse
	} else {
		attrs = vaultVaultRecordShareAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultVaultRecordShareSummaryRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultVaultRecordShareSummaryAttrTypesRSRORecurse
	} else {
		attrs = vaultVaultRecordShareSummaryAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for children with type List
	obj["parent"] = reorderVaultVaultRecordShareRO(state.Attributes()["parent"].(types.Object), priorState.Attributes()["parent"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultVaultRecord_additionalObjects(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultVaultRecord_additionalObjectsAttrTypesRSRecurse
	} else {
		attrs = vaultVaultRecord_additionalObjectsAttrTypesRS
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["secret"] = reorderVaultVaultRecordSecrets(state.Attributes()["secret"].(types.Object), priorState.Attributes()["secret"].(types.Object), recurse)
	obj["tile"] = reorderLaunchpadVaultRecordLaunchpadTile(state.Attributes()["tile"].(types.Object), priorState.Attributes()["tile"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderVaultVaultRecord_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = vaultVaultRecord_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = vaultVaultRecord_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	obj["secret"] = reorderVaultVaultRecordSecretsRO(state.Attributes()["secret"].(types.Object), priorState.Attributes()["secret"].(types.Object), recurse)
	obj["tile"] = reorderLaunchpadVaultRecordLaunchpadTileRO(state.Attributes()["tile"].(types.Object), priorState.Attributes()["tile"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderWebhookWebhookRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = webhookWebhookAttrTypesRSRORecurse
	} else {
		attrs = webhookWebhookAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	if recurse {
	}
	if recurse {
		maps.Copy(obj, reorderWebhookWebhook_additionalObjectsRO(state, priorState, false).Attributes())
	}
	obj["account"] = reorderAuthAccountPrimerRO(state.Attributes()["account"].(types.Object), priorState.Attributes()["account"].(types.Object), recurse)
	obj["client"] = reorderClientClientApplicationPrimerRO(state.Attributes()["client"].(types.Object), priorState.Attributes()["client"].(types.Object), recurse)
	obj["client_certificate"] = reorderCertificateCertificatePrimerRO(state.Attributes()["client_certificate"].(types.Object), priorState.Attributes()["client_certificate"].(types.Object), recurse)
	obj["directory"] = reorderDirectoryAccountDirectoryPrimerRO(state.Attributes()["directory"].(types.Object), priorState.Attributes()["directory"].(types.Object), recurse)
	obj["group"] = reorderGroupGroupPrimerRO(state.Attributes()["group"].(types.Object), priorState.Attributes()["group"].(types.Object), recurse)
	obj["system"] = reorderProvisioningProvisionedSystemPrimerRO(state.Attributes()["system"].(types.Object), priorState.Attributes()["system"].(types.Object), recurse)
	obj["trusted_certificate"] = reorderCertificateCertificatePrimerRO(state.Attributes()["trusted_certificate"].(types.Object), priorState.Attributes()["trusted_certificate"].(types.Object), recurse)

	return types.ObjectValueMust(attrs, obj)
}

func reorderWebhookWebhookLinkableWrapperRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = webhookWebhookLinkableWrapperAttrTypesRSRORecurse
	} else {
		attrs = webhookWebhookLinkableWrapperAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)
	// Reordering not supported for items with type List

	return types.ObjectValueMust(attrs, obj)
}

func reorderWebhookWebhook_additionalObjectsRO(state basetypes.ObjectValue, priorState basetypes.ObjectValue, recurse bool) basetypes.ObjectValue {
	if state.IsNull() || state.IsUnknown() || priorState.IsNull() || priorState.IsUnknown() {
		return state
	}
	var attrs map[string]attr.Type
	if recurse {
		attrs = webhookWebhook_additionalObjectsAttrTypesRSRORecurse
	} else {
		attrs = webhookWebhook_additionalObjectsAttrTypesRSRO
	}
	obj := filterAttributes(state.Attributes(), attrs)

	return types.ObjectValueMust(attrs, obj)
}
