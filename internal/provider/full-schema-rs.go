// Code generated by "terraform-provider-keyhub-generator"; DO NOT EDIT.
// Copyright (c) Topicus Security B.V.
// SPDX-License-Identifier: APSL-2.0

//lint:ignore U1000 Ignore unused functions in generated code
package provider

import (
	"golang.org/x/exp/maps"
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/mapdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

func resourceSchemaAttrsAuditInfo(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["created_at"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["created_by"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["last_modified_at"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["last_modified_by"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGeneratedSecret(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["generated_secret"] = rsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["old_secret"] = rsschema.StringAttribute{
		Optional:  true,
		Sensitive: true,
	}
	schemaAttrs["regenerate"] = rsschema.BoolAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsLinkable(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsNonLinkable(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsRestLink(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["href"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["id"] = rsschema.Int64Attribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Int64{int64planmodifier.UseStateForUnknown()},
	}
	schemaAttrs["rel"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["type_escaped"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuditGroupAudit(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsAuditGroupAudit_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["accounts"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuditGroupAuditAccount(false),
		},
		Optional: true,
	}
	schemaAttrs["comment"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["created_at"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["created_by"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["group_name"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name_on_audit"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["nested_groups"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuditNestedGroupAudit(false),
		},
		Optional: true,
	}
	schemaAttrs["reviewed_at"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["reviewed_by"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["status"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NEW", "DRAFT", "UNDER_REVIEW", "FINAL",
			),
		},
	}
	schemaAttrs["submitted_at"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["submitted_by"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuditGroupAuditAccount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["account_uuid"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["account_valid"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["action"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"APPROVE", "CHANGE_TO_MANAGER", "CHANGE_TO_NORMAL", "REMOVE", "CONNECT_NESTED",
			),
		},
	}
	schemaAttrs["comment"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["disconnected_nested"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["display_name"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_used"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["nested"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["rights"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuditGroupAuditLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuditGroupAudit(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuditGroupAudit_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsAuditNestedGroupAudit(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["action"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"INCLUDE", "EXCLUDE", "MISMATCH",
			),
		},
	}
	schemaAttrs["comment"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["group_uuid"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthAccountPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["display_name"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["validity"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthPermission(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["full"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["instances"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
	}
	schemaAttrs["operations"] = rsschema.SetAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Validators: []validator.Set{
			setvalidator.ValueStringsAre(
				stringvalidator.OneOf(
					"CREATE", "READ", "UPDATE", "DELETE",
				),
			),
		},
	}
	schemaAttrs["type_escaped"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsCertificateCertificatePrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["alias"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 128),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["certificate_data"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["expiration"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["fingerprint_sha1"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["fingerprint_sha256"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["global"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["subject_dn"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientApplicationVaultVaultRecord(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "parent", "passwordMetadata", "secret", "shareSummary", "shares", "tile", "vaultholder",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsVaultVaultRecord_additionalObjects(false))

	}
	schemaAttrs["client_application_uuid"] = rsschema.StringAttribute{
		Required:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.RequiresReplace()},
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["color"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NONE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "GREEN", "RED", "BLUE", "DARK", "PINK_LAVENDER", "CRIMSON_RED", "MIDDLE_YELLOW", "ANDROID_GREEN", "SAGE", "ARTICHOKE",
			),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["share_end_time"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["derived"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["filename"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["types"] = rsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["url"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["warning_period"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"AT_EXPIRATION", "TWO_WEEKS", "ONE_MONTH", "TWO_MONTHS", "THREE_MONTHS", "SIX_MONTHS", "NEVER",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientClientApplication(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "groupclients", "groups", "secret", "tile", "vaultRecordCount",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsClientClientApplication_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["client_id"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["scopes"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Computed:    true,
	}
	schemaAttrs["sso_application"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["last_modified_at"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["owner_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["technical_administrator_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientLdapClient(false),
		}
		attr.Optional = true
		schemaAttrs["ldap_client"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientOAuth2Client(false),
		}
		attr.Optional = true
		schemaAttrs["oauth2_client"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientSaml2Client(false),
		}
		attr.Optional = true
		schemaAttrs["saml2_client"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsClientClientApplicationLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsClientClientApplication(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientClientApplicationPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["client_id"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["scopes"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Computed:    true,
	}
	schemaAttrs["sso_application"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientClientApplication_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	schemaAttrs["delete_tile"] = rsschema.BoolAttribute{
		Optional: true,
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupClientLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["groupclients"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["groups"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGeneratedSecret(recurse),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["secret"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsLaunchpadSsoApplicationLaunchpadTile(recurse),
		}
		attr.Optional = true
		schemaAttrs["tile"] = attr
	}

	schemaAttrs["vault_record_count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientLdapClient(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["bind_dn"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["client_certificate_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["share_secret_in_vault"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["shared_secret_uuid"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["used_for_provisioning"] = rsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientOAuth2Client(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["account_permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	schemaAttrs["attributes"] = rsschema.MapAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Computed:    true,
		Default:     mapdefault.StaticValue(types.MapValueMust(types.StringType, make(map[string]attr.Value))),
	}

	schemaAttrs["callback_uri"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["debug_mode"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["id_token_claims"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["initiate_login_uri"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["profile"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("WEB_APPLICATION"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"SERVER_TO_SERVER", "WEB_APPLICATION", "BROWSER_BASED_APPLICATION", "BROWSER_BASED_APPLICATION_WITH_REFRESH_TOKEN", "PUBLIC_NATIVE_APPLICATION", "PUBLIC_NATIVE_APPLICATION_WITH_SECURE_STORAGE", "CONFIDENTIAL_NATIVE_APPLICATION",
			),
		},
	}
	schemaAttrs["resource_uris"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["share_secret_in_vault"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["shared_secret_uuid"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["show_landing_page"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["use_client_credentials"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientOAuth2ClientPermission(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsClientOAuth2ClientPermission_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["for_group_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["for_system_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["value"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ACCOUNTS_QUERY", "ACCOUNTS_REMOVE", "CLIENTS_CREATE", "CLIENTS_QUERY", "GROUPONSYSTEM_CREATE", "GROUPS_CREATE", "GROUPS_GRANT_PERMISSIONS_AFTER_CREATE", "GROUPS_QUERY", "GROUPS_SET_CLASSIFICATION", "GROUP_FULL_VAULT_ACCESS", "GROUP_LAUNCHPADTILES", "GROUP_READ_CONTENTS", "GROUP_SET_AUTHORIZATION", "PROVISIONEDSYSTEMS_QUERY", "SERVICE_ACCOUNTS_CREATE", "SERVICE_ACCOUNTS_QUERY", "SERVICE_ACCOUNTS_UPDATE",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientOAuth2ClientPermissionWithClient(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsClientOAuth2ClientPermission_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["for_group_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["for_system_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["value"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ACCOUNTS_QUERY", "ACCOUNTS_REMOVE", "CLIENTS_CREATE", "CLIENTS_QUERY", "GROUPONSYSTEM_CREATE", "GROUPS_CREATE", "GROUPS_GRANT_PERMISSIONS_AFTER_CREATE", "GROUPS_QUERY", "GROUPS_SET_CLASSIFICATION", "GROUP_FULL_VAULT_ACCESS", "GROUP_LAUNCHPADTILES", "GROUP_READ_CONTENTS", "GROUP_SET_AUTHORIZATION", "PROVISIONEDSYSTEMS_QUERY", "SERVICE_ACCOUNTS_CREATE", "SERVICE_ACCOUNTS_QUERY", "SERVICE_ACCOUNTS_UPDATE",
			),
		},
	}
	schemaAttrs["client_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientOAuth2ClientPermissionWithClientLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsClientOAuth2ClientPermissionWithClient(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientOAuth2ClientPermission_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsClientSaml2Client(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["attributes"] = rsschema.MapAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Computed:    true,
		Default:     mapdefault.StaticValue(types.MapValueMust(types.StringType, make(map[string]attr.Value))),
	}

	schemaAttrs["metadata"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["metadata_url"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["subject_format"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ID", "UPN", "USERNAME", "EMAIL",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryAccountDirectory(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "markers", "status",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsDirectoryAccountDirectory_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["account_validity_supported"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["base_organizational_unit_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["default_directory"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["helpdesk_group_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["restrict2fa"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["rotating_password"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"DEFAULT_OFF", "DEFAULT_ON", "ALWAYS_ON",
			),
		},
	}
	schemaAttrs["username_customizable"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryInternalDirectory(false),
		}
		attr.Optional = true
		schemaAttrs["internal_directory"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryLDAPDirectory(false),
		}
		attr.Optional = true
		schemaAttrs["ldap_directory"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryMaintenanceDirectory(false),
		}
		attr.Optional = true
		schemaAttrs["maintenance_directory"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryOIDCDirectory(false),
		}
		attr.Optional = true
		schemaAttrs["oidc_directory"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsDirectoryAccountDirectoryLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsDirectoryAccountDirectory(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryAccountDirectoryPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["account_validity_supported"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryAccountDirectoryStatusReport(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["accounts"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["reason"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["status"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"INIT_REQUIRED", "ONLINE", "DEGRADED", "NON_REDUNDANT", "OFFLINE", "DISABLED",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryAccountDirectorySummary(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"MAINTENANCE", "LDAP", "INTERNAL", "OIDC",
			),
		},
	}
	schemaAttrs["domain_restriction"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["fully_resolved_issuer"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryAccountDirectoryStatusReport(recurse),
		}
		attr.Optional = true
		schemaAttrs["status"] = attr
	}

	schemaAttrs["username_customizable"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryAccountDirectorySummaryLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsDirectoryAccountDirectorySummary(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryAccountDirectory_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsMarkItemMarkers(recurse),
		}
		attr.Computed = true
		schemaAttrs["markers"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryAccountDirectoryStatusReport(recurse),
		}
		attr.Computed = true
		schemaAttrs["status"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsDirectoryInternalDirectory(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["owner_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryLDAPDirectory(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["attributes_to_store"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["base_dn"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["client_certificate_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["dialect"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("ACTIVE_DIRECTORY"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ACTIVE_DIRECTORY", "OPENLDAP",
			),
		},
	}
	schemaAttrs["failover_host"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["failover_trusted_certificate_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["host"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["password_recovery"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"DISABLED", "VERIFY_2FA", "VERIFY_MAIL", "VERIFY_MAIL_AND_2FA",
			),
		},
	}
	schemaAttrs["port"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["search_bind_dn"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["search_bind_password"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 128),
		},
		Sensitive: true,
	}
	schemaAttrs["search_filter"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["tls"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"VERIFIED_PINNED", "VERIFIED", "SECURE_PINNED", "SECURE", "ENCRYPTED", "UNSECURE",
			),
		},
	}
	schemaAttrs["trusted_certificate_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryMaintenanceDirectory(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryOIDCDirectory(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["acr_values"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["attributes_to_store"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["client_id"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["client_secret"] = rsschema.StringAttribute{
		Required:  true,
		Sensitive: true,
	}
	schemaAttrs["domain_restriction"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["enforces2fa"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["fully_resolved_issuer"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["issuer"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["logout_url"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["send_login_hint"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["vendor_escaped"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"GENERIC", "GOOGLE", "AZURE_AD",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupAuthorizedGroupsWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroup(recurse),
		},
		Optional: true,
	}
	schemaAttrs["group_count"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroup(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"accounts", "administeredClients", "administeredSystems", "admins", "audit", "authorizedGroups", "clientPermissions", "clients", "contentAdministeredSystems", "groupauditinginfo", "groupinfo", "helpdesk", "markers", "myaccount", "mydelegatedaccount", "nestedGroups", "ownedClients", "ownedDirectories", "ownedGroupsOnSystem", "ownedOrganizationalUnits", "ownedSystems", "recentAudits", "requeststatus", "serviceAccounts", "systems", "vault", "webhooks",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupGroup_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["admin"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["organizational_unit_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["application_administration"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupAuditConfig(false),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["audit_config"] = attr
	}

	schemaAttrs["audit_requested"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["auditor"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["authorizing_group_auditing_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["authorizing_group_delegation_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["authorizing_group_membership_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["authorizing_group_provisioning_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["authorizing_group_types"] = rsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["classification_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["description"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["extended_access"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NOT_ALLOWED"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NOT_ALLOWED", "ONE_WEEK", "TWO_WEEKS", "TWO_WEEKS_NO_CONFIRM",
			),
		},
	}
	schemaAttrs["hide_audit_trail"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["nested_under_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["private_group"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["record_trail"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["rotating_password_required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["single_managed"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["vault_recovery"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("FULL"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "RECOVERY_KEY_ONLY", "FULL",
			),
		},
	}
	schemaAttrs["vault_requires_activation"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAccount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupGroupAccount_additionalObjects(false))

	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["directory_uuid"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["disconnected_nested"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["last_used"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["nested"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["provisioning_end_time"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["rights"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"MANAGER", "NORMAL",
			),
		},
	}
	schemaAttrs["two_factor_status"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["visible_for_provisioning"] = rsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAccountLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroupAccount(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAccount_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAuditConfig(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["months"] = rsschema.SetAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Computed:    true,
		Validators: []validator.Set{
			setvalidator.ValueStringsAre(
				stringvalidator.OneOf(
					"JANUARY", "FEBRUARY", "MARCH", "APRIL", "MAY", "JUNE", "JULY", "AUGUST", "SEPTEMBER", "OCTOBER", "NOVEMBER", "DECEMBER",
				),
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAuditingInfo(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["audit_due_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["last_audit_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["nr_accounts"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["nr_disabled_accounts"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["nr_disabled_managers"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["nr_expired_vault_records"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["nr_managers"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["nr_vault_records_with_end_date"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupClassificationPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupClient(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupGroupClient_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["activation_required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["client_uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["group_uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["owner_uuid"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["technical_administrator_uuid"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupClientLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroupClient(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupClient_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupInfo(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["nr_accounts"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["nr_accounts_with_vault"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["nr_audits"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["nr_clients"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["nr_provisioned_systems"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["nr_vault_records"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroup(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["admin"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["organizational_unit_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupPrimerLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroupPrimer(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroup_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupAccountLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["accounts"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsClientClientApplicationLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["administered_clients"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["administered_systems"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupAccountLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		attr.DeprecationMessage = "This property will be removed in a future version."
		schemaAttrs["admins"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupAuthorizedGroupsWrapper(recurse),
		}
		attr.Computed = true
		schemaAttrs["authorized_groups"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsClientOAuth2ClientPermissionWithClientLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["client_permissions"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupClientLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["clients"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["content_administered_systems"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupAuditingInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["groupauditinginfo"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["groupinfo"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsDirectoryAccountDirectorySummaryLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["helpdesk"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsMarkItemMarkers(recurse),
		}
		attr.Computed = true
		schemaAttrs["markers"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupAccount(recurse),
		}
		attr.Computed = true
		schemaAttrs["myaccount"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupAccount(recurse),
		}
		attr.Computed = true
		schemaAttrs["mydelegatedaccount"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupPrimerLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["nested_groups"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsClientClientApplicationLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["owned_clients"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsDirectoryAccountDirectoryLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["owned_directories"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningOwnedGroupOnSystemsWrapper(recurse),
		}
		attr.Computed = true
		schemaAttrs["owned_groups_on_system"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsOrganizationOrganizationalUnitLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["owned_organizational_units"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["owned_systems"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsAuditGroupAuditLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["recent_audits"] = attr
	}

	schemaAttrs["requeststatus"] = rsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsServiceaccountServiceAccountLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["service_accounts"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupProvisioningGroupLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["systems"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVault(recurse),
		}
		attr.Computed = true
		schemaAttrs["vault"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsWebhookWebhookLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["webhooks"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsGroupProvisioningGroup(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupProvisioningGroup_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["activation_required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["group_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningGroupOnSystem(false),
		}
		attr.Computed = true
		attr.PlanModifiers = []planmodifier.Object{objectplanmodifier.UseStateForUnknown()}
		schemaAttrs["group_on_system"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsGroupProvisioningGroupLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupProvisioningGroup(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupProvisioningGroup_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsGroupVaultVaultRecord(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "parent", "passwordMetadata", "secret", "shareSummary", "shares", "tile", "vaultholder",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsVaultVaultRecord_additionalObjects(false))

	}
	schemaAttrs["group_uuid"] = rsschema.StringAttribute{
		Required:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.RequiresReplace()},
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["color"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NONE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "GREEN", "RED", "BLUE", "DARK", "PINK_LAVENDER", "CRIMSON_RED", "MIDDLE_YELLOW", "ANDROID_GREEN", "SAGE", "ARTICHOKE",
			),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["share_end_time"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["derived"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["filename"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["types"] = rsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["url"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["warning_period"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"AT_EXPIRATION", "TWO_WEEKS", "ONE_MONTH", "TWO_MONTHS", "THREE_MONTHS", "SIX_MONTHS", "NEVER",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsLaunchpadSsoApplicationLaunchpadTile(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["uri"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsLaunchpadVaultRecordLaunchpadTile(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsMarkItemMarker(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["level"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"INFO", "WARNING",
			),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"TLS_DISABLED", "TLS_UNVERIFIED", "WEAK_PASSWORD_HASHING", "GROUP_NO_MANAGER", "GROUP_ONE_MANAGER", "GROUP_UNREADABLE_VAULT", "GROUP_UNRECOVERABLE_VAULT", "GROUP_CRITERIA_UNSATISFIED_AUDIT_INTERVAL", "GROUP_CRITERIA_UNSATISFIED_AUDIT_MONTHS", "GROUP_CRITERIA_UNSATISFIED_AUTHORIZING_GROUP_PROVISIONING", "GROUP_CRITERIA_UNSATISFIED_AUTHORIZING_GROUP_MEMBERSHIP", "GROUP_CRITERIA_UNSATISFIED_AUTHORIZING_GROUP_DELEGATION", "GROUP_CRITERIA_UNSATISFIED_AUTHORIZING_GROUP_AUDITING", "GROUP_CRITERIA_UNSATISFIED_RECORD_TRAIL", "GROUP_CRITERIA_UNSATISFIED_ROTATING_PASSWORD_REQUIRED", "GROUP_CRITERIA_UNSATISFIED_VAULT_REQUIRES_ACTIVATION", "GROUP_CRITERIA_UNSATISFIED_MINIMUM_NR_MANAGERS",
			),
		},
	}
	schemaAttrs["parameters"] = rsschema.MapAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Computed:    true,
		Default:     mapdefault.StaticValue(types.MapValueMust(types.StringType, make(map[string]attr.Value))),
	}

	return schemaAttrs
}
func resourceSchemaAttrsMarkItemMarkers(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["markers"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsMarkItemMarker(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsNestedProvisioningGroupOnSystem(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "provgroups", "serviceAccounts",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProvisioningGroupOnSystem_additionalObjects(false))

	}
	schemaAttrs["provisioned_system_uuid"] = rsschema.StringAttribute{
		Required:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.RequiresReplace()},
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["display_name"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["name_in_system"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"POSIX_GROUP", "GROUP_OF_NAMES", "GROUP_OF_UNIQUE_NAMES", "GROUP", "AZURE_ROLE", "AZURE_UNIFIED_GROUP", "AZURE_SECURITY_GROUP", "SCIM",
			),
		},
	}
	schemaAttrs["short_name_in_system"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["owner_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationOrganizationalUnit(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsOrganizationOrganizationalUnit_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["depth"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["description"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["owner_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["parent_uuid"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationOrganizationalUnitLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsOrganizationOrganizationalUnit(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationOrganizationalUnitPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationOrganizationalUnitPrimerLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsOrganizationOrganizationalUnitPrimer(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationOrganizationalUnit_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsOrganizationOrganizationalUnitPrimerLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["create_as_parent_of"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProvisioningAbstractProvisionedLDAP(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["attributes"] = rsschema.MapAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Computed:    true,
		Default:     mapdefault.StaticValue(types.MapValueMust(types.StringType, make(map[string]attr.Value))),
	}

	schemaAttrs["base_dn"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["bind_dn"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["bind_password"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 128),
		},
		Sensitive: true,
	}
	schemaAttrs["client_certificate_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["failover_host"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["failover_trusted_certificate_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["group_dn"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["host"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["object_classes"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["port"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["service_account_dn"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["ssh_public_key_supported"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["tls"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"VERIFIED_PINNED", "VERIFIED", "SECURE_PINNED", "SECURE", "ENCRYPTED", "UNSECURE",
			),
		},
	}
	schemaAttrs["trusted_certificate_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["user_dn"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningCircuitBreakerStatistics(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["number_of_failed_calls"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["number_of_not_permitted_calls"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["number_of_successful_calls"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["state"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"CLOSED", "OPEN", "HALF_OPEN",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningGroupOnSystem(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "provgroups", "serviceAccounts",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProvisioningGroupOnSystem_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["display_name"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["name_in_system"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"POSIX_GROUP", "GROUP_OF_NAMES", "GROUP_OF_UNIQUE_NAMES", "GROUP", "AZURE_ROLE", "AZURE_UNIFIED_GROUP", "AZURE_SECURITY_GROUP", "SCIM",
			),
		},
	}
	schemaAttrs["short_name_in_system"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["owner_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningGroupOnSystemLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProvisioningGroupOnSystem(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningGroupOnSystemPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["display_name"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["name_in_system"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"POSIX_GROUP", "GROUP_OF_NAMES", "GROUP_OF_UNIQUE_NAMES", "GROUP", "AZURE_ROLE", "AZURE_UNIFIED_GROUP", "AZURE_SECURITY_GROUP", "SCIM",
			),
		},
	}
	schemaAttrs["short_name_in_system"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningGroupOnSystemTypes(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["types"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Validators: []validator.List{
			listvalidator.ValueStringsAre(
				stringvalidator.OneOf(
					"POSIX_GROUP", "GROUP_OF_NAMES", "GROUP_OF_UNIQUE_NAMES", "GROUP", "AZURE_ROLE", "AZURE_UNIFIED_GROUP", "AZURE_SECURITY_GROUP", "SCIM",
				),
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningGroupOnSystem_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupProvisioningGroupLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["provgroups"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsServiceaccountServiceAccountPrimerLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["service_accounts"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProvisioningOwnedGroupOnSystemsWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProvisioningGroupOnSystem(recurse),
		},
		Optional: true,
	}
	schemaAttrs["unlinked_count"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionNumberSequence(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "systems",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProvisioningProvisionNumberSequence_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["account_count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["next_uid"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(2000),
		Validators: []validator.Int64{
			int64validator.Between(2000, 60000),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionNumberSequence_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProvisioningProvisionedSystemPrimerLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["systems"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedAD(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["sam_account_name_scheme"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"OMIT", "TRUNCATE", "TRANSFER", "TRANSFER_TRUNCATE", "USERNAME",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedAccount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProvisioningProvisionedAccount_additionalObjects(false))

	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["uid"] = rsschema.Int64Attribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Int64{int64planmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedAccount_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedAzureOIDCDirectory(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["directory_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["tenant"] = rsschema.StringAttribute{
		Required: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedAzureSyncLDAPDirectory(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["client_id"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["client_secret"] = rsschema.StringAttribute{
		Required:  true,
		Sensitive: true,
	}
	schemaAttrs["directory_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["tenant"] = rsschema.StringAttribute{
		Required: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedAzureTenant(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["client_id"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["client_secret"] = rsschema.StringAttribute{
		Required:  true,
		Sensitive: true,
	}
	schemaAttrs["idp_domain"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["tenant"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedInternalLDAP(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["client_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedLDAP(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["gid"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["hashing_scheme"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"SSHA", "PBKDF2",
			),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionNumberSequence(recurse),
		}
		attr.Required = true
		schemaAttrs["numbering"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedLDAPDirectory(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["directory_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["group_dn"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedNamespace(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["base_system_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["group_dn"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["service_account_dn"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedSCIM(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["authentication_scheme"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NONE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "BASIC", "BEARER", "CUSTOM",
			),
		},
	}
	schemaAttrs["basic_auth_password"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
		Sensitive: true,
	}
	schemaAttrs["basic_auth_username"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["bearer_token"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 1024),
		},
		Sensitive: true,
	}
	schemaAttrs["custom_header_name"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 64),
		},
	}
	schemaAttrs["custom_header_value"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 1024),
		},
		Sensitive: true,
	}
	schemaAttrs["url"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["vendor_escaped"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("DEFAULT"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"DEFAULT", "AWS", "KEYSTONE",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedSystem(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"account", "audit", "issuedPermissions", "loginName", "managementPermissions", "markers", "statistics", "supportedGroupTypes",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProvisioningProvisionedSystem_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["organizational_unit_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["account_count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["content_administrator_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["external_uuid"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["owner_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["self_service_existing_groups"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["self_service_new_groups"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["self_service_new_namespaces"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["self_service_service_accounts"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["should_destroy_unknown_accounts"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["technical_administrator_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["username_prefix"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningAbstractProvisionedLDAP(false),
		}
		attr.Optional = true
		schemaAttrs["abstract_provisioned_ldap"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedAD(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_a_d"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedAzureOIDCDirectory(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_azure_oidc_directory"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedAzureSyncLDAPDirectory(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_azure_sync_ldap_directory"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedAzureTenant(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_azure_tenant"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedInternalLDAP(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_internal_ldap"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedLDAP(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_ldap"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedLDAPDirectory(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_ldap_directory"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedNamespace(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_namespace"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedSCIM(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_scim"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProvisioningProvisionedSystem(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedSystemPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["organizational_unit_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedSystemPrimerLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProvisioningProvisionedSystemPrimer(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedSystem_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedAccount(recurse),
		}
		attr.Computed = true
		schemaAttrs["account"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsClientOAuth2ClientPermissionWithClientLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["issued_permissions"] = attr
	}

	schemaAttrs["login_name"] = rsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisioningManagementPermissions(recurse),
		}
		attr.Computed = true
		schemaAttrs["management_permissions"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsMarkItemMarkers(recurse),
		}
		attr.Computed = true
		schemaAttrs["markers"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningCircuitBreakerStatistics(recurse),
		}
		attr.Computed = true
		schemaAttrs["statistics"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningGroupOnSystemTypes(recurse),
		}
		attr.Computed = true
		schemaAttrs["supported_group_types"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisioningManagementPermissions(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["create_new_groups_allowed"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["create_service_accounts_allowed"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["reuse_existing_groups_allowed"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "groups", "secret",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsServiceaccountServiceAccount_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["system_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["description"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["password_uuid"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["password_rotation"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("DAILY"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"MANUAL", "MANUAL_STORED_IN_VAULT", "DAILY",
			),
		},
	}
	schemaAttrs["technical_administrator_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountGroup(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsServiceaccountServiceAccountGroup_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["display_name"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["name_in_system"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"POSIX_GROUP", "GROUP_OF_NAMES", "GROUP_OF_UNIQUE_NAMES", "GROUP", "AZURE_ROLE", "AZURE_UNIFIED_GROUP", "AZURE_SECURITY_GROUP", "SCIM",
			),
		},
	}
	schemaAttrs["short_name_in_system"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountGroupLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsServiceaccountServiceAccountGroup(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountGroup_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsServiceaccountServiceAccount(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["system_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountPrimerLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsServiceaccountServiceAccountPrimer(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccount_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsServiceaccountServiceAccountGroupLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["groups"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGeneratedSecret(recurse),
		}
		attr.Optional = true
		schemaAttrs["secret"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsVaultPasswordMetadata(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["dictionary"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["duplicate"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["hash"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["length"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["lower_count"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["number_count"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["special_count"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["strength"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["upper_count"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVault(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["access_available"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["records"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Validators: []validator.List{
			listvalidator.ValueStringsAre(
				stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultHolder(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecord(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "parent", "passwordMetadata", "secret", "shareSummary", "shares", "tile", "vaultholder",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsVaultVaultRecord_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["color"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NONE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "GREEN", "RED", "BLUE", "DARK", "PINK_LAVENDER", "CRIMSON_RED", "MIDDLE_YELLOW", "ANDROID_GREEN", "SAGE", "ARTICHOKE",
			),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["share_end_time"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["derived"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["filename"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["types"] = rsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["url"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["warning_period"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"AT_EXPIRATION", "TWO_WEEKS", "ONE_MONTH", "TWO_MONTHS", "THREE_MONTHS", "SIX_MONTHS", "NEVER",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecordPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["color"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NONE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "GREEN", "RED", "BLUE", "DARK", "PINK_LAVENDER", "CRIMSON_RED", "MIDDLE_YELLOW", "ANDROID_GREEN", "SAGE", "ARTICHOKE",
			),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["share_end_time"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecordPrimerLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsVaultVaultRecordPrimer(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecordSecrets(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["comment"] = rsschema.StringAttribute{
		Optional:  true,
		Sensitive: true,
	}
	schemaAttrs["file"] = rsschema.StringAttribute{
		Optional:  true,
		Sensitive: true,
	}
	schemaAttrs["password"] = rsschema.StringAttribute{
		Optional:  true,
		Sensitive: true,
	}
	schemaAttrs["totp"] = rsschema.StringAttribute{
		Optional:  true,
		Sensitive: true,
	}
	schemaAttrs["write_totp"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecordShare(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["name"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ACCOUNT", "CLIENT", "GROUP",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecordShareSummary(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["children"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsVaultVaultRecordShare(recurse),
		},
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultRecordShare(recurse),
		}
		attr.Optional = true
		schemaAttrs["parent"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecord_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	schemaAttrs["delete_tile"] = rsschema.BoolAttribute{
		Optional: true,
	}
	schemaAttrs["parent_uuid"] = rsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultPasswordMetadata(recurse),
		}
		attr.Computed = true
		schemaAttrs["password_metadata"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultRecordSecrets(recurse),
		}
		attr.Optional = true
		schemaAttrs["secret"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultRecordShareSummary(recurse),
		}
		attr.Computed = true
		schemaAttrs["share_summary"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsVaultVaultRecordPrimerLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["shares"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsLaunchpadVaultRecordLaunchpadTile(recurse),
		}
		attr.Optional = true
		schemaAttrs["tile"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultHolder(recurse),
		}
		attr.Computed = true
		schemaAttrs["vaultholder"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsWebhookWebhook(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsWebhookWebhook_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["account_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["all_types"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["authentication_scheme"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NONE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "BASIC", "BEARER", "CUSTOM",
			),
		},
	}
	schemaAttrs["basic_auth_password"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
		Sensitive: true,
	}
	schemaAttrs["basic_auth_username"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["bearer_token"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
		Sensitive: true,
	}
	schemaAttrs["client_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["client_certificate_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["custom_header_name"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 64),
		},
	}
	schemaAttrs["custom_header_value"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 1024),
		},
		Sensitive: true,
	}
	schemaAttrs["directory_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["group_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["system_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["tls"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("SECURE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"VERIFIED_PINNED", "VERIFIED", "SECURE_PINNED", "SECURE", "ENCRYPTED", "UNSECURE",
			),
		},
	}
	schemaAttrs["trusted_certificate_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["types"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Validators: []validator.List{
			listvalidator.ValueStringsAre(
				stringvalidator.OneOf(
					"ACCOUNT_2FA_DISABLED", "ACCOUNT_2FA_ENABLED", "ACCOUNT_ADDED_TO_GROUP", "ACCOUNT_ADDED_TO_ORGANIZATIONAL_UNIT", "ACCOUNT_CREATED", "ACCOUNT_DEPROVISIONED", "ACCOUNT_DISABLED", "ACCOUNT_ENABLED", "ACCOUNT_GROUP_ACTIVATED", "ACCOUNT_GROUP_ACTIVATION_REASON", "ACCOUNT_GROUP_DEPROVISIONED", "ACCOUNT_GROUP_PROVISIONED", "ACCOUNT_LOGIN", "ACCOUNT_LOGIN_FAILED", "ACCOUNT_MODIFIED_FOR_GROUP", "ACCOUNT_PASSWORD_CHANGED", "ACCOUNT_PROVISIONED", "ACCOUNT_PROVISIONING_DESTROYED", "ACCOUNT_PROVISIONING_INITED", "ACCOUNT_PROVISIONING_SETUP", "ACCOUNT_REMOVED", "ACCOUNT_REMOVED_FROM_GROUP", "ACCOUNT_REMOVED_FROM_ORGANIZATIONAL_UNIT", "ACCOUNT_REREGISTERED", "ACCOUNT_SSH_PUBLIC_KEY_MODIFIED", "ACCOUNT_TOKEN_SIGNED", "ACCOUNT_TOTP_OFFSET_CHANGED", "ACCOUNT_VAULT_UNLOCKED", "ADD_GROUP_ADMIN_ACCEPTED", "ADD_GROUP_ADMIN_DECLINED", "ADD_GROUP_ADMIN_REQUESTED", "AUDITOR_EXPORT_GENERATED", "CERTIFICATE_CREATED", "CERTIFICATE_MODIFIED", "CERTIFICATE_REMOVED", "CLIENT_ADDED_TO_GROUP", "CLIENT_CREATED", "CLIENT_MODIFIED", "CLIENT_MODIFIED_FOR_GROUP", "CLIENT_PERMISSION_GRANTED", "CLIENT_PERMISSION_REVOKED", "CLIENT_REMOVED", "CLIENT_REMOVED_FROM_GROUP", "CLIENT_SECRET_ROTATED", "CREATE_GROUP_ACCEPTED", "CREATE_GROUP_DECLINED", "CREATE_GROUP_REQUESTED", "CREATE_GROUP_ON_SYSTEM_ACCEPTED", "CREATE_GROUP_ON_SYSTEM_DECLINED", "CREATE_GROUP_ON_SYSTEM_REQUESTED", "CREATE_PROVISIONED_NAMESPACE_ACCEPTED", "CREATE_PROVISIONED_NAMESPACE_DECLINED", "CREATE_PROVISIONED_NAMESPACE_REQUESTED", "CREATE_SERVICE_ACCOUNT_ACCEPTED", "CREATE_SERVICE_ACCOUNT_DECLINED", "CREATE_SERVICE_ACCOUNT_REQUESTED", "DIRECTORY_CREATED", "DIRECTORY_HELPDESK_MODIFIED", "DIRECTORY_MODIFIED", "DIRECTORY_REMOVED", "DISABLE_2FA_ACCEPTED", "DISABLE_2FA_DECLINED", "DISABLE_2FA_REQUESTED", "ENABLE_TECHNICAL_ADMINISTRATION_ACCEPTED", "ENABLE_TECHNICAL_ADMINISTRATION_DECLINED", "ENABLE_TECHNICAL_ADMINISTRATION_REQUESTED", "EXTENDED_ACCESS_ACCEPTED", "EXTENDED_ACCESS_DECLINED", "EXTENDED_ACCESS_REQUESTED", "GRANT_ACCESS_ACCEPTED", "GRANT_ACCESS_DECLINED", "GRANT_ACCESS_REQUESTED", "GRANT_APPLICATION_ACCEPTED", "GRANT_APPLICATION_DECLINED", "GRANT_APPLICATION_REQUESTED", "GRANT_CLIENT_PERMISSION_ACCEPTED", "GRANT_CLIENT_PERMISSION_DECLINED", "GRANT_CLIENT_PERMISSION_REQUESTED", "GRANT_GROUP_ON_SYSTEM_ACCEPTED", "GRANT_GROUP_ON_SYSTEM_DECLINED", "GRANT_GROUP_ON_SYSTEM_REQUESTED", "GRANT_GROUP_ON_SYSTEM_REQUEST_ACCEPTED", "GRANT_GROUP_ON_SYSTEM_REQUEST_DECLINED", "GRANT_GROUP_ON_SYSTEM_REQUEST_REQUESTED", "GRANT_SERVICE_ACCOUNT_GROUP_ACCEPTED", "GRANT_SERVICE_ACCOUNT_GROUP_DECLINED", "GRANT_SERVICE_ACCOUNT_GROUP_REQUESTED", "GROUP_AUDIT_CREATED", "GROUP_AUDIT_REQUESTED", "GROUP_AUTHORIZATION_CONNECTED", "GROUP_AUTHORIZATION_DISCONNECTED", "GROUP_CLASSIFICATION_ASSIGNED", "GROUP_CLASSIFICATION_CREATED", "GROUP_CLASSIFICATION_MODIFIED", "GROUP_CLASSIFICATION_REMOVED", "GROUP_CREATED", "GROUP_MODIFIED", "GROUP_NESTING_CONNECTED", "GROUP_NESTING_DISCONNECTED", "GROUP_ON_SYSTEM_CREATED", "GROUP_ON_SYSTEM_DEPROVISIONED", "GROUP_ON_SYSTEM_PROVISIONED", "GROUP_ON_SYSTEM_REMOVED", "GROUP_REMOVED", "INTERNAL_ACCOUNT_ACTIVATED", "INTERNAL_ACCOUNT_CREATED", "INTERNAL_ACCOUNT_MODIFIED", "INTERNAL_ACCOUNT_REMOVED", "INVALID_SIGNATURE_DETECTED", "JOIN_GROUP_ACCEPTED", "JOIN_GROUP_DECLINED", "JOIN_GROUP_REQUESTED", "JOIN_VAULT_ACCEPTED", "JOIN_VAULT_DECLINED", "JOIN_VAULT_REQUESTED", "LICENSE_KEY_UPLOADED", "ORGANIZATIONAL_UNIT_CREATED", "ORGANIZATIONAL_UNIT_MODIFIED", "ORGANIZATIONAL_UNIT_REMOVED", "PROVISIONED_SYSTEM_ADDED_TO_GROUP", "PROVISIONED_SYSTEM_CREATED", "PROVISIONED_SYSTEM_MODIFIED", "PROVISIONED_SYSTEM_MODIFIED_FOR_GROUP", "PROVISIONED_SYSTEM_REMOVED", "PROVISIONED_SYSTEM_REMOVED_FROM_GROUP", "PROVISIONED_SYSTEM_UNKNOWN_ACCOUNT_DESTROYED", "REMOVE_GROUP_ACCEPTED", "REMOVE_GROUP_DECLINED", "REMOVE_GROUP_REQUESTED", "REMOVE_ORGANIZATIONAL_UNIT_ACCEPTED", "REMOVE_ORGANIZATIONAL_UNIT_DECLINED", "REMOVE_ORGANIZATIONAL_UNIT_REQUESTED", "REMOVE_PROVISIONED_SYSTEM_ACCEPTED", "REMOVE_PROVISIONED_SYSTEM_DECLINED", "REMOVE_PROVISIONED_SYSTEM_REQUESTED", "RESET_PASSWORD_ACCEPTED", "RESET_PASSWORD_DECLINED", "RESET_PASSWORD_FINISHED", "RESET_PASSWORD_REQUESTED", "REVIEW_AUDIT_ACCEPTED", "REVIEW_AUDIT_DECLINED", "REVIEW_AUDIT_REQUESTED", "REVOKE_ADMIN_ACCEPTED", "REVOKE_ADMIN_DECLINED", "REVOKE_ADMIN_REQUESTED", "SERVICE_ACCOUNT_ADDED_TO_GROUP", "SERVICE_ACCOUNT_CREATED", "SERVICE_ACCOUNT_GROUP_DEPROVISIONED", "SERVICE_ACCOUNT_GROUP_PROVISIONED", "SERVICE_ACCOUNT_MODIFIED", "SERVICE_ACCOUNT_PASSWORD_ROTATED", "SERVICE_ACCOUNT_PROVISIONING_DESTROYED", "SERVICE_ACCOUNT_PROVISIONING_INITED", "SERVICE_ACCOUNT_REMOVED", "SERVICE_ACCOUNT_REMOVED_FROM_GROUP", "SETTING_MODIFIED", "SETUP_AUTHORIZING_GROUP_CONNECT_ACCEPTED", "SETUP_AUTHORIZING_GROUP_CONNECT_DECLINED", "SETUP_AUTHORIZING_GROUP_CONNECT_REQUESTED", "SETUP_AUTHORIZING_GROUP_DISCONNECT_ACCEPTED", "SETUP_AUTHORIZING_GROUP_DISCONNECT_DECLINED", "SETUP_AUTHORIZING_GROUP_DISCONNECT_REQUESTED", "SETUP_NESTED_GROUP_CONNECT_ACCEPTED", "SETUP_NESTED_GROUP_CONNECT_DECLINED", "SETUP_NESTED_GROUP_CONNECT_REQUESTED", "SETUP_NESTED_GROUP_DISCONNECT_ACCEPTED", "SETUP_NESTED_GROUP_DISCONNECT_DECLINED", "SETUP_NESTED_GROUP_DISCONNECT_REQUESTED", "TRANSFER_APPLICATION_ADMINISTRATION_ACCEPTED", "TRANSFER_APPLICATION_ADMINISTRATION_DECLINED", "TRANSFER_APPLICATION_ADMINISTRATION_REQUESTED", "TRANSFER_APPLICATION_OWNERSHIP_ACCEPTED", "TRANSFER_APPLICATION_OWNERSHIP_DECLINED", "TRANSFER_APPLICATION_OWNERSHIP_REQUESTED", "TRANSFER_GROUP_ON_SYSTEM_OWNERSHIP_ACCEPTED", "TRANSFER_GROUP_ON_SYSTEM_OWNERSHIP_DECLINED", "TRANSFER_GROUP_ON_SYSTEM_OWNERSHIP_REQUESTED", "TRANSFER_ORGANIZATIONAL_UNIT_OWNERSHIP_ACCEPTED", "TRANSFER_ORGANIZATIONAL_UNIT_OWNERSHIP_DECLINED", "TRANSFER_ORGANIZATIONAL_UNIT_OWNERSHIP_REQUESTED", "TRANSFER_PROVISIONED_SYSTEM_ADMINISTRATION_ACCEPTED", "TRANSFER_PROVISIONED_SYSTEM_ADMINISTRATION_DECLINED", "TRANSFER_PROVISIONED_SYSTEM_ADMINISTRATION_REQUESTED", "TRANSFER_PROVISIONED_SYSTEM_CONTENT_ADMINISTRATION_ACCEPTED", "TRANSFER_PROVISIONED_SYSTEM_CONTENT_ADMINISTRATION_DECLINED", "TRANSFER_PROVISIONED_SYSTEM_CONTENT_ADMINISTRATION_REQUESTED", "TRANSFER_PROVISIONED_SYSTEM_OWNERSHIP_ACCEPTED", "TRANSFER_PROVISIONED_SYSTEM_OWNERSHIP_DECLINED", "TRANSFER_PROVISIONED_SYSTEM_OWNERSHIP_REQUESTED", "TRANSFER_SERVICE_ACCOUNT_ADMINISTRATION_ACCEPTED", "TRANSFER_SERVICE_ACCOUNT_ADMINISTRATION_DECLINED", "TRANSFER_SERVICE_ACCOUNT_ADMINISTRATION_REQUESTED", "TRANSFER_AUDITOR_GROUP_ACCEPTED", "TRANSFER_AUDITOR_GROUP_DECLINED", "TRANSFER_AUDITOR_GROUP_REQUESTED", "UPDATE_GROUP_MEMBERSHIP_ACCEPTED", "UPDATE_GROUP_MEMBERSHIP_DECLINED", "UPDATE_GROUP_MEMBERSHIP_REQUESTED", "VAULT_ACCESS_RESTORED", "VAULT_EXPORTED", "VAULT_PERSONAL_RESET", "VAULT_PERSONAL_SETUP", "VAULT_RECORD_CREATED", "VAULT_RECORD_MODIFIED", "VAULT_RECORD_MOVED_COPIED_SHARED", "VAULT_RECORD_READ", "VAULT_RECORD_REMOVED", "VAULT_RECOVERED", "VERIFY_INTERNAL_ACCOUNT_ACCEPTED", "VERIFY_INTERNAL_ACCOUNT_DECLINED", "VERIFY_INTERNAL_ACCOUNT_REQUESTED", "WEBHOOK_CREATED", "WEBHOOK_MODIFIED", "WEBHOOK_REMOVED",
				),
			),
		},
	}
	schemaAttrs["url"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["verbose_payloads"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsWebhookWebhookLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsWebhookWebhook(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsWebhookWebhook_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
