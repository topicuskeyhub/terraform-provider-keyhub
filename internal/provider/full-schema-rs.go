// Code generated by "terraform-provider-keyhub-generator"; DO NOT EDIT.

//lint:ignore U1000 Ignore unused functions in generated code
package provider

import (
	"golang.org/x/exp/maps"
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

func resourceSchemaAttrsAuditInfo(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["created_at"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["created_by"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["last_modified_at"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["last_modified_by"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsErrorReport(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["application_error"] = rsschema.StringAttribute{
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsErrorReport_applicationErrorParameters(recurse),
		}
		attr.Optional = true
		schemaAttrs["application_error_parameters"] = attr
	}
	schemaAttrs["code"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["error_details"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
	}
	schemaAttrs["exception"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["message"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["reason"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["stacktrace"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsErrorReport_applicationErrorParameters(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsGeneratedSecret(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["generated_secret"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["old_secret"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["regenerate"] = rsschema.BoolAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsLinkable(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsNonLinkable(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsRestLink(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["href"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["id"] = rsschema.Int64Attribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Int64{int64planmodifier.UseStateForUnknown()},
	}
	schemaAttrs["rel"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["type_escaped"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsSegmentCount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["count"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsAccountVaultVaultRecord(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsVaultVaultRecord_additionalObjects(false))
	}
	schemaAttrs["account_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["color"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NONE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "GREEN", "RED", "BLUE", "DARK", "PINK_LAVENDER", "CRIMSON_RED", "MIDDLE_YELLOW", "ANDROID_GREEN", "SAGE", "ARTICHOKE",
			),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["share_end_time"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["derived"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["filename"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["types"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["url"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["warning_period"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"AT_EXPIRATION", "TWO_WEEKS", "ONE_MONTH", "TWO_MONTHS", "THREE_MONTHS", "SIX_MONTHS", "NEVER",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuditAuditRecord(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsAuditAuditRecord_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["date_time"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["on_account"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["on_certificate"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["on_client"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["on_directory"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["on_group"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["on_group2"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["on_group_classification"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["on_organizational_unit"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["on_service_account"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["on_system"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["on_vault_record"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["on_webhook"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["parameter1"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["parameter2"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["parameter3"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["performed_by"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["security_level"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuditAuditRecordLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuditAuditRecord(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuditAuditRecord_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthAccount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsAuthAccount_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["display_name"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["validity"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["account_permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(false),
		},
		Computed: true,
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["can_request_groups"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["directory_uuid"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["directory_name"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["directory_password_change_required"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["directory_rotating_password"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["directory_type"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["email"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["id_in_directory"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["key_hub_password_change_required"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["last_modified_at"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["license_role"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["locale"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["reregistration_required"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["token_password_enabled"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["two_factor_status"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["valid_in_directory"] = rsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthAccountBulkUpdate(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["action"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"CHANGE_LICENSE_ROLE_TO_PRO", "CHANGE_LICENSE_ROLE_TO_BUSINESS", "MARK_FOR_RENAME",
			),
		},
	}
	schemaAttrs["exclusive_selection"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["selected_accounts"] = rsschema.ListAttribute{
		ElementType: types.Int64Type,
		Required:    true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthAccountChangeLocale(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["locale"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 31),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthAccountLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthAccount(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthAccountPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["display_name"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["validity"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthAccountRecoveryStatus(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["pending2fa_recovery_request"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["pending_password_recovery_request"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthAccountSettings(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["default_organizational_unit_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["directory_name"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["directory_type"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"MAINTENANCE", "LDAP", "INTERNAL", "OIDC",
			),
		},
	}
	schemaAttrs["in_groups"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["in_multiple_organizational_units"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["key_hub_admin"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["multiple_organizational_units_exist"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["password_mode"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"UNSET", "ONE_PASSWORD_UNSYNCED", "ONE_PASSWORD", "TWO_PASSWORDS",
			),
		},
	}
	schemaAttrs["ssh_public_key"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["two_factor_authentication"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"DISABLED", "EXTERNAL", "TOTP", "APP", "WEBAUTHN", "MIXED",
			),
		},
	}
	schemaAttrs["use_token_password"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["vault_status"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NOT_CREATED", "INITIALIZING", "LOCKED", "UNLOCKED",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthAccountStatus(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["account_enabled"] = rsschema.BoolAttribute{
		Optional: true,
	}
	schemaAttrs["can_request_groups"] = rsschema.BoolAttribute{
		Optional: true,
	}
	schemaAttrs["decline_recovery_requests"] = rsschema.BoolAttribute{
		Optional: true,
	}
	schemaAttrs["license_role"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"BUSINESS", "PRO",
			),
		},
	}
	schemaAttrs["reregistration_required"] = rsschema.BoolAttribute{
		Optional: true,
	}
	schemaAttrs["two_factor_authentication_enabled"] = rsschema.BoolAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthAccount_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["active_login"] = rsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupAccountGroupLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["groups"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuthAccountRecoveryStatus(recurse),
		}
		attr.Computed = true
		schemaAttrs["pending_recovery_requests"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuthAccountSettings(recurse),
		}
		attr.Computed = true
		schemaAttrs["settings"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuthStoredAccountAttributes(recurse),
		}
		attr.Computed = true
		schemaAttrs["stored_attributes"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVault(recurse),
		}
		attr.Computed = true
		schemaAttrs["vault"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthAccountsAuditStats(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuthAccountsAuditStats_directoryStats(recurse),
		}
		attr.Optional = true
		schemaAttrs["directory_stats"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuthAccountsAuditStats_twoFAStats(recurse),
		}
		attr.Optional = true
		schemaAttrs["two_fa_stats"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuthAccountsAuditStats_validityStats(recurse),
		}
		attr.Optional = true
		schemaAttrs["validity_stats"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthAccountsAuditStats_directoryStats(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsAuthAccountsAuditStats_twoFAStats(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsAuthAccountsAuditStats_validityStats(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsAuthInternalAccount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["activation_code"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["activation_deadline"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["company"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["first_name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["last_name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["status"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"UNVERIFIED", "NOT_ACTIVATED", "ACTIVATION_EXPIRED", "ACTIVATED",
			),
		},
	}
	schemaAttrs["telephone"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthInternalAccountLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthInternalAccount(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthInternalAccountStatusObject(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["status"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"UNVERIFIED", "NOT_ACTIVATED", "ACTIVATION_EXPIRED", "ACTIVATED",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthMoveInternalAccount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryInternalDirectory(recurse),
		}
		attr.Required = true
		schemaAttrs["internal_directory"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthPermission(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["full"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["instances"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
	}
	schemaAttrs["operations"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Validators: []validator.List{
			listvalidator.ValueStringsAre(
				stringvalidator.OneOf(
					"CREATE", "READ", "UPDATE", "DELETE",
				),
			),
		},
	}
	schemaAttrs["type_escaped"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthStoredAccountAttribute(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["name"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["value"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthStoredAccountAttributes(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["attributes"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthStoredAccountAttribute(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsCertificateCertificate(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsCertificateCertificate_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["alias"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 128),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["certificate_data"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
	}
	schemaAttrs["expiration"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["fingerprint_sha1"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["fingerprint_sha256"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["global"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["subject_dn"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["key_data"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsCertificateCertificateLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsCertificateCertificate(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsCertificateCertificatePrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["alias"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 128),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["certificate_data"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
	}
	schemaAttrs["expiration"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["fingerprint_sha1"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["fingerprint_sha256"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["global"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["subject_dn"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsCertificateCertificate_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientApplicationVaultVaultRecord(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsVaultVaultRecord_additionalObjects(false))
	}
	schemaAttrs["client_application_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["color"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NONE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "GREEN", "RED", "BLUE", "DARK", "PINK_LAVENDER", "CRIMSON_RED", "MIDDLE_YELLOW", "ANDROID_GREEN", "SAGE", "ARTICHOKE",
			),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["share_end_time"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["derived"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["filename"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["types"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["url"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["warning_period"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"AT_EXPIRATION", "TWO_WEEKS", "ONE_MONTH", "TWO_MONTHS", "THREE_MONTHS", "SIX_MONTHS", "NEVER",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientClientApplication(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsClientClientApplication_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["client_id"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["scopes"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
	}
	schemaAttrs["sso_application"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["last_modified_at"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["owner_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["technical_administrator_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientOAuth2Client(false),
		}
		attr.Optional = true
		schemaAttrs["o_auth2_client"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientLdapClient(false),
		}
		attr.Optional = true
		schemaAttrs["ldap_client"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientSaml2Client(false),
		}
		attr.Optional = true
		schemaAttrs["saml2_client"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientClientApplicationLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsClientClientApplication(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientClientApplicationPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["client_id"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["scopes"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
	}
	schemaAttrs["sso_application"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientClientApplication_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	schemaAttrs["delete_tile"] = rsschema.BoolAttribute{
		Optional: true,
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupClientLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["groupclients"] = attr
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["groups"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGeneratedSecret(recurse),
		}
		attr.Optional = true
		schemaAttrs["secret"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsLaunchpadSsoApplicationLaunchpadTile(recurse),
		}
		attr.Optional = true
		schemaAttrs["tile"] = attr
	}
	schemaAttrs["vault_record_count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientLdapClient(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["bind_dn"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["client_certificate_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["share_secret_in_vault"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["shared_secret_uuid"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["used_for_provisioning"] = rsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientOAuth2Client(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["account_permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientOAuth2Client_attributes(recurse),
		}
		attr.Optional = true
		schemaAttrs["attributes"] = attr
	}
	schemaAttrs["callback_uri"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["confidential"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["debug_mode"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["id_token_claims"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["initiate_login_uri"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["resource_uris"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["share_secret_in_vault"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["shared_secret_uuid"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["show_landing_page"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["use_client_credentials"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientOAuth2ClientPermission(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsClientOAuth2ClientPermission_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["for_group_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["for_system_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["value"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ACCOUNTS_QUERY", "ACCOUNTS_REMOVE", "CLIENTS_CREATE", "CLIENTS_QUERY", "GROUPONSYSTEM_CREATE", "GROUPS_CREATE", "GROUPS_GRANT_PERMISSIONS_AFTER_CREATE", "GROUPS_QUERY", "GROUPS_SET_CLASSIFICATION", "GROUP_FULL_VAULT_ACCESS", "GROUP_LAUNCHPADTILES", "GROUP_READ_CONTENTS", "GROUP_SET_AUTHORIZATION", "PROVISIONEDSYSTEMS_QUERY", "SERVICE_ACCOUNTS_CREATE", "SERVICE_ACCOUNTS_QUERY", "SERVICE_ACCOUNTS_UPDATE",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientOAuth2ClientPermissionLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsClientOAuth2ClientPermission(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientOAuth2ClientPermissionWithClient(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsClientOAuth2ClientPermission_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["for_group_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["for_system_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["value"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ACCOUNTS_QUERY", "ACCOUNTS_REMOVE", "CLIENTS_CREATE", "CLIENTS_QUERY", "GROUPONSYSTEM_CREATE", "GROUPS_CREATE", "GROUPS_GRANT_PERMISSIONS_AFTER_CREATE", "GROUPS_QUERY", "GROUPS_SET_CLASSIFICATION", "GROUP_FULL_VAULT_ACCESS", "GROUP_LAUNCHPADTILES", "GROUP_READ_CONTENTS", "GROUP_SET_AUTHORIZATION", "PROVISIONEDSYSTEMS_QUERY", "SERVICE_ACCOUNTS_CREATE", "SERVICE_ACCOUNTS_QUERY", "SERVICE_ACCOUNTS_UPDATE",
			),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientOAuth2Client(false),
		}
		attr.Optional = true
		schemaAttrs["client"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientOAuth2ClientPermissionWithClientLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsClientOAuth2ClientPermissionWithClient(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientOAuth2ClientPermission_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientOAuth2Client_attributes(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsClientSaml2Client(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientSaml2Client_attributes(recurse),
		}
		attr.Optional = true
		schemaAttrs["attributes"] = attr
	}
	schemaAttrs["metadata"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["metadata_url"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["subject_format"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ID", "UPN", "USERNAME", "EMAIL",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientSaml2Client_attributes(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsDeletedVaultHolderVaultVaultRecord(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsVaultVaultRecord_additionalObjects(false))
	}
	schemaAttrs["deleted_vault_holder_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["color"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NONE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "GREEN", "RED", "BLUE", "DARK", "PINK_LAVENDER", "CRIMSON_RED", "MIDDLE_YELLOW", "ANDROID_GREEN", "SAGE", "ARTICHOKE",
			),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["share_end_time"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["derived"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["filename"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["types"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["url"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["warning_period"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"AT_EXPIRATION", "TWO_WEEKS", "ONE_MONTH", "TWO_MONTHS", "THREE_MONTHS", "SIX_MONTHS", "NEVER",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryAccountDirectory(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsDirectoryAccountDirectory_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["account_validity_supported"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["base_organizational_unit_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["default_directory"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["helpdesk_group_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["restrict2fa"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["rotating_password"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"DEFAULT_OFF", "DEFAULT_ON", "ALWAYS_ON",
			),
		},
	}
	schemaAttrs["username_customizable"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryOIDCDirectory(false),
		}
		attr.Optional = true
		schemaAttrs["o_id_c_directory"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryLDAPDirectory(false),
		}
		attr.Optional = true
		schemaAttrs["l_d_a_p_directory"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryMaintenanceDirectory(false),
		}
		attr.Optional = true
		schemaAttrs["maintenance_directory"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryInternalDirectory(false),
		}
		attr.Optional = true
		schemaAttrs["internal_directory"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryAccountDirectoryLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsDirectoryAccountDirectory(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryAccountDirectoryPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["account_validity_supported"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryAccountDirectoryStatusReport(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["accounts"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["reason"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["status"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"INIT_REQUIRED", "ONLINE", "DEGRADED", "NON_REDUNDANT", "OFFLINE", "DISABLED",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryAccountDirectorySummary(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"MAINTENANCE", "LDAP", "INTERNAL", "OIDC",
			),
		},
	}
	schemaAttrs["domain_restriction"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["fully_resolved_issuer"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryAccountDirectoryStatusReport(recurse),
		}
		attr.Optional = true
		schemaAttrs["status"] = attr
	}
	schemaAttrs["username_customizable"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryAccountDirectorySummaryLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsDirectoryAccountDirectorySummary(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryAccountDirectory_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsMarkItemMarkers(recurse),
		}
		attr.Computed = true
		schemaAttrs["markers"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryAccountDirectoryStatusReport(recurse),
		}
		attr.Computed = true
		schemaAttrs["status"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryInternalDirectory(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["owner_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryLDAPDirectory(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["attributes_to_store"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["base_dn"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["client_certificate_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["dialect"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("ACTIVE_DIRECTORY"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ACTIVE_DIRECTORY", "OPENLDAP",
			),
		},
	}
	schemaAttrs["failover_host"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["failover_trusted_certificate_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["host"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["password_recovery"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"DISABLED", "VERIFY_2FA", "VERIFY_MAIL", "VERIFY_MAIL_AND_2FA",
			),
		},
	}
	schemaAttrs["port"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["search_bind_dn"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["search_bind_password"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 128),
		},
	}
	schemaAttrs["search_filter"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["tls"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"VERIFIED_PINNED", "VERIFIED", "SECURE_PINNED", "SECURE", "ENCRYPTED", "UNSECURE",
			),
		},
	}
	schemaAttrs["trusted_certificate_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryMaintenanceDirectory(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryOIDCDirectory(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["acr_values"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["attributes_to_store"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["client_id"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["client_secret"] = rsschema.StringAttribute{
		Required: true,
	}
	schemaAttrs["domain_restriction"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["enforces2fa"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["fully_resolved_issuer"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["issuer"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["logout_url"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["send_login_hint"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["vendor_escaped"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"GENERIC", "GOOGLE", "AZURE_AD",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupAccountGroup(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupAccountGroup_additionalObjects(false))
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupFolder(false),
		}
		attr.Computed = true
		schemaAttrs["folder"] = attr
	}
	schemaAttrs["last_used"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["provisioning_end_time"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["rights"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"MANAGER", "NORMAL",
			),
		},
	}
	schemaAttrs["visible_for_provisioning"] = rsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupAccountGroupLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupAccountGroup(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupAccountGroup_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVault(recurse),
		}
		attr.Computed = true
		schemaAttrs["vault"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupAuthorizedGroupsWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroup(recurse),
		},
		Optional: true,
	}
	schemaAttrs["group_count"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroup(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupGroup_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["admin"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["application_administration"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupAuditConfig(false),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["audit_config"] = attr
	}
	schemaAttrs["audit_requested"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["auditor"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["authorizing_group_auditing_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["authorizing_group_delegation_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["authorizing_group_membership_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["authorizing_group_provisioning_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["authorizing_group_types"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["classification_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["description"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["extended_access"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NOT_ALLOWED"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NOT_ALLOWED", "ONE_WEEK", "TWO_WEEKS", "TWO_WEEKS_NO_CONFIRM",
			),
		},
	}
	schemaAttrs["hide_audit_trail"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["nested_under_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["organizational_unit_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["private_group"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["record_trail"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["rotating_password_required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["single_managed"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["vault_recovery"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("FULL"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "RECOVERY_KEY_ONLY", "FULL",
			),
		},
	}
	schemaAttrs["vault_requires_activation"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAccount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupGroupAccount_additionalObjects(false))
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["directory_uuid"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["disconnected_nested"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["last_used"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["nested"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["provisioning_end_time"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["rights"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"MANAGER", "NORMAL",
			),
		},
	}
	schemaAttrs["two_factor_status"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["visible_for_provisioning"] = rsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAccountLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroupAccount(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAccountNesting(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["connected"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAccountStatus(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupFolder(recurse),
		}
		attr.Optional = true
		schemaAttrs["folder"] = attr
	}
	schemaAttrs["visible_for_provisioning"] = rsschema.BoolAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAccount_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAdminMail(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["body"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAudit(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupGroupAudit_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["accounts"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroupAuditAccount(false),
		},
		Optional: true,
	}
	schemaAttrs["comment"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["created_at"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["created_by"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["group_name"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name_on_audit"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["reviewed_at"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["reviewed_by"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["status"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NEW", "DRAFT", "UNDER_REVIEW", "FINAL",
			),
		},
	}
	schemaAttrs["submitted_at"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["submitted_by"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAuditAccount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["account_uuid"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["account_valid"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["action"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"APPROVE", "CHANGE_TO_MANAGER", "CHANGE_TO_NORMAL", "REMOVE", "CONNECT_NESTED",
			),
		},
	}
	schemaAttrs["comment"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["disconnected_nested"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["display_name"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_used"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["nested"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["rights"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAuditConfig(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["months"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Computed:    true,
		Validators: []validator.List{
			listvalidator.ValueStringsAre(
				stringvalidator.OneOf(
					"JANUARY", "FEBRUARY", "MARCH", "APRIL", "MAY", "JUNE", "JULY", "AUGUST", "SEPTEMBER", "OCTOBER", "NOVEMBER", "DECEMBER",
				),
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAuditLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroupAudit(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAudit_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAuditingInfo(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["audit_due_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["last_audit_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["nr_accounts"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["nr_disabled_accounts"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["nr_disabled_managers"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["nr_expired_vault_records"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["nr_managers"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["nr_vault_records_with_end_date"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupClassification(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupGroupClassification_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["authorizing_group_auditing_required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["authorizing_group_delegation_required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["authorizing_group_membership_required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["authorizing_group_provisioning_required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["default_classification"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["description"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["maximum_audit_interval"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
		Validators: []validator.Int64{
			int64validator.Between(0, 12),
		},
	}
	schemaAttrs["minimum_nr_managers"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(1),
		Validators: []validator.Int64{
			int64validator.AtLeast(1),
		},
	}
	schemaAttrs["record_trail_required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["required_months"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Validators: []validator.List{
			listvalidator.ValueStringsAre(
				stringvalidator.OneOf(
					"JANUARY", "FEBRUARY", "MARCH", "APRIL", "MAY", "JUNE", "JULY", "AUGUST", "SEPTEMBER", "OCTOBER", "NOVEMBER", "DECEMBER",
				),
			),
		},
	}
	schemaAttrs["rotating_password_required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["vault_requires_activation"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupClassificationInfo(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["nr_groups"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupClassificationLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroupClassification(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupClassificationPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupClassificationUpdate(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["classificaton_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupClassification_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupClassificationInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["info"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupClient(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupGroupClient_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["activation_required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["client_uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["group_uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["owner_uuid"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["technical_administrator_uuid"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupClientLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroupClient(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupClient_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupFolder(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupGroupFolder_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupFolderLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroupFolder(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupFolder_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupInfo(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["nr_accounts"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["nr_accounts_with_vault"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["nr_audits"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["nr_clients"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["nr_provisioned_systems"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["nr_vault_records"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroup(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["admin"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupPrimerLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Validators: []validator.List{
			listvalidator.ValueStringsAre(
				stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupSegmentedLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroup(recurse),
		},
		Optional: true,
	}
	schemaAttrs["segments"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsSegmentCount(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroup_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupAccountLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["accounts"] = attr
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsClientClientApplicationLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["administered_clients"] = attr
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["administered_systems"] = attr
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupAccountLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		attr.DeprecationMessage = "This property will be removed in a future version."
		schemaAttrs["admins"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupAuthorizedGroupsWrapper(recurse),
		}
		attr.Computed = true
		schemaAttrs["authorized_groups"] = attr
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsClientOAuth2ClientPermissionWithClientLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["client_permissions"] = attr
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupClientLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["clients"] = attr
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["content_administered_systems"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupAuditingInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["groupauditinginfo"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["groupinfo"] = attr
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsDirectoryAccountDirectorySummaryLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["helpdesk"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsMarkItemMarkers(recurse),
		}
		attr.Computed = true
		schemaAttrs["markers"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupAccount(recurse),
		}
		attr.Computed = true
		schemaAttrs["myaccount"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupAccount(recurse),
		}
		attr.Computed = true
		schemaAttrs["mydelegatedaccount"] = attr
	}
	{
		attr := resetListAttributeFlags(resourceSchemaAttrsGroupGroupPrimerLinkableWrapper(recurse)["items"].(rsschema.ListAttribute))
		attr.Computed = true
		schemaAttrs["nested_groups"] = attr
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsClientClientApplicationLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["owned_clients"] = attr
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsDirectoryAccountDirectoryLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["owned_directories"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningOwnedGroupOnSystemsWrapper(recurse),
		}
		attr.Computed = true
		schemaAttrs["owned_groups_on_system"] = attr
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsOrganizationOrganizationalUnitLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["owned_organizational_units"] = attr
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["owned_systems"] = attr
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupAuditLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["recent_audits"] = attr
	}
	schemaAttrs["requeststatus"] = rsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsServiceaccountServiceAccountLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["service_accounts"] = attr
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupProvisioningGroupLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["systems"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVault(recurse),
		}
		attr.Computed = true
		schemaAttrs["vault"] = attr
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsWebhookWebhookLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["webhooks"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupsAuditStats(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["audited_groups"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["classifications"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroupClassification(recurse),
		},
		Optional: true,
	}
	schemaAttrs["overdue_audit_groups"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["overdue_vault_policies"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["unaudited_groups"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["valid_vault_policies"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["vaults_without_policies"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupProvisioningGroup(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupProvisioningGroup_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["activation_required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["group_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningGroupOnSystem(false),
		}
		attr.Computed = true
		attr.PlanModifiers = []planmodifier.Object{objectplanmodifier.UseStateForUnknown()}
		schemaAttrs["group_on_system"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupProvisioningGroupLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupProvisioningGroup(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupProvisioningGroup_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupVaultVaultRecord(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsVaultVaultRecord_additionalObjects(false))
	}
	schemaAttrs["group_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["color"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NONE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "GREEN", "RED", "BLUE", "DARK", "PINK_LAVENDER", "CRIMSON_RED", "MIDDLE_YELLOW", "ANDROID_GREEN", "SAGE", "ARTICHOKE",
			),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["share_end_time"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["derived"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["filename"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["types"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["url"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["warning_period"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"AT_EXPIRATION", "TWO_WEEKS", "ONE_MONTH", "TWO_MONTHS", "THREE_MONTHS", "SIX_MONTHS", "NEVER",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsLaunchpadDisplayedLaunchpadTile(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["group_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["identicon_code"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["logo"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsLaunchpadLaunchpadTilePrimer(recurse),
		}
		attr.Optional = true
		schemaAttrs["tile"] = attr
	}
	schemaAttrs["title"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["uri"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsLaunchpadDisplayedLaunchpadTiles(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsLaunchpadDisplayedLaunchpadTile(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsLaunchpadLaunchpadTile(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsLaunchpadLaunchpadTile_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["application_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["group_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["identicon_code"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["launchpad_launchpad_tile_type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["logo"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
	}
	schemaAttrs["vault_record_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsLaunchpadVaultRecordLaunchpadTile(false),
		}
		attr.Optional = true
		schemaAttrs["vault_record_launchpad_tile"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsLaunchpadSsoApplicationLaunchpadTile(false),
		}
		attr.Optional = true
		schemaAttrs["sso_application_launchpad_tile"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsLaunchpadManualLaunchpadTile(false),
		}
		attr.Optional = true
		schemaAttrs["manual_launchpad_tile"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsLaunchpadLaunchpadTileLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsLaunchpadLaunchpadTile(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsLaunchpadLaunchpadTilePrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsLaunchpadLaunchpadTile_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsLaunchpadManualLaunchpadTile(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["title"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uri"] = rsschema.StringAttribute{
		Required: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsLaunchpadSsoApplicationLaunchpadTile(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["uri"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsLaunchpadVaultRecordLaunchpadTile(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsLicenseKeyHubLicenseInfo(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["current_license_status"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"OK", "NOT_YET_VALID", "EXPIRED", "TERMINATED", "SOFT_LIMIT_REACHED", "HARD_LIMIT_REACHED", "HARD_LIMIT_EXCEEDED", "WRONG_DOMAIN", "PRO_LIMIT_EXCEEDED", "FEATURE_IN_USE",
			),
		},
	}
	schemaAttrs["customer_company"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 100),
		},
	}
	schemaAttrs["customer_contact"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 100),
		},
	}
	schemaAttrs["customer_domains"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Validators: []validator.List{
			listvalidator.ValueStringsAre(
				stringvalidator.UTF8LengthBetween(0, 100),
			),
		},
	}
	schemaAttrs["details"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
	}
	schemaAttrs["expiration_time"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["features"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Validators: []validator.List{
			listvalidator.ValueStringsAre(
				stringvalidator.OneOf(
					"CLUSTER_HA", "CLUSTER_HA_ENTERPRISE", "WORKFLOWS", "NESTED_GROUPS", "ENTERPRISE_ORGANISATION", "COMPLIANCE_PLUS", "OFFLINE_MODE", "SERVICE_ACCOUNTS",
				),
			),
		},
	}
	schemaAttrs["issue_time"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["key_hub_domain"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["license_key"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["not_before_time"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["users_hard_limit"] = rsschema.Int64Attribute{
		Optional: true,
	}
	schemaAttrs["users_pro_limit"] = rsschema.Int64Attribute{
		Optional: true,
	}
	schemaAttrs["users_soft_limit"] = rsschema.Int64Attribute{
		Optional: true,
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 36),
		},
	}
	schemaAttrs["version"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	return schemaAttrs
}
func resourceSchemaAttrsMarkItemMarker(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["level"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"INFO", "WARNING",
			),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"TLS_DISABLED", "TLS_UNVERIFIED", "WEAK_PASSWORD_HASHING", "GROUP_NO_MANAGER", "GROUP_ONE_MANAGER", "GROUP_UNREADABLE_VAULT", "GROUP_UNRECOVERABLE_VAULT", "GROUP_CRITERIA_UNSATISFIED_AUDIT_INTERVAL", "GROUP_CRITERIA_UNSATISFIED_AUDIT_MONTHS", "GROUP_CRITERIA_UNSATISFIED_AUTHORIZING_GROUP_PROVISIONING", "GROUP_CRITERIA_UNSATISFIED_AUTHORIZING_GROUP_MEMBERSHIP", "GROUP_CRITERIA_UNSATISFIED_AUTHORIZING_GROUP_DELEGATION", "GROUP_CRITERIA_UNSATISFIED_AUTHORIZING_GROUP_AUDITING", "GROUP_CRITERIA_UNSATISFIED_RECORD_TRAIL", "GROUP_CRITERIA_UNSATISFIED_ROTATING_PASSWORD_REQUIRED", "GROUP_CRITERIA_UNSATISFIED_VAULT_REQUIRES_ACTIVATION", "GROUP_CRITERIA_UNSATISFIED_MINIMUM_NR_MANAGERS",
			),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsMarkItemMarker_parameters(recurse),
		}
		attr.Optional = true
		schemaAttrs["parameters"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsMarkItemMarker_parameters(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsMarkItemMarkers(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["markers"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsMarkItemMarker(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsNestedAuthInternalAccount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["account_directory_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["activation_code"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["activation_deadline"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["company"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["first_name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["last_name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["status"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"UNVERIFIED", "NOT_ACTIVATED", "ACTIVATION_EXPIRED", "ACTIVATED",
			),
		},
	}
	schemaAttrs["telephone"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsNestedClientOAuth2ClientPermission(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsClientOAuth2ClientPermission_additionalObjects(false))
	}
	schemaAttrs["client_application_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["for_group_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["for_system_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["value"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ACCOUNTS_QUERY", "ACCOUNTS_REMOVE", "CLIENTS_CREATE", "CLIENTS_QUERY", "GROUPONSYSTEM_CREATE", "GROUPS_CREATE", "GROUPS_GRANT_PERMISSIONS_AFTER_CREATE", "GROUPS_QUERY", "GROUPS_SET_CLASSIFICATION", "GROUP_FULL_VAULT_ACCESS", "GROUP_LAUNCHPADTILES", "GROUP_READ_CONTENTS", "GROUP_SET_AUTHORIZATION", "PROVISIONEDSYSTEMS_QUERY", "SERVICE_ACCOUNTS_CREATE", "SERVICE_ACCOUNTS_QUERY", "SERVICE_ACCOUNTS_UPDATE",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsNestedGroupAccountGroup(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupAccountGroup_additionalObjects(false))
	}
	schemaAttrs["account_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupFolder(false),
		}
		attr.Computed = true
		schemaAttrs["folder"] = attr
	}
	schemaAttrs["last_used"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["provisioning_end_time"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["rights"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"MANAGER", "NORMAL",
			),
		},
	}
	schemaAttrs["visible_for_provisioning"] = rsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsNestedGroupGroupAccount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupGroupAccount_additionalObjects(false))
	}
	schemaAttrs["group_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["directory_uuid"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["disconnected_nested"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["last_used"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["nested"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["provisioning_end_time"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["rights"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"MANAGER", "NORMAL",
			),
		},
	}
	schemaAttrs["two_factor_status"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["visible_for_provisioning"] = rsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsNestedGroupGroupAudit(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupGroupAudit_additionalObjects(false))
	}
	schemaAttrs["group_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["accounts"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroupAuditAccount(false),
		},
		Optional: true,
	}
	schemaAttrs["comment"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["created_at"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["created_by"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["group_name"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name_on_audit"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["reviewed_at"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["reviewed_by"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["status"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NEW", "DRAFT", "UNDER_REVIEW", "FINAL",
			),
		},
	}
	schemaAttrs["submitted_at"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["submitted_by"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsNestedOrganizationAccountOrganizationalUnit(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsOrganizationAccountOrganizationalUnit_additionalObjects(false))
	}
	schemaAttrs["account_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsNestedOrganizationOrganizationalUnitAccount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsOrganizationOrganizationalUnitAccount_additionalObjects(false))
	}
	schemaAttrs["organizational_unit_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["directory_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsNestedProvisioningGroupOnSystem(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProvisioningGroupOnSystem_additionalObjects(false))
	}
	schemaAttrs["provisioned_system_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["display_name"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["name_in_system"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"POSIX_GROUP", "GROUP_OF_NAMES", "GROUP_OF_UNIQUE_NAMES", "GROUP", "AZURE_ROLE", "AZURE_UNIFIED_GROUP", "AZURE_SECURITY_GROUP",
			),
		},
	}
	schemaAttrs["short_name_in_system"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["owner_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsNestedProvisioningProvisionedAccount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProvisioningProvisionedAccount_additionalObjects(false))
	}
	schemaAttrs["provisioned_system_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["uid"] = rsschema.Int64Attribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Int64{int64planmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsNestedProvisioningProvisionedSystemSyncLog(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProvisioningProvisionedSystemSyncLog_additionalObjects(false))
	}
	schemaAttrs["provisioned_system_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["created_at"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["errors"] = rsschema.Int64Attribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Int64{int64planmodifier.UseStateForUnknown()},
	}
	schemaAttrs["log"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["modifications"] = rsschema.Int64Attribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Int64{int64planmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsNestedServiceaccountServiceAccountGroup(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsServiceaccountServiceAccountGroup_additionalObjects(false))
	}
	schemaAttrs["service_account_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["display_name"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["name_in_system"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"POSIX_GROUP", "GROUP_OF_NAMES", "GROUP_OF_UNIQUE_NAMES", "GROUP", "AZURE_ROLE", "AZURE_UNIFIED_GROUP", "AZURE_SECURITY_GROUP",
			),
		},
	}
	schemaAttrs["short_name_in_system"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsNestedWebhookWebhookDelivery(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsWebhookWebhookDelivery_additionalObjects(false))
	}
	schemaAttrs["webhook_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsWebhookWebhookPush(false),
		}
		attr.Optional = true
		schemaAttrs["payload"] = attr
	}
	schemaAttrs["reponse_headers"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["request_headers"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["response"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["status"] = rsschema.Int64Attribute{
		Optional: true,
	}
	schemaAttrs["time"] = rsschema.Int64Attribute{
		Optional: true,
	}
	schemaAttrs["trigger_time"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsNotificationCertificateExpiredNotification(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsCertificateCertificate(recurse),
		}
		attr.Optional = true
		schemaAttrs["certificate"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryLDAPDirectory(recurse),
		}
		attr.Optional = true
		schemaAttrs["directory"] = attr
	}
	schemaAttrs["expiration"] = rsschema.StringAttribute{
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientLdapClient(recurse),
		}
		attr.Optional = true
		schemaAttrs["ldap_client"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedSystem(recurse),
		}
		attr.Optional = true
		schemaAttrs["system"] = attr
	}
	schemaAttrs["usage"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"LDAP_DIRECTORY", "PROVISIONED_AD", "PROVISIONED_LDAP", "WEBHOOK", "LDAP_CLIENT", "LDAP_SERVER_SETTING", "GLOBAL_TRUSTED_CERTIFICATE", "IDP", "KEYHUB",
			),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsWebhookWebhook(recurse),
		}
		attr.Optional = true
		schemaAttrs["webhook"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsNotificationGroupAuditRequiredNotification(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["due_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroup(recurse),
		}
		attr.Optional = true
		schemaAttrs["group"] = attr
	}
	schemaAttrs["notification_group_audit_required_notification_type"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"CONFORM", "PERIODIC", "REQUESTED",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsNotificationGroupEditRequiredNotification(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroup(recurse),
		}
		attr.Optional = true
		schemaAttrs["group"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsNotificationGroupEditRequiredNotification_parameters(recurse),
		}
		attr.Optional = true
		schemaAttrs["parameters"] = attr
	}
	schemaAttrs["reason"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ONE_MANAGER", "CRITERIA_UNSATISFIED_AUDIT_INTERVAL", "CRITERIA_UNSATISFIED_AUDIT_MONTHS", "CRITERIA_UNSATISFIED_AUTHORIZING_GROUP_PROVISIONING", "CRITERIA_UNSATISFIED_AUTHORIZING_GROUP_MEMBERSHIP", "CRITERIA_UNSATISFIED_AUTHORIZING_GROUP_DELEGATION", "CRITERIA_UNSATISFIED_AUTHORIZING_GROUP_AUDITING", "CRITERIA_UNSATISFIED_RECORD_TRAIL", "CRITERIA_UNSATISFIED_ROTATING_PASSWORD_REQUIRED", "CRITERIA_UNSATISFIED_VAULT_REQUIRES_ACTIVATION", "CRITERIA_UNSATISFIED_MINIMUM_NR_MANAGERS",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsNotificationGroupEditRequiredNotification_parameters(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsNotificationInvalidSignaturesDetectedNotification(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsNotificationLicenseStatusNotification(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["active_accounts"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsLicenseKeyHubLicenseInfo(recurse),
		}
		attr.Optional = true
		schemaAttrs["license_info"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsNotificationModificationRequestNotification(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["admins"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
	}
	schemaAttrs["groups"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestModificationRequest(recurse),
		}
		attr.Optional = true
		schemaAttrs["request"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsNotificationNotification(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsNotificationNotifications(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsNotificationNotification(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsNotificationOldApiVersionUsageNotification(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["api_version"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientOAuth2Client(recurse),
		}
		attr.Optional = true
		schemaAttrs["client"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsNotificationProvisionConfigRequiredNotification(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["systems"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Validators: []validator.List{
			listvalidator.ValueStringsAre(
				stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsNotificationRotatingPasswordRequiredNotification(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["groups"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Validators: []validator.List{
			listvalidator.ValueStringsAre(
				stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsNotificationUpdateAvailableNotification(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["released_at"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsNotificationVaultRecordExpiredNotification(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultRecord(recurse),
		}
		attr.Optional = true
		schemaAttrs["record"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationAccountOrganizationalUnit(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsOrganizationAccountOrganizationalUnit_additionalObjects(false))
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationAccountOrganizationalUnitLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsOrganizationAccountOrganizationalUnit(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationAccountOrganizationalUnit_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationOrganizationalUnit(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsOrganizationOrganizationalUnit_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["depth"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["description"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["owner_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["parent_uuid"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationOrganizationalUnitAccount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsOrganizationOrganizationalUnitAccount_additionalObjects(false))
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["directory_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationOrganizationalUnitAccountLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsOrganizationOrganizationalUnitAccount(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationOrganizationalUnitAccount_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationOrganizationalUnitLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsOrganizationOrganizationalUnit(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationOrganizationalUnitPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationOrganizationalUnitPrimerLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Validators: []validator.List{
			listvalidator.ValueStringsAre(
				stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationOrganizationalUnit_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	{
		attr := resetListAttributeFlags(resourceSchemaAttrsOrganizationOrganizationalUnitPrimerLinkableWrapper(recurse)["items"].(rsschema.ListAttribute))
		attr.Optional = true
		schemaAttrs["create_as_parent_of"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningAbstractProvisionedLDAP(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningAbstractProvisionedLDAP_attributes(recurse),
		}
		attr.Optional = true
		schemaAttrs["attributes"] = attr
	}
	schemaAttrs["base_dn"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["bind_dn"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["bind_password"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 128),
		},
	}
	schemaAttrs["client_certificate_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["failover_host"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["failover_trusted_certificate_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["group_dn"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["host"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["object_classes"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["port"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["service_account_dn"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["ssh_public_key_supported"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["tls"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"VERIFIED_PINNED", "VERIFIED", "SECURE_PINNED", "SECURE", "ENCRYPTED", "UNSECURE",
			),
		},
	}
	schemaAttrs["trusted_certificate_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["user_dn"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningAbstractProvisionedLDAP_attributes(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningAccountProvisioningStatus(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["description"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["result"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"OK", "CONFIGURATION_REQUIRED", "ERROR",
			),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupProvisioningGroup(recurse),
		}
		attr.Optional = true
		schemaAttrs["system"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningAccountProvisioningStatusReport(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["status"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProvisioningAccountProvisioningStatus(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningCircuitBreakerStatistics(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["number_of_failed_calls"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["number_of_not_permitted_calls"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["number_of_successful_calls"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["state"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"CLOSED", "OPEN", "HALF_OPEN",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningGroupOnSystem(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProvisioningGroupOnSystem_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["display_name"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["name_in_system"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"POSIX_GROUP", "GROUP_OF_NAMES", "GROUP_OF_UNIQUE_NAMES", "GROUP", "AZURE_ROLE", "AZURE_UNIFIED_GROUP", "AZURE_SECURITY_GROUP",
			),
		},
	}
	schemaAttrs["short_name_in_system"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["owner_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningGroupOnSystemLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProvisioningGroupOnSystem(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningGroupOnSystemPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["display_name"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["name_in_system"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"POSIX_GROUP", "GROUP_OF_NAMES", "GROUP_OF_UNIQUE_NAMES", "GROUP", "AZURE_ROLE", "AZURE_UNIFIED_GROUP", "AZURE_SECURITY_GROUP",
			),
		},
	}
	schemaAttrs["short_name_in_system"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningGroupOnSystemTypes(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["types"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Validators: []validator.List{
			listvalidator.ValueStringsAre(
				stringvalidator.OneOf(
					"POSIX_GROUP", "GROUP_OF_NAMES", "GROUP_OF_UNIQUE_NAMES", "GROUP", "AZURE_ROLE", "AZURE_UNIFIED_GROUP", "AZURE_SECURITY_GROUP",
				),
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningGroupOnSystem_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupProvisioningGroupLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["provgroups"] = attr
	}
	{
		attr := resetListAttributeFlags(resourceSchemaAttrsServiceaccountServiceAccountPrimerLinkableWrapper(recurse)["items"].(rsschema.ListAttribute))
		attr.Optional = true
		schemaAttrs["service_accounts"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningGroupProvisioningStatus(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupFolder(recurse),
		}
		attr.Optional = true
		schemaAttrs["folder"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroup(recurse),
		}
		attr.Optional = true
		schemaAttrs["group"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningGroupProvisioningStatus_provisioningDuration(recurse),
		}
		attr.Optional = true
		schemaAttrs["provisioning_duration"] = attr
	}
	schemaAttrs["provisioning_end_time"] = rsschema.StringAttribute{
		Required: true,
	}
	schemaAttrs["provisioning_permission_end_time"] = rsschema.StringAttribute{
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningAccountProvisioningStatusReport(recurse),
		}
		attr.Optional = true
		schemaAttrs["status_report"] = attr
	}
	schemaAttrs["visible_on_dashboard"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningGroupProvisioningStatus_provisioningDuration(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["nanos"] = rsschema.Int64Attribute{
		Optional: true,
	}
	schemaAttrs["seconds"] = rsschema.Int64Attribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningOwnedGroupOnSystemsWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProvisioningGroupOnSystem(recurse),
		},
		Optional: true,
	}
	schemaAttrs["unlinked_count"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionNumberSequence(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProvisioningProvisionNumberSequence_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["account_count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["next_uid"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(2000),
		Validators: []validator.Int64{
			int64validator.Between(2000, 60000),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionNumberSequenceLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProvisioningProvisionNumberSequence(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionNumberSequence_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	{
		attr := resetListAttributeFlags(resourceSchemaAttrsProvisioningProvisionedSystemPrimerLinkableWrapper(recurse)["items"].(rsschema.ListAttribute))
		attr.Computed = true
		schemaAttrs["systems"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedAD(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["sam_account_name_scheme"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"OMIT", "TRUNCATE", "TRANSFER", "TRANSFER_TRUNCATE", "USERNAME",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedAccount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProvisioningProvisionedAccount_additionalObjects(false))
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["uid"] = rsschema.Int64Attribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Int64{int64planmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedAccountLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProvisioningProvisionedAccount(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedAccount_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedAzureOIDCDirectory(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["directory_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["tenant"] = rsschema.StringAttribute{
		Required: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedAzureSyncLDAPDirectory(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["client_id"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["client_secret"] = rsschema.StringAttribute{
		Required: true,
	}
	schemaAttrs["directory_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["tenant"] = rsschema.StringAttribute{
		Required: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedAzureTenant(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["client_id"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["client_secret"] = rsschema.StringAttribute{
		Required: true,
	}
	schemaAttrs["idp_domain"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["tenant"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedInternalLDAP(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientLdapClient(recurse),
		}
		attr.Optional = true
		schemaAttrs["client"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedLDAP(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["gid"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["hashing_scheme"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"SSHA", "PBKDF2",
			),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionNumberSequence(recurse),
		}
		attr.Required = true
		schemaAttrs["numbering"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedLDAPDirectory(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["directory_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["group_dn"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedSystem(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProvisioningProvisionedSystem_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["organizational_unit_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["account_count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["content_administrator_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["external_uuid"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["owner_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["self_service_existing_groups"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["self_service_new_groups"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["self_service_service_accounts"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["should_destroy_unknown_accounts"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["technical_administrator_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["username_prefix"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedAzureOIDCDirectory(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_azure_oidc_directory"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningAbstractProvisionedLDAP(false),
		}
		attr.Optional = true
		schemaAttrs["abstract_provisioned_ldap"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedLDAP(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_ldap"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedAzureTenant(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_azure_tenant"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedAzureSyncLDAPDirectory(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_azure_sync_ldap_directory"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedAD(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_a_d"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedInternalLDAP(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_internal_ldap"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedLDAPDirectory(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_ldap_directory"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProvisioningProvisionedSystem(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedSystemPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["organizational_unit_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedSystemPrimerLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Validators: []validator.List{
			listvalidator.ValueStringsAre(
				stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedSystemSyncLog(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProvisioningProvisionedSystemSyncLog_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["created_at"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["errors"] = rsschema.Int64Attribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Int64{int64planmodifier.UseStateForUnknown()},
	}
	schemaAttrs["log"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["modifications"] = rsschema.Int64Attribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Int64{int64planmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedSystemSyncLogLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProvisioningProvisionedSystemSyncLog(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedSystemSyncLog_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedSystem_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedAccount(recurse),
		}
		attr.Computed = true
		schemaAttrs["account"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsClientOAuth2ClientPermissionWithClientLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["issued_permissions"] = attr
	}
	schemaAttrs["login_name"] = rsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisioningManagementPermissions(recurse),
		}
		attr.Computed = true
		schemaAttrs["management_permissions"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsMarkItemMarkers(recurse),
		}
		attr.Computed = true
		schemaAttrs["markers"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningCircuitBreakerStatistics(recurse),
		}
		attr.Computed = true
		schemaAttrs["statistics"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningGroupOnSystemTypes(recurse),
		}
		attr.Computed = true
		schemaAttrs["supported_group_types"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisioningManagementPermissions(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["create_new_groups_allowed"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["create_service_accounts_allowed"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["reuse_existing_groups_allowed"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisioningStatus(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["groups"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProvisioningGroupProvisioningStatus(recurse),
		},
		Optional: true,
	}
	schemaAttrs["ignore_errors"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["restricted_by_license"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningTokenPassword(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["password"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestAbstractApplicationModificationRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["application_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestAbstractOrganizationalUnitModificationRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["organizational_unit_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestAbstractProvisionedSystemModificationRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["system_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestAcceptGrantAccessRequestParameters(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestAcceptGrantAccessRequestParameters_accessDuration(recurse),
		}
		attr.Optional = true
		schemaAttrs["access_duration"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestAcceptGrantAccessRequestParameters_accessDuration(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["nanos"] = rsschema.Int64Attribute{
		Optional: true,
	}
	schemaAttrs["seconds"] = rsschema.Int64Attribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestAcceptJoinGroupRequestParameters(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["make_manager"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestAcceptModificationRequestParameters(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsRequestAddGroupAdminRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["new_admin_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["private_key"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestCreateGroupOnSystemRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["activation_required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["group_on_system_type"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"POSIX_GROUP", "GROUP_OF_NAMES", "GROUP_OF_UNIQUE_NAMES", "GROUP", "AZURE_ROLE", "AZURE_UNIFIED_GROUP", "AZURE_SECURITY_GROUP",
			),
		},
	}
	schemaAttrs["name_in_system"] = rsschema.StringAttribute{
		Required: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestCreateGroupRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["group_name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestCreateServiceAccountRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["username"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestDisable2FARequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["subject"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestEnableTechnicalAdministrationRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsRequestExtendAccessRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["extend_until"] = rsschema.StringAttribute{
		Required: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestGrantAccessRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsRequestGrantApplicationRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsRequestGrantClientPermissionRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["permission_type"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ACCOUNTS_QUERY", "ACCOUNTS_REMOVE", "CLIENTS_CREATE", "CLIENTS_QUERY", "GROUPONSYSTEM_CREATE", "GROUPS_CREATE", "GROUPS_GRANT_PERMISSIONS_AFTER_CREATE", "GROUPS_QUERY", "GROUPS_SET_CLASSIFICATION", "GROUP_FULL_VAULT_ACCESS", "GROUP_LAUNCHPADTILES", "GROUP_READ_CONTENTS", "GROUP_SET_AUTHORIZATION", "PROVISIONEDSYSTEMS_QUERY", "SERVICE_ACCOUNTS_CREATE", "SERVICE_ACCOUNTS_QUERY", "SERVICE_ACCOUNTS_UPDATE",
			),
		},
	}
	schemaAttrs["system_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestGrantGroupOnSystemRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["activation_required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningGroupOnSystem(recurse),
		}
		attr.Required = true
		schemaAttrs["group_on_system"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestGrantGroupOnSystemRequestRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["activation_required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningGroupOnSystem(recurse),
		}
		attr.Required = true
		schemaAttrs["group_on_system"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestGrantServiceAccountGroupRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningGroupOnSystem(recurse),
		}
		attr.Required = true
		schemaAttrs["group_on_system"] = attr
	}
	schemaAttrs["service_account_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestJoinGroupRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsRequestJoinVaultRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsRequestModificationRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsRequestModificationRequest_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["account_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["comment"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["feedback"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["group_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["mail_key"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["request_modification_request_type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["status"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"REQUESTED", "ALLOWED", "DISALLOWED", "CANCELLED",
			),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestEnableTechnicalAdministrationRequest(false),
		}
		attr.Optional = true
		schemaAttrs["enable_technical_administration_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestAbstractApplicationModificationRequest(false),
		}
		attr.Optional = true
		schemaAttrs["abstract_application_modification_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestTransferApplicationAdministrationRequest(false),
		}
		attr.Optional = true
		schemaAttrs["transfer_application_administration_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestPasswordResetRequest(false),
		}
		attr.Optional = true
		schemaAttrs["password_reset_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestAbstractProvisionedSystemModificationRequest(false),
		}
		attr.Optional = true
		schemaAttrs["abstract_provisioned_system_modification_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestTransferProvisionedSystemOwnershipRequest(false),
		}
		attr.Optional = true
		schemaAttrs["transfer_provisioned_system_ownership_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestAddGroupAdminRequest(false),
		}
		attr.Optional = true
		schemaAttrs["add_group_admin_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestAbstractOrganizationalUnitModificationRequest(false),
		}
		attr.Optional = true
		schemaAttrs["abstract_organizational_unit_modification_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestCreateGroupRequest(false),
		}
		attr.Optional = true
		schemaAttrs["create_group_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestRemoveProvisionedSystemRequest(false),
		}
		attr.Optional = true
		schemaAttrs["remove_provisioned_system_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestGrantApplicationRequest(false),
		}
		attr.Optional = true
		schemaAttrs["grant_application_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestCreateGroupOnSystemRequest(false),
		}
		attr.Optional = true
		schemaAttrs["create_group_on_system_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestSetupNestedGroupRequest(false),
		}
		attr.Optional = true
		schemaAttrs["setup_nested_group_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestVerifyInternalAccountRequest(false),
		}
		attr.Optional = true
		schemaAttrs["verify_internal_account_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestGrantGroupOnSystemRequestRequest(false),
		}
		attr.Optional = true
		schemaAttrs["grant_group_on_system_request_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestJoinGroupRequest(false),
		}
		attr.Optional = true
		schemaAttrs["join_group_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestTransferOrganizationalUnitOwnershipRequest(false),
		}
		attr.Optional = true
		schemaAttrs["transfer_organizational_unit_ownership_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestDisable2FARequest(false),
		}
		attr.Optional = true
		schemaAttrs["disable2fa_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestTransferProvisionedSystemContentAdministrationRequest(false),
		}
		attr.Optional = true
		schemaAttrs["transfer_provisioned_system_content_administration_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestGrantGroupOnSystemRequest(false),
		}
		attr.Optional = true
		schemaAttrs["grant_group_on_system_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestTransferApplicationOwnershipRequest(false),
		}
		attr.Optional = true
		schemaAttrs["transfer_application_ownership_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestTransferGroupOnSystemOwnershipRequest(false),
		}
		attr.Optional = true
		schemaAttrs["transfer_group_on_system_ownership_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestTransferServiceAccountAdministrationRequest(false),
		}
		attr.Optional = true
		schemaAttrs["transfer_service_account_administration_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestTransferAuditorGroupRequest(false),
		}
		attr.Optional = true
		schemaAttrs["transfer_auditor_group_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestReviewAuditRequest(false),
		}
		attr.Optional = true
		schemaAttrs["review_audit_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestUpdateGroupMembershipRequest(false),
		}
		attr.Optional = true
		schemaAttrs["update_group_membership_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestExtendAccessRequest(false),
		}
		attr.Optional = true
		schemaAttrs["extend_access_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestRemoveGroupRequest(false),
		}
		attr.Optional = true
		schemaAttrs["remove_group_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestRevokeAdminRequest(false),
		}
		attr.Optional = true
		schemaAttrs["revoke_admin_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestGrantServiceAccountGroupRequest(false),
		}
		attr.Optional = true
		schemaAttrs["grant_service_account_group_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestSetupAuthorizingGroupRequest(false),
		}
		attr.Optional = true
		schemaAttrs["setup_authorizing_group_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestTransferProvisionedSystemAdministrationRequest(false),
		}
		attr.Optional = true
		schemaAttrs["transfer_provisioned_system_administration_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestGrantAccessRequest(false),
		}
		attr.Optional = true
		schemaAttrs["grant_access_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestJoinVaultRequest(false),
		}
		attr.Optional = true
		schemaAttrs["join_vault_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestRemoveOrganizationalUnitRequest(false),
		}
		attr.Optional = true
		schemaAttrs["remove_organizational_unit_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestCreateServiceAccountRequest(false),
		}
		attr.Optional = true
		schemaAttrs["create_service_account_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestGrantClientPermissionRequest(false),
		}
		attr.Optional = true
		schemaAttrs["grant_client_permission_request"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestModificationRequestLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRequestModificationRequest(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestModificationRequest_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestAcceptModificationRequestParameters(recurse),
		}
		attr.Optional = true
		schemaAttrs["accept_params"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsRequestPasswordResetRequestStatus(recurse),
		}
		attr.Computed = true
		schemaAttrs["reset_status"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestPasswordResetRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["new_vault_and_directory_password"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["new_vault_password"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["unsynced_password"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestPasswordResetRequestStatus(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["cooldown_end"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["managers"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
	}
	schemaAttrs["nr_accepted"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["reset_via_mail"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "REACTIVATION", "EXTERNAL",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestRemoveGroupRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["group_name"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestRemoveOrganizationalUnitRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["organizational_unit_name"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestRemoveProvisionedSystemRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["system_name"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestReviewAuditRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsRequestRevokeAdminRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["admin_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestSetupAuthorizingGroupRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["authorizing_group_type"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"PROVISIONING", "MEMBERSHIP", "DELEGATION", "AUDITING",
			),
		},
	}
	schemaAttrs["connect"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["requesting_group_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestSetupNestedGroupRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["account_action"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"REMOVE", "CONVERT", "RETAIN",
			),
		},
	}
	schemaAttrs["connect"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["requesting_group_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestTransferApplicationAdministrationRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsRequestTransferApplicationOwnershipRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsRequestTransferAuditorGroupRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsRequestTransferGroupOnSystemOwnershipRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningGroupOnSystem(recurse),
		}
		attr.Required = true
		schemaAttrs["group_on_system"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestTransferOrganizationalUnitOwnershipRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsRequestTransferProvisionedSystemAdministrationRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsRequestTransferProvisionedSystemContentAdministrationRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsRequestTransferProvisionedSystemOwnershipRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsRequestTransferServiceAccountAdministrationRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["service_account_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestUpdateGroupMembershipRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["account_to_update_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["current_end_date"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["current_rights"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["rights"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"MANAGER", "NORMAL",
			),
		},
	}
	schemaAttrs["update_group_membership_type"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ADD", "MODIFY", "REMOVE",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsRequestVerifyInternalAccountRequest(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["internal_account_name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsServiceaccountServiceAccount_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["system_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["description"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["password_uuid"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["password_rotation"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"MANUAL", "MANUAL_STORED_IN_VAULT", "DAILY",
			),
		},
	}
	schemaAttrs["technical_administrator_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountGroup(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsServiceaccountServiceAccountGroup_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["display_name"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["name_in_system"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"POSIX_GROUP", "GROUP_OF_NAMES", "GROUP_OF_UNIQUE_NAMES", "GROUP", "AZURE_ROLE", "AZURE_UNIFIED_GROUP", "AZURE_SECURITY_GROUP",
			),
		},
	}
	schemaAttrs["short_name_in_system"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountGroupLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsServiceaccountServiceAccountGroup(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountGroup_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsServiceaccountServiceAccount(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["system_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountPrimerLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Validators: []validator.List{
			listvalidator.ValueStringsAre(
				stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountStatus(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["account_enabled"] = rsschema.BoolAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccount_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsServiceaccountServiceAccountGroupLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["groups"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGeneratedSecret(recurse),
		}
		attr.Optional = true
		schemaAttrs["secret"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountsAuditStats(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["disabled_count"] = rsschema.Int64Attribute{
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsServiceaccountServiceAccountsAuditStats_passwordSchemeEnabledStats(recurse),
		}
		attr.Optional = true
		schemaAttrs["password_scheme_enabled_stats"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsServiceaccountServiceAccountsAuditStats_systemStats(recurse),
		}
		attr.Optional = true
		schemaAttrs["system_stats"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountsAuditStats_passwordSchemeEnabledStats(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountsAuditStats_systemStats(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsSimpleStringValue(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["value"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsSimpleVersionInfo(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["contract_versions"] = rsschema.ListAttribute{
		ElementType: types.Int64Type,
		Optional:    true,
	}
	schemaAttrs["key_hub_version"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultDeletedVaultHolder(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsVaultDeletedVaultHolder_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["record_count"] = rsschema.Int64Attribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Int64{int64planmodifier.UseStateForUnknown()},
	}
	schemaAttrs["vault_deleted_vault_holder_type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultDeletedVaultHolderLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsVaultDeletedVaultHolder(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultDeletedVaultHolder_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVault(recurse),
		}
		attr.Computed = true
		schemaAttrs["vault"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultDeletedVaultRecovery(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["prefix"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["private_key"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["target_group_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultMoveVaultRecord(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["account_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["action"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("MOVE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"MOVE", "COPY", "SHARE",
			),
		},
	}
	schemaAttrs["group_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultMoveVaultRecord_shareDuration(recurse),
		}
		attr.Optional = true
		schemaAttrs["share_duration"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultMoveVaultRecord_shareDuration(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["nanos"] = rsschema.Int64Attribute{
		Optional: true,
	}
	schemaAttrs["seconds"] = rsschema.Int64Attribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultPasswordMetadata(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["dictionary"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["duplicate"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["hash"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["length"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["lower_count"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["number_count"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["special_count"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["strength"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["upper_count"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVault(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["access_available"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["records"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsVaultVaultRecord(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultHolder(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecord(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsVaultVaultRecord_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["color"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NONE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "GREEN", "RED", "BLUE", "DARK", "PINK_LAVENDER", "CRIMSON_RED", "MIDDLE_YELLOW", "ANDROID_GREEN", "SAGE", "ARTICHOKE",
			),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["share_end_time"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["derived"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["filename"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["types"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["url"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["warning_period"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"AT_EXPIRATION", "TWO_WEEKS", "ONE_MONTH", "TWO_MONTHS", "THREE_MONTHS", "SIX_MONTHS", "NEVER",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecordLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsVaultVaultRecord(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecordPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["color"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NONE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "GREEN", "RED", "BLUE", "DARK", "PINK_LAVENDER", "CRIMSON_RED", "MIDDLE_YELLOW", "ANDROID_GREEN", "SAGE", "ARTICHOKE",
			),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["share_end_time"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecordPrimerLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Validators: []validator.List{
			listvalidator.ValueStringsAre(
				stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecordSecrets(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["comment"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["file"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["password"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["totp"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["write_totp"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecordShare(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["name"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ACCOUNT", "CLIENT", "GROUP",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecordShareSummary(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["children"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsVaultVaultRecordShare(recurse),
		},
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultRecordShare(recurse),
		}
		attr.Optional = true
		schemaAttrs["parent"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecord_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	schemaAttrs["delete_tile"] = rsschema.BoolAttribute{
		Optional: true,
	}
	schemaAttrs["parent_uuid"] = rsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultPasswordMetadata(recurse),
		}
		attr.Computed = true
		schemaAttrs["password_metadata"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultRecordSecrets(recurse),
		}
		attr.Optional = true
		schemaAttrs["secret"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultRecordShareSummary(recurse),
		}
		attr.Computed = true
		schemaAttrs["share_summary"] = attr
	}
	{
		attr := resetListAttributeFlags(resourceSchemaAttrsVaultVaultRecordPrimerLinkableWrapper(recurse)["items"].(rsschema.ListAttribute))
		attr.Computed = true
		schemaAttrs["shares"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsLaunchpadVaultRecordLaunchpadTile(recurse),
		}
		attr.Optional = true
		schemaAttrs["tile"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultHolder(recurse),
		}
		attr.Computed = true
		schemaAttrs["vaultholder"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecovery(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["account_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["private_key"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultUnlock(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["password"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultUnlockResponse(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["expires_at"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["session_password"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsWebhookWebhook(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsWebhookWebhook_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["account_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["all_types"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["authentication_scheme"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NONE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "BASIC", "BEARER", "CUSTOM",
			),
		},
	}
	schemaAttrs["basic_auth_password"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["basic_auth_username"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["bearer_token"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["client_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["client_certificate_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["custom_header_name"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 64),
		},
	}
	schemaAttrs["custom_header_value"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 1024),
		},
	}
	schemaAttrs["directory_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["group_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["system_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["tls"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("SECURE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"VERIFIED_PINNED", "VERIFIED", "SECURE_PINNED", "SECURE", "ENCRYPTED", "UNSECURE",
			),
		},
	}
	schemaAttrs["trusted_certificate_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["types"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Validators: []validator.List{
			listvalidator.ValueStringsAre(
				stringvalidator.OneOf(
					"ACCOUNT_2FA_DISABLED", "ACCOUNT_2FA_ENABLED", "ACCOUNT_ADDED_TO_GROUP", "ACCOUNT_ADDED_TO_ORGANIZATIONAL_UNIT", "ACCOUNT_CREATED", "ACCOUNT_DEPROVISIONED", "ACCOUNT_DISABLED", "ACCOUNT_ENABLED", "ACCOUNT_GROUP_ACTIVATED", "ACCOUNT_GROUP_ACTIVATION_REASON", "ACCOUNT_GROUP_DEPROVISIONED", "ACCOUNT_GROUP_PROVISIONED", "ACCOUNT_LOGIN", "ACCOUNT_LOGIN_FAILED", "ACCOUNT_MODIFIED_FOR_GROUP", "ACCOUNT_PASSWORD_CHANGED", "ACCOUNT_PROVISIONED", "ACCOUNT_PROVISIONING_DESTROYED", "ACCOUNT_PROVISIONING_INITED", "ACCOUNT_PROVISIONING_SETUP", "ACCOUNT_REMOVED", "ACCOUNT_REMOVED_FROM_GROUP", "ACCOUNT_REMOVED_FROM_ORGANIZATIONAL_UNIT", "ACCOUNT_REREGISTERED", "ACCOUNT_SSH_PUBLIC_KEY_MODIFIED", "ACCOUNT_TOKEN_SIGNED", "ACCOUNT_TOTP_OFFSET_CHANGED", "ACCOUNT_VAULT_UNLOCKED", "ADD_GROUP_ADMIN_ACCEPTED", "ADD_GROUP_ADMIN_DECLINED", "ADD_GROUP_ADMIN_REQUESTED", "AUDITOR_EXPORT_GENERATED", "CERTIFICATE_CREATED", "CERTIFICATE_MODIFIED", "CERTIFICATE_REMOVED", "CLIENT_ADDED_TO_GROUP", "CLIENT_CREATED", "CLIENT_MODIFIED", "CLIENT_MODIFIED_FOR_GROUP", "CLIENT_PERMISSION_GRANTED", "CLIENT_PERMISSION_REVOKED", "CLIENT_REMOVED", "CLIENT_REMOVED_FROM_GROUP", "CLIENT_SECRET_ROTATED", "CREATE_GROUP_ACCEPTED", "CREATE_GROUP_DECLINED", "CREATE_GROUP_REQUESTED", "CREATE_GROUP_ON_SYSTEM_ACCEPTED", "CREATE_GROUP_ON_SYSTEM_DECLINED", "CREATE_GROUP_ON_SYSTEM_REQUESTED", "CREATE_SERVICE_ACCOUNT_ACCEPTED", "CREATE_SERVICE_ACCOUNT_DECLINED", "CREATE_SERVICE_ACCOUNT_REQUESTED", "DIRECTORY_CREATED", "DIRECTORY_HELPDESK_MODIFIED", "DIRECTORY_MODIFIED", "DIRECTORY_REMOVED", "DISABLE_2FA_ACCEPTED", "DISABLE_2FA_DECLINED", "DISABLE_2FA_REQUESTED", "ENABLE_TECHNICAL_ADMINISTRATION_ACCEPTED", "ENABLE_TECHNICAL_ADMINISTRATION_DECLINED", "ENABLE_TECHNICAL_ADMINISTRATION_REQUESTED", "EXTENDED_ACCESS_ACCEPTED", "EXTENDED_ACCESS_DECLINED", "EXTENDED_ACCESS_REQUESTED", "GRANT_ACCESS_ACCEPTED", "GRANT_ACCESS_DECLINED", "GRANT_ACCESS_REQUESTED", "GRANT_APPLICATION_ACCEPTED", "GRANT_APPLICATION_DECLINED", "GRANT_APPLICATION_REQUESTED", "GRANT_CLIENT_PERMISSION_ACCEPTED", "GRANT_CLIENT_PERMISSION_DECLINED", "GRANT_CLIENT_PERMISSION_REQUESTED", "GRANT_GROUP_ON_SYSTEM_ACCEPTED", "GRANT_GROUP_ON_SYSTEM_DECLINED", "GRANT_GROUP_ON_SYSTEM_REQUESTED", "GRANT_GROUP_ON_SYSTEM_REQUEST_ACCEPTED", "GRANT_GROUP_ON_SYSTEM_REQUEST_DECLINED", "GRANT_GROUP_ON_SYSTEM_REQUEST_REQUESTED", "GRANT_SERVICE_ACCOUNT_GROUP_ACCEPTED", "GRANT_SERVICE_ACCOUNT_GROUP_DECLINED", "GRANT_SERVICE_ACCOUNT_GROUP_REQUESTED", "GROUP_AUDIT_CREATED", "GROUP_AUDIT_REQUESTED", "GROUP_AUTHORIZATION_CONNECTED", "GROUP_AUTHORIZATION_DISCONNECTED", "GROUP_CLASSIFICATION_ASSIGNED", "GROUP_CLASSIFICATION_CREATED", "GROUP_CLASSIFICATION_MODIFIED", "GROUP_CLASSIFICATION_REMOVED", "GROUP_CREATED", "GROUP_MODIFIED", "GROUP_NESTING_CONNECTED", "GROUP_NESTING_DISCONNECTED", "GROUP_ON_SYSTEM_CREATED", "GROUP_ON_SYSTEM_DEPROVISIONED", "GROUP_ON_SYSTEM_PROVISIONED", "GROUP_ON_SYSTEM_REMOVED", "GROUP_REMOVED", "INTERNAL_ACCOUNT_ACTIVATED", "INTERNAL_ACCOUNT_CREATED", "INTERNAL_ACCOUNT_MODIFIED", "INTERNAL_ACCOUNT_REMOVED", "INVALID_SIGNATURE_DETECTED", "JOIN_GROUP_ACCEPTED", "JOIN_GROUP_DECLINED", "JOIN_GROUP_REQUESTED", "JOIN_VAULT_ACCEPTED", "JOIN_VAULT_DECLINED", "JOIN_VAULT_REQUESTED", "LICENSE_KEY_UPLOADED", "ORGANIZATIONAL_UNIT_CREATED", "ORGANIZATIONAL_UNIT_MODIFIED", "ORGANIZATIONAL_UNIT_REMOVED", "PROVISIONED_SYSTEM_ADDED_TO_GROUP", "PROVISIONED_SYSTEM_CREATED", "PROVISIONED_SYSTEM_MODIFIED", "PROVISIONED_SYSTEM_MODIFIED_FOR_GROUP", "PROVISIONED_SYSTEM_REMOVED", "PROVISIONED_SYSTEM_REMOVED_FROM_GROUP", "PROVISIONED_SYSTEM_UNKNOWN_ACCOUNT_DESTROYED", "REMOVE_GROUP_ACCEPTED", "REMOVE_GROUP_DECLINED", "REMOVE_GROUP_REQUESTED", "REMOVE_ORGANIZATIONAL_UNIT_ACCEPTED", "REMOVE_ORGANIZATIONAL_UNIT_DECLINED", "REMOVE_ORGANIZATIONAL_UNIT_REQUESTED", "REMOVE_PROVISIONED_SYSTEM_ACCEPTED", "REMOVE_PROVISIONED_SYSTEM_DECLINED", "REMOVE_PROVISIONED_SYSTEM_REQUESTED", "RESET_PASSWORD_ACCEPTED", "RESET_PASSWORD_DECLINED", "RESET_PASSWORD_FINISHED", "RESET_PASSWORD_REQUESTED", "REVIEW_AUDIT_ACCEPTED", "REVIEW_AUDIT_DECLINED", "REVIEW_AUDIT_REQUESTED", "REVOKE_ADMIN_ACCEPTED", "REVOKE_ADMIN_DECLINED", "REVOKE_ADMIN_REQUESTED", "SERVICE_ACCOUNT_ADDED_TO_GROUP", "SERVICE_ACCOUNT_CREATED", "SERVICE_ACCOUNT_GROUP_DEPROVISIONED", "SERVICE_ACCOUNT_GROUP_PROVISIONED", "SERVICE_ACCOUNT_MODIFIED", "SERVICE_ACCOUNT_PASSWORD_ROTATED", "SERVICE_ACCOUNT_PROVISIONING_DESTROYED", "SERVICE_ACCOUNT_PROVISIONING_INITED", "SERVICE_ACCOUNT_REMOVED", "SERVICE_ACCOUNT_REMOVED_FROM_GROUP", "SETUP_AUTHORIZING_GROUP_CONNECT_ACCEPTED", "SETUP_AUTHORIZING_GROUP_CONNECT_DECLINED", "SETUP_AUTHORIZING_GROUP_CONNECT_REQUESTED", "SETUP_AUTHORIZING_GROUP_DISCONNECT_ACCEPTED", "SETUP_AUTHORIZING_GROUP_DISCONNECT_DECLINED", "SETUP_AUTHORIZING_GROUP_DISCONNECT_REQUESTED", "SETUP_NESTED_GROUP_CONNECT_ACCEPTED", "SETUP_NESTED_GROUP_CONNECT_DECLINED", "SETUP_NESTED_GROUP_CONNECT_REQUESTED", "SETUP_NESTED_GROUP_DISCONNECT_ACCEPTED", "SETUP_NESTED_GROUP_DISCONNECT_DECLINED", "SETUP_NESTED_GROUP_DISCONNECT_REQUESTED", "TRANSFER_APPLICATION_ADMINISTRATION_ACCEPTED", "TRANSFER_APPLICATION_ADMINISTRATION_DECLINED", "TRANSFER_APPLICATION_ADMINISTRATION_REQUESTED", "TRANSFER_APPLICATION_OWNERSHIP_ACCEPTED", "TRANSFER_APPLICATION_OWNERSHIP_DECLINED", "TRANSFER_APPLICATION_OWNERSHIP_REQUESTED", "TRANSFER_GROUP_ON_SYSTEM_OWNERSHIP_ACCEPTED", "TRANSFER_GROUP_ON_SYSTEM_OWNERSHIP_DECLINED", "TRANSFER_GROUP_ON_SYSTEM_OWNERSHIP_REQUESTED", "TRANSFER_ORGANIZATIONAL_UNIT_OWNERSHIP_ACCEPTED", "TRANSFER_ORGANIZATIONAL_UNIT_OWNERSHIP_DECLINED", "TRANSFER_ORGANIZATIONAL_UNIT_OWNERSHIP_REQUESTED", "TRANSFER_PROVISIONED_SYSTEM_ADMINISTRATION_ACCEPTED", "TRANSFER_PROVISIONED_SYSTEM_ADMINISTRATION_DECLINED", "TRANSFER_PROVISIONED_SYSTEM_ADMINISTRATION_REQUESTED", "TRANSFER_PROVISIONED_SYSTEM_CONTENT_ADMINISTRATION_ACCEPTED", "TRANSFER_PROVISIONED_SYSTEM_CONTENT_ADMINISTRATION_DECLINED", "TRANSFER_PROVISIONED_SYSTEM_CONTENT_ADMINISTRATION_REQUESTED", "TRANSFER_PROVISIONED_SYSTEM_OWNERSHIP_ACCEPTED", "TRANSFER_PROVISIONED_SYSTEM_OWNERSHIP_DECLINED", "TRANSFER_PROVISIONED_SYSTEM_OWNERSHIP_REQUESTED", "TRANSFER_SERVICE_ACCOUNT_ADMINISTRATION_ACCEPTED", "TRANSFER_SERVICE_ACCOUNT_ADMINISTRATION_DECLINED", "TRANSFER_SERVICE_ACCOUNT_ADMINISTRATION_REQUESTED", "TRANSFER_AUDITOR_GROUP_ACCEPTED", "TRANSFER_AUDITOR_GROUP_DECLINED", "TRANSFER_AUDITOR_GROUP_REQUESTED", "UPDATE_GROUP_MEMBERSHIP_ACCEPTED", "UPDATE_GROUP_MEMBERSHIP_DECLINED", "UPDATE_GROUP_MEMBERSHIP_REQUESTED", "VAULT_ACCESS_RESTORED", "VAULT_EXPORTED", "VAULT_PERSONAL_RESET", "VAULT_PERSONAL_SETUP", "VAULT_RECORD_CREATED", "VAULT_RECORD_MODIFIED", "VAULT_RECORD_MOVED_COPIED_SHARED", "VAULT_RECORD_READ", "VAULT_RECORD_REMOVED", "VAULT_RECOVERED", "VERIFY_INTERNAL_ACCOUNT_ACCEPTED", "VERIFY_INTERNAL_ACCOUNT_DECLINED", "VERIFY_INTERNAL_ACCOUNT_REQUESTED", "WEBHOOK_CREATED", "WEBHOOK_MODIFIED", "WEBHOOK_REMOVED",
				),
			),
		},
	}
	schemaAttrs["url"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["verbose_payloads"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsWebhookWebhookDelivery(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsWebhookWebhookDelivery_additionalObjects(false))
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsWebhookWebhookPush(false),
		}
		attr.Optional = true
		schemaAttrs["payload"] = attr
	}
	schemaAttrs["reponse_headers"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["request_headers"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["response"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["status"] = rsschema.Int64Attribute{
		Optional: true,
	}
	schemaAttrs["time"] = rsschema.Int64Attribute{
		Optional: true,
	}
	schemaAttrs["trigger_time"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsWebhookWebhookDeliveryLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsWebhookWebhookDelivery(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsWebhookWebhookDelivery_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	return schemaAttrs
}
func resourceSchemaAttrsWebhookWebhookLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsWebhookWebhook(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsWebhookWebhookNameUuid(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["name"] = rsschema.StringAttribute{
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsLinkable(recurse),
		}
		attr.Optional = true
		schemaAttrs["object"] = attr
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsWebhookWebhookPush(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsWebhookWebhookNameUuid(recurse),
		}
		attr.Optional = true
		schemaAttrs["account"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsWebhookWebhookNameUuid(recurse),
		}
		attr.Optional = true
		schemaAttrs["by_party"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsWebhookWebhookNameUuid(recurse),
		}
		attr.Optional = true
		schemaAttrs["certificate"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsWebhookWebhookNameUuid(recurse),
		}
		attr.Optional = true
		schemaAttrs["client"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsWebhookWebhookNameUuid(recurse),
		}
		attr.Optional = true
		schemaAttrs["directory"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsWebhookWebhookNameUuid(recurse),
		}
		attr.Optional = true
		schemaAttrs["group"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsWebhookWebhookNameUuid(recurse),
		}
		attr.Optional = true
		schemaAttrs["group2"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsWebhookWebhookNameUuid(recurse),
		}
		attr.Optional = true
		schemaAttrs["group_classification"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsWebhookWebhookNameUuid(recurse),
		}
		attr.Optional = true
		schemaAttrs["modification_request"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsWebhookWebhookNameUuid(recurse),
		}
		attr.Optional = true
		schemaAttrs["organizational_unit"] = attr
	}
	schemaAttrs["parameter1"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["parameter2"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["parameter3"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["security_level"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"LOW", "MEDIUM", "HIGH",
			),
		},
	}
	schemaAttrs["seq"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsWebhookWebhookNameUuid(recurse),
		}
		attr.Optional = true
		schemaAttrs["service_account"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsWebhookWebhookNameUuid(recurse),
		}
		attr.Optional = true
		schemaAttrs["system"] = attr
	}
	schemaAttrs["timestamp"] = rsschema.StringAttribute{
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsWebhookWebhookNameUuid(recurse),
		}
		attr.Optional = true
		schemaAttrs["vault_record"] = attr
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsWebhookWebhookNameUuid(recurse),
		}
		attr.Optional = true
		schemaAttrs["webhook"] = attr
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ACCOUNT_2FA_DISABLED", "ACCOUNT_2FA_ENABLED", "ACCOUNT_ADDED_TO_GROUP", "ACCOUNT_ADDED_TO_ORGANIZATIONAL_UNIT", "ACCOUNT_CREATED", "ACCOUNT_DEPROVISIONED", "ACCOUNT_DISABLED", "ACCOUNT_ENABLED", "ACCOUNT_GROUP_ACTIVATED", "ACCOUNT_GROUP_ACTIVATION_REASON", "ACCOUNT_GROUP_DEPROVISIONED", "ACCOUNT_GROUP_PROVISIONED", "ACCOUNT_LOGIN", "ACCOUNT_LOGIN_FAILED", "ACCOUNT_MODIFIED_FOR_GROUP", "ACCOUNT_PASSWORD_CHANGED", "ACCOUNT_PROVISIONED", "ACCOUNT_PROVISIONING_DESTROYED", "ACCOUNT_PROVISIONING_INITED", "ACCOUNT_PROVISIONING_SETUP", "ACCOUNT_REMOVED", "ACCOUNT_REMOVED_FROM_GROUP", "ACCOUNT_REMOVED_FROM_ORGANIZATIONAL_UNIT", "ACCOUNT_REREGISTERED", "ACCOUNT_SSH_PUBLIC_KEY_MODIFIED", "ACCOUNT_TOKEN_SIGNED", "ACCOUNT_TOTP_OFFSET_CHANGED", "ACCOUNT_VAULT_UNLOCKED", "ADD_GROUP_ADMIN_ACCEPTED", "ADD_GROUP_ADMIN_DECLINED", "ADD_GROUP_ADMIN_REQUESTED", "AUDITOR_EXPORT_GENERATED", "CERTIFICATE_CREATED", "CERTIFICATE_MODIFIED", "CERTIFICATE_REMOVED", "CLIENT_ADDED_TO_GROUP", "CLIENT_CREATED", "CLIENT_MODIFIED", "CLIENT_MODIFIED_FOR_GROUP", "CLIENT_PERMISSION_GRANTED", "CLIENT_PERMISSION_REVOKED", "CLIENT_REMOVED", "CLIENT_REMOVED_FROM_GROUP", "CLIENT_SECRET_ROTATED", "CREATE_GROUP_ACCEPTED", "CREATE_GROUP_DECLINED", "CREATE_GROUP_REQUESTED", "CREATE_GROUP_ON_SYSTEM_ACCEPTED", "CREATE_GROUP_ON_SYSTEM_DECLINED", "CREATE_GROUP_ON_SYSTEM_REQUESTED", "CREATE_SERVICE_ACCOUNT_ACCEPTED", "CREATE_SERVICE_ACCOUNT_DECLINED", "CREATE_SERVICE_ACCOUNT_REQUESTED", "DIRECTORY_CREATED", "DIRECTORY_HELPDESK_MODIFIED", "DIRECTORY_MODIFIED", "DIRECTORY_REMOVED", "DISABLE_2FA_ACCEPTED", "DISABLE_2FA_DECLINED", "DISABLE_2FA_REQUESTED", "ENABLE_TECHNICAL_ADMINISTRATION_ACCEPTED", "ENABLE_TECHNICAL_ADMINISTRATION_DECLINED", "ENABLE_TECHNICAL_ADMINISTRATION_REQUESTED", "EXTENDED_ACCESS_ACCEPTED", "EXTENDED_ACCESS_DECLINED", "EXTENDED_ACCESS_REQUESTED", "GRANT_ACCESS_ACCEPTED", "GRANT_ACCESS_DECLINED", "GRANT_ACCESS_REQUESTED", "GRANT_APPLICATION_ACCEPTED", "GRANT_APPLICATION_DECLINED", "GRANT_APPLICATION_REQUESTED", "GRANT_CLIENT_PERMISSION_ACCEPTED", "GRANT_CLIENT_PERMISSION_DECLINED", "GRANT_CLIENT_PERMISSION_REQUESTED", "GRANT_GROUP_ON_SYSTEM_ACCEPTED", "GRANT_GROUP_ON_SYSTEM_DECLINED", "GRANT_GROUP_ON_SYSTEM_REQUESTED", "GRANT_GROUP_ON_SYSTEM_REQUEST_ACCEPTED", "GRANT_GROUP_ON_SYSTEM_REQUEST_DECLINED", "GRANT_GROUP_ON_SYSTEM_REQUEST_REQUESTED", "GRANT_SERVICE_ACCOUNT_GROUP_ACCEPTED", "GRANT_SERVICE_ACCOUNT_GROUP_DECLINED", "GRANT_SERVICE_ACCOUNT_GROUP_REQUESTED", "GROUP_AUDIT_CREATED", "GROUP_AUDIT_REQUESTED", "GROUP_AUTHORIZATION_CONNECTED", "GROUP_AUTHORIZATION_DISCONNECTED", "GROUP_CLASSIFICATION_ASSIGNED", "GROUP_CLASSIFICATION_CREATED", "GROUP_CLASSIFICATION_MODIFIED", "GROUP_CLASSIFICATION_REMOVED", "GROUP_CREATED", "GROUP_MODIFIED", "GROUP_NESTING_CONNECTED", "GROUP_NESTING_DISCONNECTED", "GROUP_ON_SYSTEM_CREATED", "GROUP_ON_SYSTEM_DEPROVISIONED", "GROUP_ON_SYSTEM_PROVISIONED", "GROUP_ON_SYSTEM_REMOVED", "GROUP_REMOVED", "INTERNAL_ACCOUNT_ACTIVATED", "INTERNAL_ACCOUNT_CREATED", "INTERNAL_ACCOUNT_MODIFIED", "INTERNAL_ACCOUNT_REMOVED", "INVALID_SIGNATURE_DETECTED", "JOIN_GROUP_ACCEPTED", "JOIN_GROUP_DECLINED", "JOIN_GROUP_REQUESTED", "JOIN_VAULT_ACCEPTED", "JOIN_VAULT_DECLINED", "JOIN_VAULT_REQUESTED", "LICENSE_KEY_UPLOADED", "ORGANIZATIONAL_UNIT_CREATED", "ORGANIZATIONAL_UNIT_MODIFIED", "ORGANIZATIONAL_UNIT_REMOVED", "PROVISIONED_SYSTEM_ADDED_TO_GROUP", "PROVISIONED_SYSTEM_CREATED", "PROVISIONED_SYSTEM_MODIFIED", "PROVISIONED_SYSTEM_MODIFIED_FOR_GROUP", "PROVISIONED_SYSTEM_REMOVED", "PROVISIONED_SYSTEM_REMOVED_FROM_GROUP", "PROVISIONED_SYSTEM_UNKNOWN_ACCOUNT_DESTROYED", "REMOVE_GROUP_ACCEPTED", "REMOVE_GROUP_DECLINED", "REMOVE_GROUP_REQUESTED", "REMOVE_ORGANIZATIONAL_UNIT_ACCEPTED", "REMOVE_ORGANIZATIONAL_UNIT_DECLINED", "REMOVE_ORGANIZATIONAL_UNIT_REQUESTED", "REMOVE_PROVISIONED_SYSTEM_ACCEPTED", "REMOVE_PROVISIONED_SYSTEM_DECLINED", "REMOVE_PROVISIONED_SYSTEM_REQUESTED", "RESET_PASSWORD_ACCEPTED", "RESET_PASSWORD_DECLINED", "RESET_PASSWORD_FINISHED", "RESET_PASSWORD_REQUESTED", "REVIEW_AUDIT_ACCEPTED", "REVIEW_AUDIT_DECLINED", "REVIEW_AUDIT_REQUESTED", "REVOKE_ADMIN_ACCEPTED", "REVOKE_ADMIN_DECLINED", "REVOKE_ADMIN_REQUESTED", "SERVICE_ACCOUNT_ADDED_TO_GROUP", "SERVICE_ACCOUNT_CREATED", "SERVICE_ACCOUNT_GROUP_DEPROVISIONED", "SERVICE_ACCOUNT_GROUP_PROVISIONED", "SERVICE_ACCOUNT_MODIFIED", "SERVICE_ACCOUNT_PASSWORD_ROTATED", "SERVICE_ACCOUNT_PROVISIONING_DESTROYED", "SERVICE_ACCOUNT_PROVISIONING_INITED", "SERVICE_ACCOUNT_REMOVED", "SERVICE_ACCOUNT_REMOVED_FROM_GROUP", "SETUP_AUTHORIZING_GROUP_CONNECT_ACCEPTED", "SETUP_AUTHORIZING_GROUP_CONNECT_DECLINED", "SETUP_AUTHORIZING_GROUP_CONNECT_REQUESTED", "SETUP_AUTHORIZING_GROUP_DISCONNECT_ACCEPTED", "SETUP_AUTHORIZING_GROUP_DISCONNECT_DECLINED", "SETUP_AUTHORIZING_GROUP_DISCONNECT_REQUESTED", "SETUP_NESTED_GROUP_CONNECT_ACCEPTED", "SETUP_NESTED_GROUP_CONNECT_DECLINED", "SETUP_NESTED_GROUP_CONNECT_REQUESTED", "SETUP_NESTED_GROUP_DISCONNECT_ACCEPTED", "SETUP_NESTED_GROUP_DISCONNECT_DECLINED", "SETUP_NESTED_GROUP_DISCONNECT_REQUESTED", "TRANSFER_APPLICATION_ADMINISTRATION_ACCEPTED", "TRANSFER_APPLICATION_ADMINISTRATION_DECLINED", "TRANSFER_APPLICATION_ADMINISTRATION_REQUESTED", "TRANSFER_APPLICATION_OWNERSHIP_ACCEPTED", "TRANSFER_APPLICATION_OWNERSHIP_DECLINED", "TRANSFER_APPLICATION_OWNERSHIP_REQUESTED", "TRANSFER_GROUP_ON_SYSTEM_OWNERSHIP_ACCEPTED", "TRANSFER_GROUP_ON_SYSTEM_OWNERSHIP_DECLINED", "TRANSFER_GROUP_ON_SYSTEM_OWNERSHIP_REQUESTED", "TRANSFER_ORGANIZATIONAL_UNIT_OWNERSHIP_ACCEPTED", "TRANSFER_ORGANIZATIONAL_UNIT_OWNERSHIP_DECLINED", "TRANSFER_ORGANIZATIONAL_UNIT_OWNERSHIP_REQUESTED", "TRANSFER_PROVISIONED_SYSTEM_ADMINISTRATION_ACCEPTED", "TRANSFER_PROVISIONED_SYSTEM_ADMINISTRATION_DECLINED", "TRANSFER_PROVISIONED_SYSTEM_ADMINISTRATION_REQUESTED", "TRANSFER_PROVISIONED_SYSTEM_CONTENT_ADMINISTRATION_ACCEPTED", "TRANSFER_PROVISIONED_SYSTEM_CONTENT_ADMINISTRATION_DECLINED", "TRANSFER_PROVISIONED_SYSTEM_CONTENT_ADMINISTRATION_REQUESTED", "TRANSFER_PROVISIONED_SYSTEM_OWNERSHIP_ACCEPTED", "TRANSFER_PROVISIONED_SYSTEM_OWNERSHIP_DECLINED", "TRANSFER_PROVISIONED_SYSTEM_OWNERSHIP_REQUESTED", "TRANSFER_SERVICE_ACCOUNT_ADMINISTRATION_ACCEPTED", "TRANSFER_SERVICE_ACCOUNT_ADMINISTRATION_DECLINED", "TRANSFER_SERVICE_ACCOUNT_ADMINISTRATION_REQUESTED", "TRANSFER_AUDITOR_GROUP_ACCEPTED", "TRANSFER_AUDITOR_GROUP_DECLINED", "TRANSFER_AUDITOR_GROUP_REQUESTED", "UPDATE_GROUP_MEMBERSHIP_ACCEPTED", "UPDATE_GROUP_MEMBERSHIP_DECLINED", "UPDATE_GROUP_MEMBERSHIP_REQUESTED", "VAULT_ACCESS_RESTORED", "VAULT_EXPORTED", "VAULT_PERSONAL_RESET", "VAULT_PERSONAL_SETUP", "VAULT_RECORD_CREATED", "VAULT_RECORD_MODIFIED", "VAULT_RECORD_MOVED_COPIED_SHARED", "VAULT_RECORD_READ", "VAULT_RECORD_REMOVED", "VAULT_RECOVERED", "VERIFY_INTERNAL_ACCOUNT_ACCEPTED", "VERIFY_INTERNAL_ACCOUNT_DECLINED", "VERIFY_INTERNAL_ACCOUNT_REQUESTED", "WEBHOOK_CREATED", "WEBHOOK_MODIFIED", "WEBHOOK_REMOVED",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsWebhookWebhook_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfo(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}
	return schemaAttrs
}
