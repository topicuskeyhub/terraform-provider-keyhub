// Code generated by "terraform-provider-keyhub-generator"; DO NOT EDIT.
// Copyright (c) Topicus Security B.V.
// SPDX-License-Identifier: APSL-2.0

//lint:ignore U1000 Ignore unused functions in generated code
package provider

import (
	"golang.org/x/exp/maps"
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/mapdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

func resourceSchemaAttrsAuditInfoRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["created_at"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["created_by"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_modified_at"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_modified_by"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGeneratedSecret(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["generated_secret"] = rsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["old_secret"] = rsschema.StringAttribute{
		Optional:  true,
		Sensitive: true,
	}
	schemaAttrs["regenerate"] = rsschema.BoolAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGeneratedSecretRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["generated_secret"] = rsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["old_secret"] = rsschema.StringAttribute{
		Optional:  true,
		Sensitive: true,
	}
	schemaAttrs["regenerate"] = rsschema.BoolAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsLinkable(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsLinkableRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsNonLinkable(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsNonLinkableRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsRestLink(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["href"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["id"] = rsschema.Int64Attribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Int64{int64planmodifier.UseStateForUnknown()},
	}
	schemaAttrs["rel"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["type_escaped"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsRestLinkRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["href"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["id"] = rsschema.Int64Attribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Int64{int64planmodifier.UseStateForUnknown()},
	}
	schemaAttrs["rel"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["type_escaped"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuditGroupAuditRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsAuditGroupAudit_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["accounts"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuditGroupAuditAccountRO(false),
		},
		Optional: true,
	}
	schemaAttrs["comment"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["created_at"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["created_by"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["group_name"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name_on_audit"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["nested_groups"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuditNestedGroupAuditRO(false),
		},
		Optional: true,
	}
	schemaAttrs["reviewed_at"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["reviewed_by"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["status"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NEW", "DRAFT", "UNDER_REVIEW", "FINAL",
			),
		},
	}
	schemaAttrs["submitted_at"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["submitted_by"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuditGroupAuditAccountRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["account_uuid"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["account_valid"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["action"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"APPROVE", "ADD_AS_MANAGER", "ADD_AS_NORMAL", "CHANGE_TO_MANAGER", "CHANGE_TO_NORMAL", "REMOVE", "CONNECT_NESTED",
			),
		},
	}
	schemaAttrs["comment"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["disconnected_nested"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["display_name"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_used"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["nested"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["rights"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuditGroupAuditLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuditGroupAuditRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuditGroupAudit_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsAuditNestedGroupAuditRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["action"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"INCLUDE", "EXCLUDE", "MISMATCH",
			),
		},
	}
	schemaAttrs["comment"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["group_uuid"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthAccountPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["display_name"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["validity"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthAccountPrimerRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["display_name"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_active"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["validity"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthPermission(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["full"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["instances"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
	}
	schemaAttrs["operations"] = rsschema.SetAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Validators: []validator.Set{
			setvalidator.ValueStringsAre(
				stringvalidator.OneOf(
					"CREATE", "READ", "UPDATE", "DELETE",
				),
			),
		},
	}
	schemaAttrs["type_escaped"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsAuthPermissionRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["full"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["instances"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
	}
	schemaAttrs["operations"] = rsschema.SetAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Validators: []validator.Set{
			setvalidator.ValueStringsAre(
				stringvalidator.OneOf(
					"CREATE", "READ", "UPDATE", "DELETE",
				),
			),
		},
	}
	schemaAttrs["type_escaped"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsCertificateCertificatePrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["alias"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 128),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["certificate_data"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["expiration"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["fingerprint_sha1"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["fingerprint_sha256"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["global"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["subject_dn"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsCertificateCertificatePrimerRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["alias"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 128),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["certificate_data"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["expiration"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["fingerprint_sha1"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["fingerprint_sha256"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["global"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["subject_dn"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientApplicationVaultVaultRecord(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"activationStatus", "audit", "parent", "passwordMetadata", "secret", "shareSummary", "shares", "tile", "vaultholder",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsVaultVaultRecord_additionalObjects(false))

	}
	schemaAttrs["client_application_uuid"] = rsschema.StringAttribute{
		Required:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.RequiresReplace()},
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["color"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NONE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "GREEN", "RED", "BLUE", "DARK", "PINK_LAVENDER", "CRIMSON_RED", "MIDDLE_YELLOW", "ANDROID_GREEN", "SAGE", "ARTICHOKE",
			),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["share_end_time"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["derived"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["filename"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["types"] = rsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["url"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["warning_period"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"AT_EXPIRATION", "TWO_WEEKS", "ONE_MONTH", "TWO_MONTHS", "THREE_MONTHS", "SIX_MONTHS", "NEVER",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientClientApplication(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"accessprofileclients", "audit", "groupclients", "groups", "organizationalUnits", "secret", "tile", "vaultRecordCount",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsClientClientApplication_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["client_id"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["scopes"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Computed:    true,
	}
	schemaAttrs["sso_application"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["last_modified_at"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["owner_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["technical_administrator_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientLdapClient(false),
		}
		attr.Optional = true
		schemaAttrs["ldap_client"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientOAuth2Client(false),
		}
		attr.Optional = true
		schemaAttrs["oauth2_client"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientSaml2Client(false),
		}
		attr.Optional = true
		schemaAttrs["saml2_client"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsClientClientApplicationRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"accessprofileclients", "audit", "groupclients", "groups", "organizationalUnits", "secret", "tile", "vaultRecordCount",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsClientClientApplication_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["client_id"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["scopes"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Computed:    true,
	}
	schemaAttrs["sso_application"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["last_modified_at"] = rsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["owner"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["technical_administrator"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientLdapClientRO(false),
		}
		attr.Optional = true
		schemaAttrs["ldap_client"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientOAuth2ClientRO(false),
		}
		attr.Optional = true
		schemaAttrs["oauth2_client"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientSaml2ClientRO(false),
		}
		attr.Optional = true
		schemaAttrs["saml2_client"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsClientClientApplicationLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsClientClientApplicationRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientClientApplicationPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["client_id"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["scopes"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Computed:    true,
	}
	schemaAttrs["sso_application"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientClientApplicationPrimerRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["client_id"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["scopes"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Computed:    true,
	}
	schemaAttrs["sso_application"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientClientApplication_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProfileAccessProfileClientLinkableWrapperWithCount(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["accessprofileclients"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	schemaAttrs["delete_tile"] = rsschema.BoolAttribute{
		WriteOnly: true,
		Optional:  true,
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupClientLinkableWrapperWithCount(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["groupclients"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["groups"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsOrganizationClientApplicationOrganizationalUnitLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["organizational_units"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGeneratedSecret(recurse),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["secret"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsLaunchpadSsoApplicationLaunchpadTile(recurse),
		}
		attr.Optional = true
		schemaAttrs["tile"] = attr
	}

	schemaAttrs["vault_record_count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientClientApplication_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProfileAccessProfileClientLinkableWrapperWithCountRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["accessprofileclients"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	schemaAttrs["delete_tile"] = rsschema.BoolAttribute{
		WriteOnly: true,
		Optional:  true,
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupClientLinkableWrapperWithCountRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["groupclients"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["groups"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsOrganizationClientApplicationOrganizationalUnitLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["organizational_units"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGeneratedSecretRO(recurse),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["secret"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsLaunchpadSsoApplicationLaunchpadTileRO(recurse),
		}
		attr.Optional = true
		schemaAttrs["tile"] = attr
	}

	schemaAttrs["vault_record_count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientLdapClient(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["bind_dn"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["client_certificate_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["share_secret_in_vault"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultRecordPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["shared_secret"] = attr
	}

	schemaAttrs["used_for_provisioning"] = rsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientLdapClientRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["bind_dn"] = rsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsCertificateCertificatePrimerRO(recurse),
		}
		attr.Optional = true
		schemaAttrs["client_certificate"] = attr
	}

	schemaAttrs["share_secret_in_vault"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultRecordPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["shared_secret"] = attr
	}

	schemaAttrs["used_for_provisioning"] = rsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientOAuth2Client(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["account_permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["attributes"] = rsschema.MapAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Computed:    true,
		Default:     mapdefault.StaticValue(types.MapValueMust(types.StringType, make(map[string]attr.Value))),
	}

	schemaAttrs["callback_uri"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["debug_mode"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["for_identity_source"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["id_token_claims"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["initiate_login_uri"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["profile"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("WEB_APPLICATION"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"SERVER_TO_SERVER", "WEB_APPLICATION", "BROWSER_BASED_APPLICATION", "BROWSER_BASED_APPLICATION_WITH_REFRESH_TOKEN", "PUBLIC_NATIVE_APPLICATION", "PUBLIC_NATIVE_APPLICATION_WITH_SECURE_STORAGE", "CONFIDENTIAL_NATIVE_APPLICATION",
			),
		},
	}
	schemaAttrs["resource_uris"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["share_secret_in_vault"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultRecordPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["shared_secret"] = attr
	}

	schemaAttrs["show_landing_page"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["use_client_credentials"] = rsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientOAuth2ClientRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["account_permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed: true,
	}
	schemaAttrs["attributes"] = rsschema.MapAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Computed:    true,
		Default:     mapdefault.StaticValue(types.MapValueMust(types.StringType, make(map[string]attr.Value))),
	}

	schemaAttrs["callback_uri"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["debug_mode"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["for_identity_source"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["id_token_claims"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["initiate_login_uri"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["profile"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("WEB_APPLICATION"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"SERVER_TO_SERVER", "WEB_APPLICATION", "BROWSER_BASED_APPLICATION", "BROWSER_BASED_APPLICATION_WITH_REFRESH_TOKEN", "PUBLIC_NATIVE_APPLICATION", "PUBLIC_NATIVE_APPLICATION_WITH_SECURE_STORAGE", "CONFIDENTIAL_NATIVE_APPLICATION",
			),
		},
	}
	schemaAttrs["resource_uris"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["share_secret_in_vault"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultRecordPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["shared_secret"] = attr
	}

	schemaAttrs["show_landing_page"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["use_client_credentials"] = rsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientOAuth2ClientPermission(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsClientOAuth2ClientPermission_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["for_group_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["for_system_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["value"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ACCOUNTS_CREATE", "ACCOUNTS_QUERY", "ACCOUNTS_REMOVE", "CLIENTS_CREATE", "CLIENTS_QUERY", "GROUPONSYSTEM_CREATE", "GROUPS_CREATE", "GROUPS_GRANT_PERMISSIONS_AFTER_CREATE", "GROUPS_QUERY", "GROUPS_SET_CLASSIFICATION", "GROUP_FULL_VAULT_ACCESS", "GROUP_LAUNCHPADTILES", "GROUP_READ_CONTENTS", "GROUP_SET_AUTHORIZATION", "PROVISIONEDSYSTEMS_QUERY", "SERVICE_ACCOUNTS_CREATE", "SERVICE_ACCOUNTS_QUERY", "SERVICE_ACCOUNTS_UPDATE",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientOAuth2ClientPermissionRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsClientOAuth2ClientPermission_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["for_group"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedSystemPrimerRO(false),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["for_system"] = attr
	}

	schemaAttrs["value"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ACCOUNTS_CREATE", "ACCOUNTS_QUERY", "ACCOUNTS_REMOVE", "CLIENTS_CREATE", "CLIENTS_QUERY", "GROUPONSYSTEM_CREATE", "GROUPS_CREATE", "GROUPS_GRANT_PERMISSIONS_AFTER_CREATE", "GROUPS_QUERY", "GROUPS_SET_CLASSIFICATION", "GROUP_FULL_VAULT_ACCESS", "GROUP_LAUNCHPADTILES", "GROUP_READ_CONTENTS", "GROUP_SET_AUTHORIZATION", "PROVISIONEDSYSTEMS_QUERY", "SERVICE_ACCOUNTS_CREATE", "SERVICE_ACCOUNTS_QUERY", "SERVICE_ACCOUNTS_UPDATE",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientOAuth2ClientPermissionWithClient(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsClientOAuth2ClientPermission_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["for_group_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["for_system_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["value"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ACCOUNTS_CREATE", "ACCOUNTS_QUERY", "ACCOUNTS_REMOVE", "CLIENTS_CREATE", "CLIENTS_QUERY", "GROUPONSYSTEM_CREATE", "GROUPS_CREATE", "GROUPS_GRANT_PERMISSIONS_AFTER_CREATE", "GROUPS_QUERY", "GROUPS_SET_CLASSIFICATION", "GROUP_FULL_VAULT_ACCESS", "GROUP_LAUNCHPADTILES", "GROUP_READ_CONTENTS", "GROUP_SET_AUTHORIZATION", "PROVISIONEDSYSTEMS_QUERY", "SERVICE_ACCOUNTS_CREATE", "SERVICE_ACCOUNTS_QUERY", "SERVICE_ACCOUNTS_UPDATE",
			),
		},
	}
	schemaAttrs["client_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientOAuth2ClientPermissionWithClientRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsClientOAuth2ClientPermission_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["for_group"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedSystemPrimerRO(false),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["for_system"] = attr
	}

	schemaAttrs["value"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ACCOUNTS_CREATE", "ACCOUNTS_QUERY", "ACCOUNTS_REMOVE", "CLIENTS_CREATE", "CLIENTS_QUERY", "GROUPONSYSTEM_CREATE", "GROUPS_CREATE", "GROUPS_GRANT_PERMISSIONS_AFTER_CREATE", "GROUPS_QUERY", "GROUPS_SET_CLASSIFICATION", "GROUP_FULL_VAULT_ACCESS", "GROUP_LAUNCHPADTILES", "GROUP_READ_CONTENTS", "GROUP_SET_AUTHORIZATION", "PROVISIONEDSYSTEMS_QUERY", "SERVICE_ACCOUNTS_CREATE", "SERVICE_ACCOUNTS_QUERY", "SERVICE_ACCOUNTS_UPDATE",
			),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientOAuth2ClientRO(false),
		}
		attr.Optional = true
		schemaAttrs["client"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsClientOAuth2ClientPermissionWithClientLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsClientOAuth2ClientPermissionWithClient(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientOAuth2ClientPermissionWithClientLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsClientOAuth2ClientPermissionWithClientRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientOAuth2ClientPermission_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsClientOAuth2ClientPermission_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsClientSaml2Client(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["attributes"] = rsschema.MapAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Computed:    true,
		Default:     mapdefault.StaticValue(types.MapValueMust(types.StringType, make(map[string]attr.Value))),
	}

	schemaAttrs["metadata"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["metadata_url"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["subject_format"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ID", "UPN", "USERNAME", "EMAIL",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsClientSaml2ClientRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["attributes"] = rsschema.MapAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Computed:    true,
		Default:     mapdefault.StaticValue(types.MapValueMust(types.StringType, make(map[string]attr.Value))),
	}

	schemaAttrs["metadata"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["metadata_url"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["subject_format"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ID", "UPN", "USERNAME", "EMAIL",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryAccountDirectoryRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "markers", "status",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsDirectoryAccountDirectory_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["account_validity_supported"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(false),
		}
		attr.Required = true
		schemaAttrs["base_organizational_unit"] = attr
	}

	schemaAttrs["default_directory"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Optional = true
		schemaAttrs["helpdesk_group"] = attr
	}

	schemaAttrs["restrict2fa"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["rotating_password"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"DEFAULT_OFF", "DEFAULT_ON", "ALWAYS_ON",
			),
		},
	}
	schemaAttrs["username_customizable"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryInternalDirectoryRO(false),
		}
		attr.Optional = true
		schemaAttrs["internal_directory"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryLDAPDirectoryRO(false),
		}
		attr.Optional = true
		schemaAttrs["ldap_directory"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryMaintenanceDirectoryRO(false),
		}
		attr.Optional = true
		schemaAttrs["maintenance_directory"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryOIDCDirectoryRO(false),
		}
		attr.Optional = true
		schemaAttrs["oidc_directory"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryPendingAccountsDirectoryRO(false),
		}
		attr.Optional = true
		schemaAttrs["pending_accounts_directory"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsDirectoryAccountDirectoryLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsDirectoryAccountDirectoryRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryAccountDirectoryPrimerRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["account_validity_supported"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryAccountDirectoryStatusReportRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["accounts"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["reason"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["status"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryAccountDirectorySummaryRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"MAINTENANCE", "LDAP", "INTERNAL", "OIDC", "PENDING_ACCOUNTS",
			),
		},
	}
	schemaAttrs["domain_restriction"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["fully_resolved_issuer"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryAccountDirectoryStatusReportRO(recurse),
		}
		attr.Optional = true
		schemaAttrs["status"] = attr
	}

	schemaAttrs["username_customizable"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryAccountDirectorySummaryLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsDirectoryAccountDirectorySummaryRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryAccountDirectory_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsMarkItemMarkersRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["markers"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryAccountDirectoryStatusReportRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["status"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsDirectoryInternalDirectoryRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(recurse),
		}
		attr.Required = true
		schemaAttrs["owner"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsDirectoryLDAPDirectoryRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["attributes_to_store"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["base_dn"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsCertificateCertificatePrimerRO(recurse),
		}
		attr.Optional = true
		schemaAttrs["client_certificate"] = attr
	}

	schemaAttrs["dialect"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("ACTIVE_DIRECTORY"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ACTIVE_DIRECTORY", "OPENLDAP",
			),
		},
	}
	schemaAttrs["failover_host"] = rsschema.StringAttribute{
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsCertificateCertificatePrimerRO(recurse),
		}
		attr.Optional = true
		schemaAttrs["failover_trusted_certificate"] = attr
	}

	schemaAttrs["host"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["password_recovery"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"DISABLED", "VERIFY_2FA", "VERIFY_MAIL", "VERIFY_MAIL_AND_2FA",
			),
		},
	}
	schemaAttrs["port"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["search_bind_dn"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["search_bind_password"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 128),
		},
		Sensitive: true,
	}
	schemaAttrs["search_filter"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["tls"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"VERIFIED_PINNED", "VERIFIED", "SECURE_PINNED", "SECURE", "ENCRYPTED", "UNSECURE",
			),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsCertificateCertificatePrimerRO(recurse),
		}
		attr.Optional = true
		schemaAttrs["trusted_certificate"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsDirectoryMaintenanceDirectoryRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryOIDCDirectoryRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["acr_values"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["attributes_to_store"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["client_id"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["client_secret"] = rsschema.StringAttribute{
		Required:  true,
		Sensitive: true,
	}
	schemaAttrs["domain_restriction"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["enforces2fa"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["fully_resolved_issuer"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["issuer"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["logout_url"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["send_login_hint"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["vendor_escaped"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"GENERIC", "GOOGLE", "AZURE_AD",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsDirectoryPendingAccountsDirectoryRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroup(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"accounts", "administeredClients", "administeredSystems", "admins", "audit", "authorizedGroups", "clientPermissions", "clients", "contentAdministeredSystems", "globalRoles", "groupAccessInfo", "groupauditinginfo", "groupinfo", "helpdesk", "markers", "myaccount", "mydelegatedaccount", "nestedGroups", "ownedAccessProfiles", "ownedClients", "ownedDirectories", "ownedGroupsOnSystem", "ownedOrganizationalUnits", "ownedSystems", "recentAudits", "requeststatus", "serviceAccounts", "systems", "vault", "webhooks",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupGroup_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["admin"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["organizational_unit_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["application_administration"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupAuditConfig(false),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["audit_config"] = attr
	}

	schemaAttrs["audit_requested"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["authorizing_group_auditing_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["authorizing_group_delegation_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["authorizing_group_membership_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["authorizing_group_provisioning_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["authorizing_group_types"] = rsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["classification_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["description"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["extended_access"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NOT_ALLOWED"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NOT_ALLOWED", "ONE_WEEK", "TWO_WEEKS", "TWO_WEEKS_NO_CONFIRM",
			),
		},
	}
	schemaAttrs["hide_audit_trail"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["nested_under_uuid"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["private_group"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["profile_administration"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["record_trail"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["rotating_password_required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["single_managed"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["vault_recovery"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("FULL"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "RECOVERY_KEY_ONLY", "FULL",
			),
		},
	}
	schemaAttrs["vault_requires_activation"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"accounts", "administeredClients", "administeredSystems", "admins", "audit", "authorizedGroups", "clientPermissions", "clients", "contentAdministeredSystems", "globalRoles", "groupAccessInfo", "groupauditinginfo", "groupinfo", "helpdesk", "markers", "myaccount", "mydelegatedaccount", "nestedGroups", "ownedAccessProfiles", "ownedClients", "ownedDirectories", "ownedGroupsOnSystem", "ownedOrganizationalUnits", "ownedSystems", "recentAudits", "requeststatus", "serviceAccounts", "systems", "vault", "webhooks",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupGroup_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["admin"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["organizational_unit"] = attr
	}

	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["application_administration"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupAuditConfigRO(false),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["audit_config"] = attr
	}

	schemaAttrs["audit_requested"] = rsschema.BoolAttribute{
		Computed: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Optional = true
		schemaAttrs["authorizing_group_auditing"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Optional = true
		schemaAttrs["authorizing_group_delegation"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Optional = true
		schemaAttrs["authorizing_group_membership"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Optional = true
		schemaAttrs["authorizing_group_provisioning"] = attr
	}

	schemaAttrs["authorizing_group_types"] = rsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupClassificationPrimerRO(false),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["classification"] = attr
	}

	schemaAttrs["description"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["extended_access"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NOT_ALLOWED"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NOT_ALLOWED", "ONE_WEEK", "TWO_WEEKS", "TWO_WEEKS_NO_CONFIRM",
			),
		},
	}
	schemaAttrs["hide_audit_trail"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Optional = true
		schemaAttrs["nested_under"] = attr
	}

	schemaAttrs["private_group"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["profile_administration"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["record_trail"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["rotating_password_required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["single_managed"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["vault_recovery"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("FULL"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "RECOVERY_KEY_ONLY", "FULL",
			),
		},
	}
	schemaAttrs["vault_requires_activation"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAccessInfoRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["business_accounts"] = rsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAccount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupGroupAccount_additionalObjects(false))

	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryAccountDirectoryPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["directory"] = attr
	}

	schemaAttrs["disconnected_nested"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["last_used"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["nested"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["provisioning_end_time"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["provisioning_permission_end_time"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["rights"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"MANAGER", "NORMAL",
			),
		},
	}
	schemaAttrs["two_factor_status"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["visible_for_provisioning"] = rsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAccountRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupGroupAccount_additionalObjectsRO(false))

	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryAccountDirectoryPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["directory"] = attr
	}

	schemaAttrs["disconnected_nested"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["last_used"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["nested"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["provisioning_end_time"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["provisioning_permission_end_time"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["rights"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"MANAGER", "NORMAL",
			),
		},
	}
	schemaAttrs["two_factor_status"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["visible_for_provisioning"] = rsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAccountLinkableWrapper(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroupAccount(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAccountLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroupAccountRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAccount_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAccount_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAuditConfig(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["months"] = rsschema.SetAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Computed:    true,
		Validators: []validator.Set{
			setvalidator.ValueStringsAre(
				stringvalidator.OneOf(
					"JANUARY", "FEBRUARY", "MARCH", "APRIL", "MAY", "JUNE", "JULY", "AUGUST", "SEPTEMBER", "OCTOBER", "NOVEMBER", "DECEMBER",
				),
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAuditConfigRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["months"] = rsschema.SetAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Computed:    true,
		Validators: []validator.Set{
			setvalidator.ValueStringsAre(
				stringvalidator.OneOf(
					"JANUARY", "FEBRUARY", "MARCH", "APRIL", "MAY", "JUNE", "JULY", "AUGUST", "SEPTEMBER", "OCTOBER", "NOVEMBER", "DECEMBER",
				),
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupAuditingInfoRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["audit_due_date"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["last_audit_date"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["nr_accounts"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_disabled_accounts"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_disabled_managers"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_expired_vault_records"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_managers"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_vault_records_with_end_date"] = rsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupClassificationPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupClassificationPrimerRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupClient(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupGroupClient_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["activation_required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientClientApplicationPrimerRO(false),
		}
		attr.Computed = true
		attr.PlanModifiers = []planmodifier.Object{objectplanmodifier.UseStateForUnknown()}
		schemaAttrs["client"] = attr
	}

	schemaAttrs["group_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["owner_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["technical_administrator_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupClientRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupGroupClient_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["activation_required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientClientApplicationPrimerRO(false),
		}
		attr.Computed = true
		attr.PlanModifiers = []planmodifier.Object{objectplanmodifier.UseStateForUnknown()}
		schemaAttrs["client"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Required = true
		schemaAttrs["group"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["owner"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["technical_administrator"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupClientLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroupClientRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupClientLinkableWrapperWithCount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroupClient(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupClientLinkableWrapperWithCountRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroupClientRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupClient_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupClient_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupGlobalRoleInfoRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["auditor_group_for"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse),
		},
		Optional: true,
	}
	schemaAttrs["create_group_approve_group_for"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse),
		},
		Optional: true,
	}
	schemaAttrs["enable_tech_admin_approve_group_for"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse),
		},
		Optional: true,
	}
	schemaAttrs["recovery_fallback_group_for"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse),
		},
		Optional: true,
	}
	schemaAttrs["remove_group_approve_group_for"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupInfoRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["nr_accounts"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_accounts_with_vault"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_audits"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_clients"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_provisioned_systems"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["nr_vault_records"] = rsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroupRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupLinkableWrapperWithCountRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroupRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["admin"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["organizational_unit_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupPrimerRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["admin"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["organizational_unit"] = attr
	}

	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroupPrimerLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupGroup_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupAccountLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["accounts"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsClientClientApplicationLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["administered_clients"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["administered_systems"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupAccountLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		attr.DeprecationMessage = "This property will be removed in a future version."
		schemaAttrs["admins"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupLinkableWrapperWithCountRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["authorized_groups"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsClientOAuth2ClientPermissionWithClientLinkableWrapper(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["client_permissions"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupClientLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["clients"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["content_administered_systems"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupGlobalRoleInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["global_roles"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupAccessInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["group_access_info"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupAuditingInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["groupauditinginfo"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["groupinfo"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsDirectoryAccountDirectorySummaryLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["helpdesk"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsMarkItemMarkersRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["markers"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupAccountRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["myaccount"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupAccountRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["mydelegatedaccount"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupPrimerLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["nested_groups"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProfileAccessProfileLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["owned_access_profiles"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsClientClientApplicationLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["owned_clients"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsDirectoryAccountDirectoryLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["owned_directories"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningOwnedGroupOnSystemsWrapperRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["owned_groups_on_system"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsOrganizationOrganizationalUnitLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["owned_organizational_units"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["owned_systems"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsAuditGroupAuditLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["recent_audits"] = attr
	}

	schemaAttrs["requeststatus"] = rsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsServiceaccountServiceAccountLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["service_accounts"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupProvisioningGroupLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["systems"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["vault"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsWebhookWebhookLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["webhooks"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsGroupGroup_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupAccountLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["accounts"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsClientClientApplicationLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["administered_clients"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["administered_systems"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupAccountLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		attr.DeprecationMessage = "This property will be removed in a future version."
		schemaAttrs["admins"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupLinkableWrapperWithCountRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["authorized_groups"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsClientOAuth2ClientPermissionWithClientLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["client_permissions"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupClientLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["clients"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["content_administered_systems"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupGlobalRoleInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["global_roles"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupAccessInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["group_access_info"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupAuditingInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["groupauditinginfo"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["groupinfo"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsDirectoryAccountDirectorySummaryLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["helpdesk"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsMarkItemMarkersRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["markers"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupAccountRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["myaccount"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupAccountRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["mydelegatedaccount"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupGroupPrimerLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["nested_groups"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProfileAccessProfileLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["owned_access_profiles"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsClientClientApplicationLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["owned_clients"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsDirectoryAccountDirectoryLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["owned_directories"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningOwnedGroupOnSystemsWrapperRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["owned_groups_on_system"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsOrganizationOrganizationalUnitLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["owned_organizational_units"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["owned_systems"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsAuditGroupAuditLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["recent_audits"] = attr
	}

	schemaAttrs["requeststatus"] = rsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsServiceaccountServiceAccountLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["service_accounts"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupProvisioningGroupLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["systems"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["vault"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsWebhookWebhookLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["webhooks"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsGroupProvisioningGroup(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupProvisioningGroup_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["activation_required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["group_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningGroupOnSystemRO(false),
		}
		attr.Computed = true
		attr.PlanModifiers = []planmodifier.Object{objectplanmodifier.UseStateForUnknown()}
		schemaAttrs["group_on_system"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsGroupProvisioningGroupRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsGroupProvisioningGroup_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["activation_required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Required = true
		schemaAttrs["group"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningGroupOnSystemRO(false),
		}
		attr.Computed = true
		attr.PlanModifiers = []planmodifier.Object{objectplanmodifier.UseStateForUnknown()}
		schemaAttrs["group_on_system"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsGroupProvisioningGroupLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupProvisioningGroupRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupProvisioningGroupLinkableWrapperWithCount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupProvisioningGroup(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupProvisioningGroupLinkableWrapperWithCountRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsGroupProvisioningGroupRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsGroupProvisioningGroup_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsGroupProvisioningGroup_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsGroupVaultVaultRecord(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"activationStatus", "audit", "parent", "passwordMetadata", "secret", "shareSummary", "shares", "tile", "vaultholder",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsVaultVaultRecord_additionalObjects(false))

	}
	schemaAttrs["group_uuid"] = rsschema.StringAttribute{
		Required:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.RequiresReplace()},
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["color"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NONE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "GREEN", "RED", "BLUE", "DARK", "PINK_LAVENDER", "CRIMSON_RED", "MIDDLE_YELLOW", "ANDROID_GREEN", "SAGE", "ARTICHOKE",
			),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["share_end_time"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["derived"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["filename"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["types"] = rsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["url"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["warning_period"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"AT_EXPIRATION", "TWO_WEEKS", "ONE_MONTH", "TWO_MONTHS", "THREE_MONTHS", "SIX_MONTHS", "NEVER",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsIdentityAccountAttributeDefinitionRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsIdentityAccountAttributeDefinition_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["format"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"INTERNAL", "EMAIL", "TELEPHONE", "NUMBER", "DATE", "DATETIME", "BOOLEAN", "TEXT",
			),
		},
	}
	schemaAttrs["list"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
	}
	schemaAttrs["required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["system_definition"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["unique"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsIdentityAccountAttributeDefinition_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsIdentityAccountAttributeRuleRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsIdentityAccountAttributeRule_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["allow_override"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["allow_self_service"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsIdentityAccountAttributeDefinitionRO(false),
		}
		attr.Optional = true
		schemaAttrs["attribute"] = attr
	}

	schemaAttrs["default_value"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["priority_directory"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(2),
	}
	schemaAttrs["priority_external_source"] = rsschema.Int64Attribute{
		Optional: true,
	}
	schemaAttrs["priority_formula"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(3),
	}
	schemaAttrs["priority_scim"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(1),
	}
	schemaAttrs["script"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["update_automatically"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	return schemaAttrs
}
func resourceSchemaAttrsIdentityAccountAttributeRuleLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsIdentityAccountAttributeRuleRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsIdentityAccountAttributeRule_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsIdentityAccountAttributeValueSummaryRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsIdentityAccountAttributeDefinitionRO(recurse),
		}
		attr.Optional = true
		schemaAttrs["attribute"] = attr
	}

	schemaAttrs["context"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["current_value"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["expected_value"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["source"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"SCIM", "EXTERNAL", "DIRECTORY", "FORMULA", "DEFAULT", "SELF_SERVICE", "OVERRIDE",
			),
		},
	}
	schemaAttrs["status"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"IN_SYNC", "OUT_OF_SYNC", "INVALID", "DUPLICATE", "ERROR", "MISSING", "UNKNOWN",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsLaunchpadSsoApplicationLaunchpadTile(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["uri"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsLaunchpadSsoApplicationLaunchpadTileRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["uri"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsLaunchpadVaultRecordLaunchpadTile(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsLaunchpadVaultRecordLaunchpadTileRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	return schemaAttrs
}
func resourceSchemaAttrsMarkItemMarkerRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["level"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["parameters"] = rsschema.MapAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}

	return schemaAttrs
}
func resourceSchemaAttrsMarkItemMarkersRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["markers"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsMarkItemMarkerRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsMiscAttributeCustomizationRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsIdentityAccountAttributeDefinitionRO(recurse),
		}
		attr.Optional = true
		schemaAttrs["attribute_definition"] = attr
	}

	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["script"] = rsschema.StringAttribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsNestedProvisioningGroupOnSystem(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"accessProfileProvisioning", "audit", "provgroups", "serviceAccounts",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProvisioningGroupOnSystem_additionalObjects(false))

	}
	schemaAttrs["provisioned_system_uuid"] = rsschema.StringAttribute{
		Required:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.RequiresReplace()},
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["display_name"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name_in_system"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"POSIX_GROUP", "GROUP_OF_NAMES", "GROUP_OF_UNIQUE_NAMES", "GROUP_GLOBAL_SECURITY", "GROUP_LOCAL_SECURITY", "GROUP_UNIVERSAL_SECURITY", "GROUP_UNKNOWN", "AZURE_ROLE", "AZURE_UNIFIED_GROUP", "AZURE_SECURITY_GROUP", "SCIM", "ACCOUNT_ONLY",
			),
		},
	}
	schemaAttrs["short_name_in_system"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["owner_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["provisioning_enabled"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationClientApplicationOrganizationalUnitRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationClientApplicationOrganizationalUnitLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsOrganizationClientApplicationOrganizationalUnitRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationOrganizationalUnitRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "settings",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsOrganizationOrganizationalUnit_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Optional = true
		schemaAttrs["auditor_group"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Optional = true
		schemaAttrs["create_group_approve_group"] = attr
	}

	schemaAttrs["create_group_placeholder"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["depth"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["description"] = rsschema.StringAttribute{
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Optional = true
		schemaAttrs["enable_tech_admin_approve_group"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Required = true
		schemaAttrs["owner"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["parent"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Optional = true
		schemaAttrs["recovery_fallback_group"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Optional = true
		schemaAttrs["remove_group_approve_group"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsOrganizationOrganizationalUnitLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsOrganizationOrganizationalUnitRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationOrganizationalUnitPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationOrganizationalUnitPrimerLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsOrganizationOrganizationalUnitSettingsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(recurse),
		}
		attr.Optional = true
		schemaAttrs["create_group_approve_group"] = attr
	}

	schemaAttrs["create_group_placeholder"] = rsschema.StringAttribute{
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(recurse),
		}
		attr.Optional = true
		schemaAttrs["enable_tech_admin_approve_group"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(recurse),
		}
		attr.Optional = true
		schemaAttrs["recovery_fallback_group"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(recurse),
		}
		attr.Optional = true
		schemaAttrs["remove_group_approve_group"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsOrganizationOrganizationalUnit_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsOrganizationOrganizationalUnitPrimerLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.WriteOnly = true
		schemaAttrs["create_as_parent_of"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsOrganizationOrganizationalUnitSettingsRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["settings"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"accountsWithAttributes", "attributeRules", "audit", "clients", "groups", "provisioning",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProfileAccessProfile_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["activate_rule_script"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["description"] = rsschema.StringAttribute{
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryAccountDirectoryPrimerRO(false),
		}
		attr.Optional = true
		schemaAttrs["directory"] = attr
	}

	schemaAttrs["match_rule_script"] = rsschema.StringAttribute{
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Required = true
		schemaAttrs["owner"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileAccountRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProfileAccessProfileAccount_additionalObjectsRO(false))

	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["activation"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("ACTIVE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"INACTIVE", "ACTIVE", "FORCE_INACTIVE", "FORCE_ACTIVE",
			),
		},
	}
	schemaAttrs["manual"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileAccountWithAttributesRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProfileAccessProfileAccount_additionalObjectsRO(false))

	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["activation"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("ACTIVE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"INACTIVE", "ACTIVE", "FORCE_INACTIVE", "FORCE_ACTIVE",
			),
		},
	}
	schemaAttrs["manual"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["attributes"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsIdentityAccountAttributeValueSummaryRO(false),
		},
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileAccountWithAttributesLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProfileAccessProfileAccountWithAttributesRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileAccount_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileClient(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProfileAccessProfileClient_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["access_profile_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientClientApplicationPrimerRO(false),
		}
		attr.Computed = true
		attr.PlanModifiers = []planmodifier.Object{objectplanmodifier.UseStateForUnknown()}
		schemaAttrs["client"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileClientRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProfileAccessProfileClient_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProfileAccessProfilePrimerRO(false),
		}
		attr.Required = true
		schemaAttrs["access_profile"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientClientApplicationPrimerRO(false),
		}
		attr.Computed = true
		attr.PlanModifiers = []planmodifier.Object{objectplanmodifier.UseStateForUnknown()}
		schemaAttrs["client"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileClientLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProfileAccessProfileClientRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileClientLinkableWrapperWithCount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProfileAccessProfileClient(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileClientLinkableWrapperWithCountRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProfileAccessProfileClientRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileClient_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileClient_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileGroupRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProfileAccessProfileGroup_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProfileAccessProfilePrimerRO(false),
		}
		attr.Computed = true
		attr.PlanModifiers = []planmodifier.Object{objectplanmodifier.UseStateForUnknown()}
		schemaAttrs["access_profile"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Computed = true
		attr.PlanModifiers = []planmodifier.Object{objectplanmodifier.UseStateForUnknown()}
		schemaAttrs["group"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileGroupLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProfileAccessProfileGroupRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileGroup_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProfileAccessProfileRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfilePrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfilePrimerRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileProvisioning(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProfileAccessProfileProvisioning_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProfileAccessProfilePrimerRO(false),
		}
		attr.Computed = true
		attr.PlanModifiers = []planmodifier.Object{objectplanmodifier.UseStateForUnknown()}
		schemaAttrs["access_profile"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningGroupOnSystemRO(false),
		}
		attr.Computed = true
		attr.PlanModifiers = []planmodifier.Object{objectplanmodifier.UseStateForUnknown()}
		schemaAttrs["group_on_system"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileProvisioningRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProfileAccessProfileProvisioning_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProfileAccessProfilePrimerRO(false),
		}
		attr.Computed = true
		attr.PlanModifiers = []planmodifier.Object{objectplanmodifier.UseStateForUnknown()}
		schemaAttrs["access_profile"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningGroupOnSystemRO(false),
		}
		attr.Computed = true
		attr.PlanModifiers = []planmodifier.Object{objectplanmodifier.UseStateForUnknown()}
		schemaAttrs["group_on_system"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileProvisioningLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProfileAccessProfileProvisioningRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileProvisioningLinkableWrapperWithCount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProfileAccessProfileProvisioning(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileProvisioningLinkableWrapperWithCountRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProfileAccessProfileProvisioningRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileProvisioning_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfileProvisioning_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProfileAccessProfile_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProfileAccessProfileAccountWithAttributesLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["accounts_with_attributes"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsIdentityAccountAttributeRuleLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["attribute_rules"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProfileAccessProfileClientLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["clients"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProfileAccessProfileGroupLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["groups"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProfileAccessProfileProvisioningLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["provisioning"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProvisioningAbstractProvisionedLDAPRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["attributes"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsMiscAttributeCustomizationRO(recurse),
		},
		Optional: true,
	}
	schemaAttrs["base_dn"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["bind_dn"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["bind_password"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 128),
		},
		Sensitive: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsCertificateCertificatePrimerRO(recurse),
		}
		attr.Optional = true
		schemaAttrs["client_certificate"] = attr
	}

	schemaAttrs["failover_host"] = rsschema.StringAttribute{
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsCertificateCertificatePrimerRO(recurse),
		}
		attr.Optional = true
		schemaAttrs["failover_trusted_certificate"] = attr
	}

	schemaAttrs["group_dn"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["host"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["object_classes"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["port"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(0),
	}
	schemaAttrs["service_account_dn"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["ssh_public_key_support"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("SSH_PUBLIC_KEY"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"DISABLED", "SSH_PUBLIC_KEY", "ALT_SECURITY_IDENTITIES",
			),
		},
	}
	schemaAttrs["tls"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"VERIFIED_PINNED", "VERIFIED", "SECURE_PINNED", "SECURE", "ENCRYPTED", "UNSECURE",
			),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsCertificateCertificatePrimerRO(recurse),
		}
		attr.Optional = true
		schemaAttrs["trusted_certificate"] = attr
	}

	schemaAttrs["user_dn"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningCircuitBreakerStatisticsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["number_of_failed_calls"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["number_of_not_permitted_calls"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["number_of_successful_calls"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["state"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningGroupOnSystemRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"accessProfileProvisioning", "audit", "provgroups", "serviceAccounts",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProvisioningGroupOnSystem_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["display_name"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name_in_system"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"POSIX_GROUP", "GROUP_OF_NAMES", "GROUP_OF_UNIQUE_NAMES", "GROUP_GLOBAL_SECURITY", "GROUP_LOCAL_SECURITY", "GROUP_UNIVERSAL_SECURITY", "GROUP_UNKNOWN", "AZURE_ROLE", "AZURE_UNIFIED_GROUP", "AZURE_SECURITY_GROUP", "SCIM", "ACCOUNT_ONLY",
			),
		},
	}
	schemaAttrs["short_name_in_system"] = rsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Required = true
		schemaAttrs["owner"] = attr
	}

	schemaAttrs["provisioning_enabled"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningGroupOnSystemLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProvisioningGroupOnSystemRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningGroupOnSystemPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["display_name"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name_in_system"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"POSIX_GROUP", "GROUP_OF_NAMES", "GROUP_OF_UNIQUE_NAMES", "GROUP_GLOBAL_SECURITY", "GROUP_LOCAL_SECURITY", "GROUP_UNIVERSAL_SECURITY", "GROUP_UNKNOWN", "AZURE_ROLE", "AZURE_UNIFIED_GROUP", "AZURE_SECURITY_GROUP", "SCIM", "ACCOUNT_ONLY",
			),
		},
	}
	schemaAttrs["short_name_in_system"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningGroupOnSystemPrimerRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["display_name"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name_in_system"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"POSIX_GROUP", "GROUP_OF_NAMES", "GROUP_OF_UNIQUE_NAMES", "GROUP_GLOBAL_SECURITY", "GROUP_LOCAL_SECURITY", "GROUP_UNIVERSAL_SECURITY", "GROUP_UNKNOWN", "AZURE_ROLE", "AZURE_UNIFIED_GROUP", "AZURE_SECURITY_GROUP", "SCIM", "ACCOUNT_ONLY",
			),
		},
	}
	schemaAttrs["short_name_in_system"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningGroupOnSystemTypesRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["types"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Validators: []validator.List{
			listvalidator.ValueStringsAre(
				stringvalidator.OneOf(
					"POSIX_GROUP", "GROUP_OF_NAMES", "GROUP_OF_UNIQUE_NAMES", "GROUP_GLOBAL_SECURITY", "GROUP_LOCAL_SECURITY", "GROUP_UNIVERSAL_SECURITY", "GROUP_UNKNOWN", "AZURE_ROLE", "AZURE_UNIFIED_GROUP", "AZURE_SECURITY_GROUP", "SCIM", "ACCOUNT_ONLY",
				),
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningGroupOnSystem_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProfileAccessProfileProvisioningLinkableWrapperWithCount(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["access_profile_provisioning"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupProvisioningGroupLinkableWrapperWithCount(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["provgroups"] = attr
	}

	{
		attr := resetSetAttributeFlags(resourceSchemaAttrsServiceaccountServiceAccountPrimerLinkableWrapperWithCount(recurse)["items"].(rsschema.SetAttribute))
		attr.Optional = true
		schemaAttrs["service_accounts_uuid"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProvisioningGroupOnSystem_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProfileAccessProfileProvisioningLinkableWrapperWithCountRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["access_profile_provisioning"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsGroupProvisioningGroupLinkableWrapperWithCountRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["provgroups"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsServiceaccountServiceAccountPrimerLinkableWrapperWithCountRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Optional = true
		schemaAttrs["service_accounts"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProvisioningOwnedGroupOnSystemsWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProvisioningGroupOnSystemRO(recurse),
		},
		Optional: true,
	}
	schemaAttrs["unlinked_count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionNumberSequenceRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "systems",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProvisioningProvisionNumberSequence_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["next_id"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(2001),
		Validators: []validator.Int64{
			int64validator.Between(2000, 60000),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionNumberSequence_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsProvisioningProvisionedSystemPrimerLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["systems"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedADRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["sam_account_name_scheme"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"OMIT", "TRUNCATE", "TRANSFER", "TRANSFER_TRUNCATE", "USERNAME",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedAccountRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProvisioningProvisionedAccount_additionalObjectsRO(false))

	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["uid"] = rsschema.Int64Attribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Int64{int64planmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedAccount_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedAzureOIDCDirectoryRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["accounts_writable"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryAccountDirectoryPrimerRO(recurse),
		}
		attr.Required = true
		schemaAttrs["directory"] = attr
	}

	schemaAttrs["tenant"] = rsschema.StringAttribute{
		Required: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedAzureSyncLDAPDirectoryRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["client_id"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["client_secret"] = rsschema.StringAttribute{
		Required:  true,
		Sensitive: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryAccountDirectoryPrimerRO(recurse),
		}
		attr.Required = true
		schemaAttrs["directory"] = attr
	}

	schemaAttrs["tenant"] = rsschema.StringAttribute{
		Required: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedAzureTenantRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["client_id"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["client_secret"] = rsschema.StringAttribute{
		Required:  true,
		Sensitive: true,
	}
	schemaAttrs["idp_domain"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["tenant"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedInternalLDAPRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientLdapClientRO(recurse),
		}
		attr.Optional = true
		schemaAttrs["client"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedLDAPRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["gid"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(2000),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionNumberSequenceRO(recurse),
		}
		attr.Required = true
		schemaAttrs["gid_numbering"] = attr
	}

	schemaAttrs["hashing_scheme"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"SSHA", "PBKDF2",
			),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionNumberSequenceRO(recurse),
		}
		attr.Required = true
		schemaAttrs["numbering"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedLDAPDirectoryRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["accounts_writable"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["attributes"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsMiscAttributeCustomizationRO(recurse),
		},
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryAccountDirectoryPrimerRO(recurse),
		}
		attr.Required = true
		schemaAttrs["directory"] = attr
	}

	schemaAttrs["gid"] = rsschema.Int64Attribute{
		Computed: true,
		Optional: true,
		Default:  int64default.StaticInt64(2000),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionNumberSequenceRO(recurse),
		}
		attr.Optional = true
		schemaAttrs["gid_numbering"] = attr
	}

	schemaAttrs["group_dn"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["hashing_scheme"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("PBKDF2"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"SSHA", "PBKDF2",
			),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionNumberSequenceRO(recurse),
		}
		attr.Optional = true
		schemaAttrs["numbering"] = attr
	}

	schemaAttrs["object_classes"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["sam_account_name_scheme"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("USERNAME"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"OMIT", "TRUNCATE", "TRANSFER", "TRANSFER_TRUNCATE", "USERNAME",
			),
		},
	}
	schemaAttrs["ssh_public_key_support"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("DISABLED"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"DISABLED", "SSH_PUBLIC_KEY", "ALT_SECURITY_IDENTITIES",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedNamespaceRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedSystemPrimerRO(recurse),
		}
		attr.Required = true
		schemaAttrs["base_system"] = attr
	}

	schemaAttrs["group_dn"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["service_account_dn"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedSCIMRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["attributes"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsMiscAttributeCustomizationRO(recurse),
		},
		Optional: true,
	}
	schemaAttrs["authentication_scheme"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NONE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "BASIC", "BEARER", "CUSTOM",
			),
		},
	}
	schemaAttrs["basic_auth_password"] = rsschema.StringAttribute{
		Optional:  true,
		Sensitive: true,
	}
	schemaAttrs["basic_auth_username"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["bearer_token"] = rsschema.StringAttribute{
		Optional:  true,
		Sensitive: true,
	}
	schemaAttrs["custom_header_name"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 64),
		},
	}
	schemaAttrs["custom_header_value"] = rsschema.StringAttribute{
		Optional:  true,
		Sensitive: true,
	}
	schemaAttrs["url"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["vendor_escaped"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("DEFAULT"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"DEFAULT", "AWS", "KEYSTONE",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedSystemRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"account", "audit", "issuedPermissions", "loginName", "managementPermissions", "markers", "statistics", "supportedGroupTypes",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsProvisioningProvisionedSystem_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["admin_permissions"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["can_write_accounts"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["content_admin_permissions"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["organizational_unit"] = attr
	}

	schemaAttrs["owner_permissions"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["account_count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedSystem_cleanupPeriodRO(false),
		}
		attr.Required = true
		schemaAttrs["cleanup_period"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["content_administrator"] = attr
	}

	schemaAttrs["external_uuid"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["group_on_system_provisioning"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("ALWAYS_PROVISIONED"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ALWAYS_PROVISIONED", "PROVISIONED_BY_DEFAULT_CAN_ONLY_BE_ENABLED", "NOT_PROVISIONED_BY_DEFAULT_CAN_ONLY_BE_ENABLED", "PROVISIONED_BY_DEFAULT", "NOT_PROVISIONED_BY_DEFAULT",
			),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Required = true
		schemaAttrs["owner"] = attr
	}

	schemaAttrs["self_service_existing_groups"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["self_service_new_groups"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["self_service_new_namespaces"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["self_service_service_accounts"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["should_destroy_unknown_accounts"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Required = true
		schemaAttrs["technical_administrator"] = attr
	}

	schemaAttrs["username_prefix"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningAbstractProvisionedLDAPRO(false),
		}
		attr.Optional = true
		schemaAttrs["abstract_provisioned_ldap"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedADRO(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_a_d"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedAzureOIDCDirectoryRO(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_azure_oidc_directory"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedAzureSyncLDAPDirectoryRO(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_azure_sync_ldap_directory"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedAzureTenantRO(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_azure_tenant"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedInternalLDAPRO(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_internal_ldap"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedLDAPRO(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_ldap"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedLDAPDirectoryRO(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_ldap_directory"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedNamespaceRO(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_namespace"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedSCIMRO(false),
		}
		attr.Optional = true
		schemaAttrs["provisioned_scim"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedSystemLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProvisioningProvisionedSystemRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedSystemPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["admin_permissions"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["can_write_accounts"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["content_admin_permissions"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["organizational_unit_uuid"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["owner_permissions"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedSystemPrimerRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["admin_permissions"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["can_write_accounts"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["content_admin_permissions"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsOrganizationOrganizationalUnitPrimerRO(recurse),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["organizational_unit"] = attr
	}

	schemaAttrs["owner_permissions"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedSystemPrimerLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsProvisioningProvisionedSystemPrimerRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedSystem_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedAccountRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["account"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsClientOAuth2ClientPermissionWithClientLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["issued_permissions"] = attr
	}

	schemaAttrs["login_name"] = rsschema.StringAttribute{
		Computed: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisioningManagementPermissionsRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["management_permissions"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsMarkItemMarkersRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["markers"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningCircuitBreakerStatisticsRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["statistics"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningGroupOnSystemTypesRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["supported_group_types"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisionedSystem_cleanupPeriodRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["days"] = rsschema.Int64Attribute{
		Optional: true,
	}
	schemaAttrs["months"] = rsschema.Int64Attribute{
		Optional: true,
	}
	schemaAttrs["years"] = rsschema.Int64Attribute{
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsProvisioningProvisioningManagementPermissionsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["create_new_groups_allowed"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["create_service_accounts_allowed"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["reuse_existing_groups_allowed"] = rsschema.BoolAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "groups", "secret", "supportedFeatures",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsServiceaccountServiceAccount_additionalObjects(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["system_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["description"] = rsschema.StringAttribute{
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultRecordPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["password"] = attr
	}

	schemaAttrs["password_rotation"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("DAILY"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"MANUAL", "MANUAL_STORED_IN_VAULT", "DAILY",
			),
		},
	}
	schemaAttrs["ssh_public_key"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["technical_administrator_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit", "groups", "secret", "supportedFeatures",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsServiceaccountServiceAccount_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedSystemPrimerRO(recurse),
		}
		attr.Required = true
		schemaAttrs["system"] = attr
	}

	schemaAttrs["username"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["description"] = rsschema.StringAttribute{
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultRecordPrimerRO(false),
		}
		attr.Computed = true
		schemaAttrs["password"] = attr
	}

	schemaAttrs["password_rotation"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("DAILY"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"MANUAL", "MANUAL_STORED_IN_VAULT", "DAILY",
			),
		},
	}
	schemaAttrs["ssh_public_key"] = rsschema.StringAttribute{
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Required = true
		schemaAttrs["technical_administrator"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountGroupRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsServiceaccountServiceAccountGroup_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["display_name"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["name_in_system"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"POSIX_GROUP", "GROUP_OF_NAMES", "GROUP_OF_UNIQUE_NAMES", "GROUP_GLOBAL_SECURITY", "GROUP_LOCAL_SECURITY", "GROUP_UNIVERSAL_SECURITY", "GROUP_UNKNOWN", "AZURE_ROLE", "AZURE_UNIFIED_GROUP", "AZURE_SECURITY_GROUP", "SCIM", "ACCOUNT_ONLY",
			),
		},
	}
	schemaAttrs["short_name_in_system"] = rsschema.StringAttribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountGroupLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsServiceaccountServiceAccountGroupRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountGroup_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsServiceaccountServiceAccountRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["system_uuid"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
		},
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountPrimerRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedSystemPrimerRO(recurse),
		}
		attr.Required = true
		schemaAttrs["system"] = attr
	}

	schemaAttrs["username"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountPrimerLinkableWrapperWithCount(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = rsschema.SetAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Validators: []validator.Set{
			setvalidator.ValueStringsAre(
				stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"), "The value must be a valid UUID"),
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountPrimerLinkableWrapperWithCountRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsServiceaccountServiceAccountPrimerRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccountSupportedFeaturesRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["ssh_public_key"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccount_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsServiceaccountServiceAccountGroupLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["groups"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGeneratedSecret(recurse),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["secret"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsServiceaccountServiceAccountSupportedFeaturesRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["supported_features"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsServiceaccountServiceAccount_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsServiceaccountServiceAccountGroupLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["groups"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGeneratedSecretRO(recurse),
		}
		attr.Optional = true
		attr.Computed = true
		schemaAttrs["secret"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsServiceaccountServiceAccountSupportedFeaturesRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["supported_features"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsVaultPasswordMetadataRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["dictionary"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["duplicate"] = rsschema.BoolAttribute{
		Computed: true,
	}
	schemaAttrs["hash"] = rsschema.StringAttribute{
		Computed: true,
	}
	schemaAttrs["length"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["lower_count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["number_count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["special_count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["strength"] = rsschema.Int64Attribute{
		Computed: true,
	}
	schemaAttrs["upper_count"] = rsschema.Int64Attribute{
		Computed: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["access_available"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["records"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsVaultVaultRecordRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultActivationStatusRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["activated"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["activation_required"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecordRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"activationStatus", "audit", "parent", "passwordMetadata", "secret", "shareSummary", "shares", "tile", "vaultholder",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsVaultVaultRecord_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["color"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NONE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "GREEN", "RED", "BLUE", "DARK", "PINK_LAVENDER", "CRIMSON_RED", "MIDDLE_YELLOW", "ANDROID_GREEN", "SAGE", "ARTICHOKE",
			),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["share_end_time"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["derived"] = rsschema.BoolAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.Bool{boolplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["end_date"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["filename"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["types"] = rsschema.SetAttribute{
		ElementType: types.StringType,
		Computed:    true,
	}
	schemaAttrs["url"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["username"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["warning_period"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"AT_EXPIRATION", "TWO_WEEKS", "ONE_MONTH", "TWO_MONTHS", "THREE_MONTHS", "SIX_MONTHS", "NEVER",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecordPrimer(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLink(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermission(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["color"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NONE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "GREEN", "RED", "BLUE", "DARK", "PINK_LAVENDER", "CRIMSON_RED", "MIDDLE_YELLOW", "ANDROID_GREEN", "SAGE", "ARTICHOKE",
			),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["share_end_time"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecordPrimerRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["color"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NONE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "GREEN", "RED", "BLUE", "DARK", "PINK_LAVENDER", "CRIMSON_RED", "MIDDLE_YELLOW", "ANDROID_GREEN", "SAGE", "ARTICHOKE",
			),
		},
	}
	schemaAttrs["name"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["share_end_time"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecordPrimerLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsVaultVaultRecordPrimerRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecordSecrets(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["comment"] = rsschema.StringAttribute{
		Optional:  true,
		Sensitive: true,
	}
	schemaAttrs["file"] = rsschema.StringAttribute{
		Optional:  true,
		Sensitive: true,
	}
	schemaAttrs["password"] = rsschema.StringAttribute{
		Optional:  true,
		Sensitive: true,
	}
	schemaAttrs["totp"] = rsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["totp_key"] = rsschema.StringAttribute{
		WriteOnly: true,
		Optional:  true,
		Sensitive: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecordSecretsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["comment"] = rsschema.StringAttribute{
		Optional:  true,
		Sensitive: true,
	}
	schemaAttrs["file"] = rsschema.StringAttribute{
		Optional:  true,
		Sensitive: true,
	}
	schemaAttrs["password"] = rsschema.StringAttribute{
		Optional:  true,
		Sensitive: true,
	}
	schemaAttrs["totp"] = rsschema.StringAttribute{
		Computed:  true,
		Sensitive: true,
	}
	schemaAttrs["totp_key"] = rsschema.StringAttribute{
		WriteOnly: true,
		Optional:  true,
		Sensitive: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecordShareRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["name"] = rsschema.StringAttribute{
		Optional: true,
	}
	schemaAttrs["type"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.OneOf(
				"ACCOUNT", "CLIENT", "GROUP",
			),
		},
	}
	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecordShareSummaryRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["children"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsVaultVaultRecordShareRO(recurse),
		},
		Optional: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultRecordShareRO(recurse),
		}
		attr.Optional = true
		schemaAttrs["parent"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecord_additionalObjects(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultActivationStatusRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["activation_status"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	schemaAttrs["delete_tile"] = rsschema.BoolAttribute{
		WriteOnly: true,
		Optional:  true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultRecordPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["parent"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultPasswordMetadataRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["password_metadata"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultRecordSecrets(recurse),
		}
		attr.Optional = true
		schemaAttrs["secret"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultRecordShareSummaryRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["share_summary"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsVaultVaultRecordPrimerLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["shares"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsLaunchpadVaultRecordLaunchpadTile(recurse),
		}
		attr.Optional = true
		schemaAttrs["tile"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsLinkableRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["vaultholder"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsVaultVaultRecord_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultActivationStatusRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["activation_status"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	schemaAttrs["delete_tile"] = rsschema.BoolAttribute{
		WriteOnly: true,
		Optional:  true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultRecordPrimerRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["parent"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultPasswordMetadataRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["password_metadata"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultRecordSecretsRO(recurse),
		}
		attr.Optional = true
		schemaAttrs["secret"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsVaultVaultRecordShareSummaryRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["share_summary"] = attr
	}

	{
		attr := resetListNestedAttributeFlags(resourceSchemaAttrsVaultVaultRecordPrimerLinkableWrapperRO(recurse)["items"].(rsschema.ListNestedAttribute))
		attr.Computed = true
		schemaAttrs["shares"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsLaunchpadVaultRecordLaunchpadTileRO(recurse),
		}
		attr.Optional = true
		schemaAttrs["tile"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsLinkableRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["vaultholder"] = attr
	}

	return schemaAttrs
}
func resourceSchemaAttrsWebhookWebhookRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	if recurse {
		schemaAttrs["additional"] = rsschema.ListAttribute{
			ElementType: types.StringType,
			Optional:    true,
			Validators: []validator.List{
				listvalidator.ValueStringsAre(stringvalidator.OneOf(
					"audit",
				)),
			},
		}
	}
	if recurse {
		maps.Copy(schemaAttrs, resourceSchemaAttrsWebhookWebhook_additionalObjectsRO(false))

	}
	schemaAttrs["links"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsRestLinkRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["permissions"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsAuthPermissionRO(recurse),
		},
		Computed:      true,
		PlanModifiers: []planmodifier.List{listplanmodifier.UseStateForUnknown()},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuthAccountPrimerRO(false),
		}
		attr.Optional = true
		schemaAttrs["account"] = attr
	}

	schemaAttrs["active"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(true),
	}
	schemaAttrs["all_types"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	schemaAttrs["authentication_scheme"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("NONE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"NONE", "BASIC", "BEARER", "CUSTOM",
			),
		},
	}
	schemaAttrs["basic_auth_password"] = rsschema.StringAttribute{
		Optional:  true,
		Sensitive: true,
	}
	schemaAttrs["basic_auth_username"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	schemaAttrs["bearer_token"] = rsschema.StringAttribute{
		Optional:  true,
		Sensitive: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsClientClientApplicationPrimerRO(false),
		}
		attr.Optional = true
		schemaAttrs["client"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsCertificateCertificatePrimerRO(false),
		}
		attr.Optional = true
		schemaAttrs["client_certificate"] = attr
	}

	schemaAttrs["custom_header_name"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 64),
		},
	}
	schemaAttrs["custom_header_value"] = rsschema.StringAttribute{
		Optional:  true,
		Sensitive: true,
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsDirectoryAccountDirectoryPrimerRO(false),
		}
		attr.Optional = true
		schemaAttrs["directory"] = attr
	}

	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsGroupGroupPrimerRO(false),
		}
		attr.Optional = true
		schemaAttrs["group"] = attr
	}

	schemaAttrs["name"] = rsschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 255),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsProvisioningProvisionedSystemPrimerRO(false),
		}
		attr.Optional = true
		schemaAttrs["system"] = attr
	}

	schemaAttrs["tls"] = rsschema.StringAttribute{
		Computed: true,
		Optional: true,
		Default:  stringdefault.StaticString("SECURE"),
		Validators: []validator.String{
			stringvalidator.OneOf(
				"VERIFIED_PINNED", "VERIFIED", "SECURE_PINNED", "SECURE", "ENCRYPTED", "UNSECURE",
			),
		},
	}
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsCertificateCertificatePrimerRO(false),
		}
		attr.Optional = true
		schemaAttrs["trusted_certificate"] = attr
	}

	schemaAttrs["types"] = rsschema.ListAttribute{
		ElementType: types.StringType,
		Optional:    true,
		Validators: []validator.List{
			listvalidator.ValueStringsAre(
				stringvalidator.OneOf(
					"ACCESS_PROFILE_CREATED", "ACCESS_PROFILE_MODIFIED", "ACCESS_PROFILE_REMOVED", "ACCOUNT_2FA_DISABLED", "ACCOUNT_2FA_ENABLED", "ACCOUNT_ACCESS_PROFILE_DEPROVISIONED", "ACCOUNT_ACCESS_PROFILE_PROVISIONED", "ACCOUNT_ACTIVATION_CODE_USED", "ACCOUNT_ADDED_TO_ACCESS_PROFILE", "ACCOUNT_ADDED_TO_GROUP", "ACCOUNT_ADDED_TO_ORGANIZATIONAL_UNIT", "ACCOUNT_CREATED", "ACCOUNT_DEPROVISIONED", "ACCOUNT_DISABLED", "ACCOUNT_ENABLED", "ACCOUNT_GROUP_ACTIVATED", "ACCOUNT_GROUP_ACTIVATION_REASON", "ACCOUNT_GROUP_DEPROVISIONED", "ACCOUNT_GROUP_PROVISIONED", "ACCOUNT_LOGIN", "ACCOUNT_LOGIN_FAILED", "ACCOUNT_MODIFIED_FOR_ACCESS_PROFILE", "ACCOUNT_MODIFIED_FOR_GROUP", "ACCOUNT_PASSWORD_CHANGED", "ACCOUNT_PROVISIONED", "ACCOUNT_PROVISIONING_DESTROYED", "ACCOUNT_PROVISIONING_INITED", "ACCOUNT_PROVISIONING_MOVED", "ACCOUNT_PROVISIONING_SETUP", "ACCOUNT_REMOVED", "ACCOUNT_REMOVED_FROM_ACCESS_PROFILE", "ACCOUNT_REMOVED_FROM_GROUP", "ACCOUNT_REMOVED_FROM_ORGANIZATIONAL_UNIT", "ACCOUNT_REREGISTERED", "ACCOUNT_SSH_PUBLIC_KEY_MODIFIED", "ACCOUNT_TOKEN_SIGNED", "ACCOUNT_TOTP_OFFSET_CHANGED", "ACCOUNT_VAULT_UNLOCKED", "ADD_GROUP_ADMIN_ACCEPTED", "ADD_GROUP_ADMIN_DECLINED", "ADD_GROUP_ADMIN_REQUESTED", "ADD_GROUP_TO_ACCESS_PROFILE_ACCEPTED", "ADD_GROUP_TO_ACCESS_PROFILE_DECLINED", "ADD_GROUP_TO_ACCESS_PROFILE_REQUESTED", "AUDITOR_EXPORT_GENERATED", "CERTIFICATE_CREATED", "CERTIFICATE_MODIFIED", "CERTIFICATE_REMOVED", "CLIENT_ADDED_TO_ACCESS_PROFILE", "CLIENT_ADDED_TO_GROUP", "CLIENT_ADDED_TO_ORGANIZATIONAL_UNIT", "CLIENT_CREATED", "CLIENT_MODIFIED", "CLIENT_MODIFIED_FOR_GROUP", "CLIENT_PERMISSION_GRANTED", "CLIENT_PERMISSION_REVOKED", "CLIENT_REMOVED", "CLIENT_REMOVED_FROM_ACCESS_PROFILE", "CLIENT_REMOVED_FROM_GROUP", "CLIENT_REMOVED_FROM_ORGANIZATIONAL_UNIT", "CLIENT_SECRET_ROTATED", "CREATE_GROUP_ACCEPTED", "CREATE_GROUP_DECLINED", "CREATE_GROUP_REQUESTED", "CREATE_GROUP_ON_SYSTEM_ACCEPTED", "CREATE_GROUP_ON_SYSTEM_DECLINED", "CREATE_GROUP_ON_SYSTEM_REQUESTED", "CREATE_PROVISIONED_NAMESPACE_ACCEPTED", "CREATE_PROVISIONED_NAMESPACE_DECLINED", "CREATE_PROVISIONED_NAMESPACE_REQUESTED", "CREATE_SERVICE_ACCOUNT_ACCEPTED", "CREATE_SERVICE_ACCOUNT_DECLINED", "CREATE_SERVICE_ACCOUNT_REQUESTED", "DIRECTORY_CREATED", "DIRECTORY_HELPDESK_MODIFIED", "DIRECTORY_MODIFIED", "DIRECTORY_REMOVED", "DISABLE_2FA_ACCEPTED", "DISABLE_2FA_DECLINED", "DISABLE_2FA_REQUESTED", "ENABLE_PROFILE_ADMINISTRATION_ACCEPTED", "ENABLE_PROFILE_ADMINISTRATION_DECLINED", "ENABLE_PROFILE_ADMINISTRATION_REQUESTED", "ENABLE_TECHNICAL_ADMINISTRATION_ACCEPTED", "ENABLE_TECHNICAL_ADMINISTRATION_DECLINED", "ENABLE_TECHNICAL_ADMINISTRATION_REQUESTED", "EXTENDED_ACCESS_ACCEPTED", "EXTENDED_ACCESS_DECLINED", "EXTENDED_ACCESS_REQUESTED", "GRANT_ACCESS_ACCEPTED", "GRANT_ACCESS_DECLINED", "GRANT_ACCESS_REQUESTED", "GRANT_APPLICATION_ACCEPTED", "GRANT_APPLICATION_DECLINED", "GRANT_APPLICATION_REQUESTED", "GRANT_CLIENT_PERMISSION_ACCEPTED", "GRANT_CLIENT_PERMISSION_DECLINED", "GRANT_CLIENT_PERMISSION_REQUESTED", "GRANT_GROUP_ON_SYSTEM_ACCEPTED", "GRANT_GROUP_ON_SYSTEM_DECLINED", "GRANT_GROUP_ON_SYSTEM_REQUESTED", "GRANT_GROUP_ON_SYSTEM_REQUEST_ACCEPTED", "GRANT_GROUP_ON_SYSTEM_REQUEST_DECLINED", "GRANT_GROUP_ON_SYSTEM_REQUEST_REQUESTED", "GRANT_SERVICE_ACCOUNT_GROUP_ACCEPTED", "GRANT_SERVICE_ACCOUNT_GROUP_DECLINED", "GRANT_SERVICE_ACCOUNT_GROUP_REQUESTED", "GROUP_ADDED_TO_ACCESS_PROFILE", "GROUP_AUDIT_CREATED", "GROUP_AUDIT_REQUESTED", "GROUP_AUTHORIZATION_CONNECTED", "GROUP_AUTHORIZATION_DISCONNECTED", "GROUP_CLASSIFICATION_ASSIGNED", "GROUP_CLASSIFICATION_CREATED", "GROUP_CLASSIFICATION_MODIFIED", "GROUP_CLASSIFICATION_REMOVED", "GROUP_CREATED", "GROUP_MODIFIED", "GROUP_MOVED", "GROUP_NESTING_CONNECTED", "GROUP_NESTING_DISCONNECTED", "GROUP_ON_SYSTEM_MODIFIED", "GROUP_ON_SYSTEM_DEPROVISIONED", "GROUP_ON_SYSTEM_CREATED", "GROUP_ON_SYSTEM_PROVISIONED", "GROUP_ON_SYSTEM_REMOVED", "GROUP_REMOVED", "GROUP_REMOVED_FROM_ACCESS_PROFILE", "IDENTITY_SOURCE_CREATED", "IDENTITY_SOURCE_MODIFIED", "IDENTITY_SOURCE_REMOVED", "INTERNAL_ACCOUNT_ACTIVATED", "INTERNAL_ACCOUNT_CREATED", "INTERNAL_ACCOUNT_MODIFIED", "INTERNAL_ACCOUNT_REMOVED", "INVALID_SIGNATURE_DETECTED", "JOIN_GROUP_ACCEPTED", "JOIN_GROUP_DECLINED", "JOIN_GROUP_REQUESTED", "JOIN_VAULT_ACCEPTED", "JOIN_VAULT_DECLINED", "JOIN_VAULT_REQUESTED", "LICENSE_KEY_UPLOADED", "LINK_DIRECTORY_TO_ACCESS_PROFILE_ACCEPTED", "LINK_DIRECTORY_TO_ACCESS_PROFILE_DECLINED", "LINK_DIRECTORY_TO_ACCESS_PROFILE_REQUESTED", "MOVE_GROUPS_ACCEPTED", "MOVE_GROUPS_DECLINED", "MOVE_GROUPS_REQUESTED", "ORGANIZATIONAL_UNIT_CREATED", "ORGANIZATIONAL_UNIT_MODIFIED", "ORGANIZATIONAL_UNIT_REMOVED", "PROVISIONED_SYSTEM_ADDED_TO_ACCESS_PROFILE", "PROVISIONED_SYSTEM_ADDED_TO_GROUP", "PROVISIONED_SYSTEM_CREATED", "PROVISIONED_SYSTEM_MODIFIED", "PROVISIONED_SYSTEM_MODIFIED_FOR_GROUP", "PROVISIONED_SYSTEM_REMOVED", "PROVISIONED_SYSTEM_REMOVED_FROM_ACCESS_PROFILE", "PROVISIONED_SYSTEM_REMOVED_FROM_GROUP", "PROVISIONED_SYSTEM_UNKNOWN_ACCOUNT_DESTROYED", "REMOVE_ACCESS_PROFILE_ACCEPTED", "REMOVE_ACCESS_PROFILE_DECLINED", "REMOVE_ACCESS_PROFILE_REQUESTED", "REMOVE_GROUP_ACCEPTED", "REMOVE_GROUP_DECLINED", "REMOVE_GROUP_REQUESTED", "REMOVE_ORGANIZATIONAL_UNIT_ACCEPTED", "REMOVE_ORGANIZATIONAL_UNIT_DECLINED", "REMOVE_ORGANIZATIONAL_UNIT_REQUESTED", "REMOVE_PROVISIONED_SYSTEM_ACCEPTED", "REMOVE_PROVISIONED_SYSTEM_DECLINED", "REMOVE_PROVISIONED_SYSTEM_REQUESTED", "RESET_PASSWORD_ACCEPTED", "RESET_PASSWORD_DECLINED", "RESET_PASSWORD_FINISHED", "RESET_PASSWORD_REQUESTED", "REVIEW_AUDIT_ACCEPTED", "REVIEW_AUDIT_DECLINED", "REVIEW_AUDIT_REQUESTED", "REVOKE_ADMIN_ACCEPTED", "REVOKE_ADMIN_DECLINED", "REVOKE_ADMIN_REQUESTED", "SERVICE_ACCOUNT_ADDED_TO_GROUP", "SERVICE_ACCOUNT_CREATED", "SERVICE_ACCOUNT_DEPROVISIONED", "SERVICE_ACCOUNT_GROUP_DEPROVISIONED", "SERVICE_ACCOUNT_GROUP_PROVISIONED", "SERVICE_ACCOUNT_MODIFIED", "SERVICE_ACCOUNT_PASSWORD_ROTATED", "SERVICE_ACCOUNT_PROVISIONED", "SERVICE_ACCOUNT_PROVISIONING_DESTROYED", "SERVICE_ACCOUNT_PROVISIONING_INITED", "SERVICE_ACCOUNT_REMOVED", "SERVICE_ACCOUNT_REMOVED_FROM_GROUP", "SETTING_MODIFIED", "SETUP_AUTHORIZING_GROUP_CONNECT_ACCEPTED", "SETUP_AUTHORIZING_GROUP_CONNECT_DECLINED", "SETUP_AUTHORIZING_GROUP_CONNECT_REQUESTED", "SETUP_AUTHORIZING_GROUP_DISCONNECT_ACCEPTED", "SETUP_AUTHORIZING_GROUP_DISCONNECT_DECLINED", "SETUP_AUTHORIZING_GROUP_DISCONNECT_REQUESTED", "SETUP_NESTED_GROUP_CONNECT_ACCEPTED", "SETUP_NESTED_GROUP_CONNECT_DECLINED", "SETUP_NESTED_GROUP_CONNECT_REQUESTED", "SETUP_NESTED_GROUP_DISCONNECT_ACCEPTED", "SETUP_NESTED_GROUP_DISCONNECT_DECLINED", "SETUP_NESTED_GROUP_DISCONNECT_REQUESTED", "TRANSFER_ACCESS_PROFILE_OWNERSHIP_ACCEPTED", "TRANSFER_ACCESS_PROFILE_OWNERSHIP_DECLINED", "TRANSFER_ACCESS_PROFILE_OWNERSHIP_REQUESTED", "TRANSFER_APPLICATION_ADMINISTRATION_ACCEPTED", "TRANSFER_APPLICATION_ADMINISTRATION_DECLINED", "TRANSFER_APPLICATION_ADMINISTRATION_REQUESTED", "TRANSFER_APPLICATION_OWNERSHIP_ACCEPTED", "TRANSFER_APPLICATION_OWNERSHIP_DECLINED", "TRANSFER_APPLICATION_OWNERSHIP_REQUESTED", "TRANSFER_GROUP_ON_SYSTEM_OWNERSHIP_ACCEPTED", "TRANSFER_GROUP_ON_SYSTEM_OWNERSHIP_DECLINED", "TRANSFER_GROUP_ON_SYSTEM_OWNERSHIP_REQUESTED", "TRANSFER_ORGANIZATIONAL_UNIT_OWNERSHIP_ACCEPTED", "TRANSFER_ORGANIZATIONAL_UNIT_OWNERSHIP_DECLINED", "TRANSFER_ORGANIZATIONAL_UNIT_OWNERSHIP_REQUESTED", "TRANSFER_PROVISIONED_SYSTEM_ADMINISTRATION_ACCEPTED", "TRANSFER_PROVISIONED_SYSTEM_ADMINISTRATION_DECLINED", "TRANSFER_PROVISIONED_SYSTEM_ADMINISTRATION_REQUESTED", "TRANSFER_PROVISIONED_SYSTEM_CONTENT_ADMINISTRATION_ACCEPTED", "TRANSFER_PROVISIONED_SYSTEM_CONTENT_ADMINISTRATION_DECLINED", "TRANSFER_PROVISIONED_SYSTEM_CONTENT_ADMINISTRATION_REQUESTED", "TRANSFER_PROVISIONED_SYSTEM_OWNERSHIP_ACCEPTED", "TRANSFER_PROVISIONED_SYSTEM_OWNERSHIP_DECLINED", "TRANSFER_PROVISIONED_SYSTEM_OWNERSHIP_REQUESTED", "TRANSFER_SERVICE_ACCOUNT_ADMINISTRATION_ACCEPTED", "TRANSFER_SERVICE_ACCOUNT_ADMINISTRATION_DECLINED", "TRANSFER_SERVICE_ACCOUNT_ADMINISTRATION_REQUESTED", "UPDATE_GROUP_MEMBERSHIP_ACCEPTED", "UPDATE_GROUP_MEMBERSHIP_DECLINED", "UPDATE_GROUP_MEMBERSHIP_REQUESTED", "UPDATE_LICENSE_ACCEPTED", "UPDATE_LICENSE_DECLINED", "UPDATE_LICENSE_REQUESTED", "VAULT_ACCESS_RESTORED", "VAULT_EXPORTED", "VAULT_PERSONAL_RESET", "VAULT_PERSONAL_SETUP", "VAULT_RECORD_CREATED", "VAULT_RECORD_MODIFIED", "VAULT_RECORD_MOVED_COPIED_SHARED", "VAULT_RECORD_READ", "VAULT_RECORD_REMOVED", "VAULT_RECOVERED", "VERIFY_INTERNAL_ACCOUNT_ACCEPTED", "VERIFY_INTERNAL_ACCOUNT_DECLINED", "VERIFY_INTERNAL_ACCOUNT_REQUESTED", "WEBHOOK_CREATED", "WEBHOOK_MODIFIED", "WEBHOOK_REMOVED",
				),
			),
		},
	}
	schemaAttrs["url"] = rsschema.StringAttribute{
		Required: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthBetween(0, 512),
		},
	}
	schemaAttrs["uuid"] = rsschema.StringAttribute{
		Computed:      true,
		PlanModifiers: []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
	}
	schemaAttrs["verbose_payloads"] = rsschema.BoolAttribute{
		Computed: true,
		Optional: true,
		Default:  booldefault.StaticBool(false),
	}
	return schemaAttrs
}
func resourceSchemaAttrsWebhookWebhookLinkableWrapperRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	schemaAttrs["items"] = rsschema.ListNestedAttribute{
		NestedObject: rsschema.NestedAttributeObject{
			Attributes: resourceSchemaAttrsWebhookWebhookRO(recurse),
		},
		Optional: true,
	}
	return schemaAttrs
}
func resourceSchemaAttrsWebhookWebhook_additionalObjectsRO(recurse bool) map[string]rsschema.Attribute {
	schemaAttrs := make(map[string]rsschema.Attribute)
	{
		attr := rsschema.SingleNestedAttribute{
			Attributes: resourceSchemaAttrsAuditInfoRO(recurse),
		}
		attr.Computed = true
		schemaAttrs["audit"] = attr
	}

	return schemaAttrs
}
