// Code generated by "terraform-provider-keyhub-generator"; DO NOT EDIT.

//lint:ignore U1000 Ignore unused functions in generated code
package provider

import (
	"context"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	keyhub "github.com/topicuskeyhub/sdk-go"
	keyhubaccount "github.com/topicuskeyhub/sdk-go/account"
	keyhubcertificate "github.com/topicuskeyhub/sdk-go/certificate"
	keyhubclient "github.com/topicuskeyhub/sdk-go/client"
	keyhubdirectory "github.com/topicuskeyhub/sdk-go/directory"
	keyhubgroup "github.com/topicuskeyhub/sdk-go/group"
	keyhubgroupclassification "github.com/topicuskeyhub/sdk-go/groupclassification"
	keyhubmodel "github.com/topicuskeyhub/sdk-go/models"
	keyhuborganizationalunit "github.com/topicuskeyhub/sdk-go/organizationalunit"
	keyhubserviceaccount "github.com/topicuskeyhub/sdk-go/serviceaccount"
	keyhubsystem "github.com/topicuskeyhub/sdk-go/system"
	keyhubvaultrecord "github.com/topicuskeyhub/sdk-go/vaultrecord"
)

type contextKey int

const (
	keyHubClientKey contextKey = iota
)

func sliceToTF[T any](elemType attr.Type, vals []T, toValue func(T, *diag.Diagnostics) attr.Value) (attr.Value, diag.Diagnostics) {
	var diags diag.Diagnostics
	ret := make([]attr.Value, 0, len(vals))
	for _, curVal := range vals {
		ret = append(ret, toValue(curVal, &diags))
	}
	return types.ListValue(elemType, ret)
}

func tfToSlice[T any](val basetypes.ListValue, toValue func(attr.Value, *diag.Diagnostics) T) ([]T, diag.Diagnostics) {
	var diags diag.Diagnostics
	vals := val.Elements()
	ret := make([]T, 0, len(vals))
	for _, curVal := range vals {
		ret = append(ret, toValue(curVal, &diags))
	}
	return ret, diags
}

func int32PToInt64P(in *int32) *int64 {
	if in == nil {
		return nil
	}
	ret := int64(*in)
	return &ret
}

func int64PToInt32P(in *int64) *int32 {
	if in == nil {
		return nil
	}
	ret := int32(*in)
	return &ret
}

func stringerToTF[T fmt.Stringer](val *T) attr.Value {
	if val == nil {
		return types.StringNull()
	}
	return types.StringValue((*val).String())
}

func timeToTF(val time.Time) attr.Value {
	ret, _ := val.MarshalText()
	return types.StringValue(string(ret))
}

func timePointerToTF(val *time.Time) attr.Value {
	if val == nil {
		return types.StringNull()
	}
	ret, _ := val.MarshalText()
	return types.StringValue(string(ret))
}

func tfToTime(val basetypes.StringValue) (time.Time, diag.Diagnostics) {
	var diags diag.Diagnostics
	parsed, err := time.Parse(time.RFC3339, val.ValueString())
	if err != nil {
		diags.AddError("Conversion error", fmt.Sprintf("Unable to parse time: %s", err))
	}
	return parsed, diags
}

func tfToTimePointer(val basetypes.StringValue) (*time.Time, diag.Diagnostics) {
	if val.IsNull() || val.IsUnknown() {
		return nil, diag.Diagnostics{}
	}
	parsed, diags := tfToTime(val)
	return &parsed, diags
}

func withUuidToTF(val interface{ GetUuid() *string }) attr.Value {
	if val == nil {
		return types.StringNull()
	}
	return types.StringPointerValue(val.GetUuid())
}

func parsePointer[T any](val basetypes.StringValue, parser func(string) (T, error)) (*T, diag.Diagnostics) {
	if val.IsNull() || val.IsUnknown() {
		return nil, diag.Diagnostics{}
	}
	parsed, diags := parse(val, parser)
	return &parsed, diags
}

func parsePointer2[T any](val basetypes.StringValue, parser func(string) (*T, error)) (*T, diag.Diagnostics) {
	if val.IsNull() || val.IsUnknown() {
		return nil, diag.Diagnostics{}
	}
	parsed, diags := parse(val, parser)
	return parsed, diags
}

func parse[T any](val basetypes.StringValue, parser func(string) (T, error)) (T, diag.Diagnostics) {
	var diags diag.Diagnostics
	parsed, err := parser(val.ValueString())
	if err != nil {
		diags.AddError("Conversion error", fmt.Sprintf("Unable to parse %s: %s", val.ValueString(), err))
	}
	return parsed, diags
}

func parseCastPointer[T any, Z any](val basetypes.StringValue, parser func(string) (Z, error), caster func(Z) T) (*T, diag.Diagnostics) {
	if val.IsNull() || val.IsUnknown() {
		return nil, diag.Diagnostics{}
	}
	parsed, diags := parseCast(val, parser, caster)
	return &parsed, diags
}

func parseCast[T any, Z any](val basetypes.StringValue, parser func(string) (Z, error), caster func(Z) T) (T, diag.Diagnostics) {
	parsed, diags := parse(val, parser)
	var ret T
	if diags.HasError() {
		return ret, diags
	}
	return caster(parsed), diags
}

func findFirst[T keyhubmodel.Linkableable](wrapper interface{ GetItems() []T }, name string, uuid *string, err error) (T, diag.Diagnostics) {
	var diags diag.Diagnostics
	var noVal T
	if err != nil {
		diags.AddError("Client Error", fmt.Sprintf("Unable to read %s, got error: %s", name, err))
		return noVal, diags
	}
	if len(wrapper.GetItems()) == 0 {
		diags.AddError("Client Error", fmt.Sprintf("Unable to find %s with UUID %s", name, *uuid))
		return noVal, diags
	}
	return wrapper.GetItems()[0], nil

}

func findGroupGroupPrimerByUUID(ctx context.Context, uuid *string) (keyhubmodel.GroupGroupPrimerable, diag.Diagnostics) {
	if uuid == nil {
		return nil, diag.Diagnostics{}
	}
	client := ctx.Value(keyHubClientKey).(*keyhub.KeyHubClient)
	wrapper, err := client.Group().Get(ctx, &keyhubgroup.GroupRequestBuilderGetRequestConfiguration{
		QueryParameters: &keyhubgroup.GroupRequestBuilderGetQueryParameters{
			Uuid: []string{*uuid},
		},
	})
	return findFirst[keyhubmodel.GroupGroupable](wrapper, "group", uuid, err)
}

func findDirectoryAccountDirectoryPrimerByUUID(ctx context.Context, uuid *string) (keyhubmodel.DirectoryAccountDirectoryPrimerable, diag.Diagnostics) {
	if uuid == nil {
		return nil, diag.Diagnostics{}
	}
	client := ctx.Value(keyHubClientKey).(*keyhub.KeyHubClient)
	wrapper, err := client.Directory().Get(ctx, &keyhubdirectory.DirectoryRequestBuilderGetRequestConfiguration{
		QueryParameters: &keyhubdirectory.DirectoryRequestBuilderGetQueryParameters{
			Uuid: []string{*uuid},
		},
	})
	return findFirst[keyhubmodel.DirectoryAccountDirectoryable](wrapper, "directory", uuid, err)
}

func findOrganizationOrganizationalUnitPrimerByUUID(ctx context.Context, uuid *string) (keyhubmodel.OrganizationOrganizationalUnitPrimerable, diag.Diagnostics) {
	if uuid == nil {
		return nil, diag.Diagnostics{}
	}
	client := ctx.Value(keyHubClientKey).(*keyhub.KeyHubClient)
	wrapper, err := client.Organizationalunit().Get(ctx, &keyhuborganizationalunit.OrganizationalunitRequestBuilderGetRequestConfiguration{
		QueryParameters: &keyhuborganizationalunit.OrganizationalunitRequestBuilderGetQueryParameters{
			Uuid: []string{*uuid},
		},
	})
	return findFirst[keyhubmodel.OrganizationOrganizationalUnitable](wrapper, "organizational unit", uuid, err)
}

func findCertificateCertificatePrimerByUUID(ctx context.Context, uuid *string) (keyhubmodel.CertificateCertificatePrimerable, diag.Diagnostics) {
	if uuid == nil {
		return nil, diag.Diagnostics{}
	}
	client := ctx.Value(keyHubClientKey).(*keyhub.KeyHubClient)
	wrapper, err := client.Certificate().Get(ctx, &keyhubcertificate.CertificateRequestBuilderGetRequestConfiguration{
		QueryParameters: &keyhubcertificate.CertificateRequestBuilderGetQueryParameters{
			Uuid: []string{*uuid},
		},
	})
	return findFirst[keyhubmodel.CertificateCertificateable](wrapper, "certificate", uuid, err)
}

func findProvisioningProvisionedSystemPrimerByUUID(ctx context.Context, uuid *string) (keyhubmodel.ProvisioningProvisionedSystemPrimerable, diag.Diagnostics) {
	if uuid == nil {
		return nil, diag.Diagnostics{}
	}
	client := ctx.Value(keyHubClientKey).(*keyhub.KeyHubClient)
	wrapper, err := client.System().Get(ctx, &keyhubsystem.SystemRequestBuilderGetRequestConfiguration{
		QueryParameters: &keyhubsystem.SystemRequestBuilderGetQueryParameters{
			Uuid: []string{*uuid},
		},
	})
	return findFirst[keyhubmodel.ProvisioningProvisionedSystemable](wrapper, "provisioned system", uuid, err)
}

func findGroupGroupClassificationPrimerByUUID(ctx context.Context, uuid *string) (keyhubmodel.GroupGroupClassificationPrimerable, diag.Diagnostics) {
	if uuid == nil {
		return nil, diag.Diagnostics{}
	}
	client := ctx.Value(keyHubClientKey).(*keyhub.KeyHubClient)
	wrapper, err := client.Groupclassification().Get(ctx, &keyhubgroupclassification.GroupclassificationRequestBuilderGetRequestConfiguration{
		QueryParameters: &keyhubgroupclassification.GroupclassificationRequestBuilderGetQueryParameters{
			Uuid: []string{*uuid},
		},
	})
	return findFirst[keyhubmodel.GroupGroupClassificationable](wrapper, "group classification", uuid, err)
}

func findClientClientApplicationPrimerByUUID(ctx context.Context, uuid *string) (keyhubmodel.ClientClientApplicationPrimerable, diag.Diagnostics) {
	if uuid == nil {
		return nil, diag.Diagnostics{}
	}
	client := ctx.Value(keyHubClientKey).(*keyhub.KeyHubClient)
	wrapper, err := client.Client().Get(ctx, &keyhubclient.ClientRequestBuilderGetRequestConfiguration{
		QueryParameters: &keyhubclient.ClientRequestBuilderGetQueryParameters{
			Uuid: []string{*uuid},
		},
	})
	return findFirst[keyhubmodel.ClientClientApplicationable](wrapper, "client application", uuid, err)
}

func findAuthAccountPrimerByUUID(ctx context.Context, uuid *string) (keyhubmodel.AuthAccountPrimerable, diag.Diagnostics) {
	account, diag := findAuthAccountByUUID(ctx, uuid)
	if account == nil {
		return account, diag
	}
	return &account.(*keyhubmodel.AuthAccount).AuthAccountPrimer, diag
}

func findAuthAccountByUUID(ctx context.Context, uuid *string) (keyhubmodel.AuthAccountable, diag.Diagnostics) {
	if uuid == nil {
		return nil, diag.Diagnostics{}
	}
	client := ctx.Value(keyHubClientKey).(*keyhub.KeyHubClient)
	wrapper, err := client.Account().Get(ctx, &keyhubaccount.AccountRequestBuilderGetRequestConfiguration{
		QueryParameters: &keyhubaccount.AccountRequestBuilderGetQueryParameters{
			Uuid: []string{*uuid},
		},
	})
	return findFirst[keyhubmodel.AuthAccountable](wrapper, "account", uuid, err)
}

func findServiceaccountServiceAccountPrimerByUUID(ctx context.Context, uuid *string) (keyhubmodel.ServiceaccountServiceAccountPrimerable, diag.Diagnostics) {
	if uuid == nil {
		return nil, diag.Diagnostics{}
	}
	client := ctx.Value(keyHubClientKey).(*keyhub.KeyHubClient)
	wrapper, err := client.Serviceaccount().Get(ctx, &keyhubserviceaccount.ServiceaccountRequestBuilderGetRequestConfiguration{
		QueryParameters: &keyhubserviceaccount.ServiceaccountRequestBuilderGetQueryParameters{
			Uuid: []string{*uuid},
		},
	})
	return findFirst[keyhubmodel.ServiceaccountServiceAccountable](wrapper, "service account", uuid, err)
}

func findVaultVaultRecordPrimerByUUID(ctx context.Context, uuid *string) (keyhubmodel.VaultVaultRecordPrimerable, diag.Diagnostics) {
	if uuid == nil {
		return nil, diag.Diagnostics{}
	}
	client := ctx.Value(keyHubClientKey).(*keyhub.KeyHubClient)
	wrapper, err := client.Vaultrecord().Get(ctx, &keyhubvaultrecord.VaultrecordRequestBuilderGetRequestConfiguration{
		QueryParameters: &keyhubvaultrecord.VaultrecordRequestBuilderGetQueryParameters{
			Uuid: []string{*uuid},
		},
	})
	return findFirst[keyhubmodel.VaultVaultRecordable](wrapper, "vault record", uuid, err)
}
